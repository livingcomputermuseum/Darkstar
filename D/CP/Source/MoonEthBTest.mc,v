head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.09;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.09;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ Copyright (C) 1980, 1981  by Xerox Corporation. All rights reserved. } {File name:  MoonEthBTest.mc Description: EtherNet Controller Simple Tests used in Boot-diagnostic, Author: S. Tom TXC  , Created: November 3, 1980 12:43 PM, Last edited: by S. Tom TXC  , September 17, 1981  4:37 PM, EStrobe, Dribble edited: by JxK , June 4, 1981  6:46 PM edited: by S. Tom TXC  , May 22, 1981  2:11 PM edited: by S. Tom TXC  , April 30, 1981  7:53 PM, edited: by S. Tom TXC  , April 3, 1981  5:08 PM edited: by S. Tom TXC  , November 13, 1980  4:22 PM}{ R Registers }RegDef[ErrStatus, R, 0];RegDef[TestC, R, 2];RegDef[rMPadd, R, 3];RegDef[rEDsave, R, 4];RegDef[rEDtmp, R, 5];RegDef[rGen, R, 7];RegDef[rWork, R, 9];RegDef[rEtemp, R, 0A];RegDef[rEadr, R, 0C];{RegDef[rEcnt, R, 0D]; ***** temporarily use Reg-8 to avoid conflict with IOP}RegDef[rEcnt, R, 8];{RegDef[uTask2done, R, 6]; {Packet Coming indicator}}{RH Registers}RegDef[rhReturn, RH, 2];RegDef[rhMPadd, RH, 3];RegDef[rhEDtmp, RH, 5];RegDef[rhEadr, RH, 0C];{ U Registers }RegDef[uPassC, U, 30];RegDef[uTestCtl, U, 31]; {left byte: 1st Test number; right byte: last Test number}RegDef[uLoopCtl, U, 32]; {0: no loop; 0FFFF: loop forever}RegDef[uTask2done, U, 33]; {Packet Coming indicator}RegDef[uCLoopTR, U, 038]; {LoopBack and LoopTR bits}RegDef[uLoopNet, U, 3C]; {0: LoopBack in Controller; 0FFFF: LoopBack from Net}RegDef[uTrnCnt, U, 40];RegDef[uT2count, U, 49]; {record passes to Task 2}RegDef[uEDsave, U, 05B];    {rA=rEDtmp}RegDef[uRcvAdd, U, 05E];    {rA=rEDtmp}RegDef[uRetry, U, 39]; {Retry count = 8}RegDef[uTrnLsts, U, 087];  {rA=rEcnt, fZ=EStrobe}RegDef[uC1111, U, 0C0]; {constatnt 1111}RegDef[uPreamb, U, 0C7];RegDef[uRcvSize, U, 0C8];RegDef[uRcvBufs, U, 0C9];RegDef[uRcvBufa, U, 0CD];RegDef[uTrnBufs, U, 0D7];RegDef[uTrnBufa, U, 0DB];RegDef[uTrnLsta, U, 0DC];Set[cAligCRC, 14]; {Align and CRC bits}Set[cDefMin, 50]; {Minimun Defer time 32 usec, will change to 40 usec}Set[cDefTrn, 5]; {Defer and EnTrn bits}Set[cDefTime, 84]; {Defer time is 51.2 usec}Set[cLoopBLR, 0D]; {LoopBack, LocalLoop, and EnRcv bits}Set[cLoopBNR, 9]; {LoopBack and EnRcv bits}Set[cLoopSth, 8];Set[cLoopStl, 80];Set[cLoopLoc, 0C]; {to set LoopBack and LoopLoc bits}Set[cLoopStl, 80]; {just RcvMode bit in lower 8-bits of Status}Set[cLpBCStl, 84]; {RcvMode and Bad CRC bit in Status}Set[cLpFlag, 5]; {indicate a packet comes in before Transmit during LoopBack}Set[cMaskh, 1F]; {LoopBack, LocalLoop, EnableRcv, LastWord, EnableTrn bits}Set[cRcv, 1]; {Enable Receive}Set[cRcvSt, 80];Set[cStAlig, 10]; {Bad Alig with Good CRC Status}Set[cStCol, 40]; {Collision bit in Status reg.}Set[cStColOv, 48]; {Collision and OverRun bits in Status reg.}Set[cStOv, 8]; {OverRun bit in Status reg.}Set[cStTrn, 1]; {EnableTrn bit in Status reg., must shift left 8 bits}Set[cStUnd, 20]; {UnderRun bit in Status reg.}Set[cTrn, 1]; {EnableTrn}Set[cTrnLast, 3]; {LastWord and EnTrn bits}Set[cTrnSth, 1E];Set[cTrnStl, 0];Set[DispTask, 1];Set[DispCtl, 43]; {Control word to start display task doing only refreshes}Set[EmuTask, 0];Set[EtherTask, 2];	SetTask[EmuTask], StartAddress[Go];TERROR1:	  ClrIntErr,CANCELBR[$,0F],   c*, at[0];TERROR:	  GOTO[TERROR],   c*;{Start the display task.}{Must clear many CSBs' locations, currently use command lines to do the clean}Go:	R0 ¬ CONF, CANCELBR[$,0F],	c1;	R0 ¬ R0 and 20,	c2;	EICtl ¬ 0,	c3;	EOCtl ¬ 0,	c1;	R0 ¬ R0 , ZeroBr,	c2;	rGen ¬ DispCtl,BRANCH[Go1 ,Go2 ],	c3;Go1:      GOTO[RunGood],	c1;Go2:	DCtl ¬ rGen LRot0,	c1; 	rEDtmp ¬ 55,	c2;	rEDtmp ¬ rEDtmp LRot8,	c3;	rEDtmp ¬ rEDtmp or 55, {form Preamble bits}	c1;	uPreamb ¬ rEDtmp,	c2;	Noop, {run just once}	c3;{form 4200 in uTrnBufa, part of 14200}	rMPadd ¬ 42,	c1;	rMPadd ¬ (rMPadd LRot8),	c2;	uTrnBufa ¬ rMPadd, {form address 4200H}	c3;{form 4600 in uRcvBufa, part of 14600}	rMPadd ¬ 46,	c1;	rMPadd ¬ (rMPadd LRot8),	c2;	uRcvBufa ¬ rMPadd, {form address 4600H}	c3;	rGen ¬ 8,	c1;	uRetry ¬ rGen,	c2;	Noop,	c3;{setup 1111H in uC1111}Pause:	rGen ¬ 11,	c1;	rGen ¬ (rGen LRot8) or rGen,	c2;	uC1111 ¬ rGen,	c3;{EICtl and EOCtl have been set to all 0's}Btest0:	rEDtmp ¬ 1F,	c1;	rEDtmp ¬ rEDtmp LRot8,	c2;	rEDtmp ¬ rEDtmp or 81,	c3;	rGen ¬ 1F,	c1;	rGen ¬ rGen LRot8,	c2;	rWork ¬ EStatus and rEDtmp,	c3;	[] ¬ rGen xor rWork, ZeroBr,	c1;	TestC ¬ 1, BRANCH[Badt0, $],	c2;{set EOCtl with a value of 7, Defer, LastWord, EnableTrn}Btest1:	rEDsave ¬ 7,	c3;	EOCtl ¬ rEDsave LRot0,	c1;	rGen ¬ 1C,	c2;	rGen ¬ rGen LRot8,	c3;	rWork ¬ EStatus and rEDtmp, 	c1;	[] ¬ rWork xor rGen, ZeroBr,	c2;	TestC ¬ 2, BRANCH[Badt1, $],	c3;{set EICtl with a value of 0F, LoopBack, LoopTR, TurnOff, EnableRcv}{**** IMPORTANT****** must ignore all or partial packet on the Net}Btest2:	EOCtl ¬ 0,	c1;	rEDsave ¬ 0F,	c2;	rEDtmp ¬ rEDtmp xor 80, {rEDtmp had 1F81}	c3;	EICtl ¬ rEDsave LRot0,	c1;	rEDtmp ¬ EStatus and rEDtmp, {ignore RcvMode}	c2;	EICtl ¬ 0, rEDsave ¬ 0,	c3;	rGen ¬ 3, 	c1;	rGen ¬ rGen LRot8,	c2;	rGen ¬ rGen or 1,	c3;	[] ¬ rEDtmp xor rGen, ZeroBr,	c1;	TestC ¬ 3, BRANCH[Badt2, $],	c2;	EOCtl ¬ 0,	c3;	Noop, 	c1;	rEDtmp ¬ 0,pCall2,	c2;	CALL[FifoCk],	c3, at[0,10];	        rEDtmp ¬ ~rEDtmp,       c1, at[0,10,FifoRet];	pCall2,	c2;	CALL[FifoCk],	c3, at[1,10];	        rEDtmp ¬ 0AA,       c1, at[1,10,FifoRet];	rEDtmp ¬ rEDtmp LRot8,pCall2,	c2;	rEDtmp ¬ rEDtmp or 0AA,CALL[FifoCk],	c3, at[2,10];	        rEDtmp ¬ 55,       c1, at[2,10,FifoRet];		rEDtmp ¬ rEDtmp LRot8,pCall2,	c2;	rEDtmp ¬ rEDtmp  or 55,CALL[FifoCk],	c3, at[3,10];	        	FifoCk:   EICtl ¬ cLoopLoc,	c1;          rEDsave ¬ 1	c2;	  EOCtl ¬ cDefTrn,	c3;	  FifoCk1:  Noop,	c1;          EOData ¬ rEDtmp LRot0,	c2;          EStrobe,	c3;	  Noop, {must have enough cycles for FIFO}	c1;	  rEDsave ¬ rEDsave-1,NZeroBr,	c2;	  BRANCH[FifoRead, FifoCk1],	c3;	FifoRead: R6¬ 1,	c1;FifoRead1:[] ¬ EIData xor rEDtmp, ZeroBr,	c2;	  R6 ¬ R6-1, ZeroBr,  BRANCH[FifoErr,$],	c3;	  BRANCH[FifoRead1, FifoDone],	c1;	  	  	FifoErr:  EICtl ¬ 0,CANCELBR[$],	c1;	  EOCtl ¬ 0,pRet2,	c2;          RET[FifoErrRet]	c3;	    FifoDone: EOCtl ¬ 0, pRet2,	c2;          EICtl ¬ 0, RET[FifoRet]	c3;{LoopBack locally a short packet of 15 words included CRC}{allow 32 attemps to loopback}Btest4:	rEDsave ¬ 1, {allow 32D attemps to loopback},	c1, at[3,10,FifoRet];	uTrnCnt ¬ rEDsave,	c2;	Noop,	c3;{setup packet to be looped back in memory, -1 per byte, starting with byte 0FF}	EOCtl ¬ 0,	c1, at[0,10,ReTryRet];	EICtl ¬ 0,	c2;	TestC ¬ 5, {real TASK2 starts when TestC is 8}	c3;			rhMPadd ¬ 1,	c1;	rMPadd ¬ uTrnBufa, {memory address 14200}	c2;	R1¬1,	c3;	rEDsave ¬ 0D, 	c1;	rEDtmp ¬ 1,pCall0,	c2;	rEDtmp ¬ ~rEDtmp,CALL[MemStore],	c3, at[0,10];	        R1¬0,               c1, at[0,10,MemSRet];EndWB3:	rEDtmp ¬ 0C0,	c2;{13 words -1 per Byte's (with first byte 0FF) CRC is C0E9 0CE2}	rEDtmp ¬ rEDtmp LRot8,	c3;	rEDtmp ¬ rEDtmp or 0E9,	c1;	rEDsave ¬ 1,pCall0,	c2;	rGen ¬ 0C,CALL[MemStore],	c3, at[1,10];	rEDsave ¬ 1,	c1, at[1,10,MemSRet];	rEDtmp ¬ rGen LRot8,pCall0,	c2;	rEDtmp ¬ rEDtmp or 0E2,CALL[MemStore],	c3, at[2,10];	{Clear the Receiving buffer in memory, 16 words}	rEDsave ¬ 10,	c1, at[2,10,MemSRet];	rEDtmp ¬ uRcvBufa,	c2;	rMPadd ¬ uRcvBufa, {RcvBuff address}	c3;	ClrBuf:	R1¬3,	c1;	pCall0,	c2;	CALL[MemStore],	c3, at[3,10];         	ClrFin:	rEtemp ¬ 1,	c1, at[3,10,MemSRet];	TestC ¬ 8,	c2;	rEDtmp ¬ 20,	c3;		rEDtmp ¬ rEDtmp LRot8, {form a count of 8192}	c1;{set LoopBack, LocalLoop, EnRcv bits in EICtl}	rGen ¬ 0E0 , {wake up EtherTask}	c2;	R1 ¬ cLoopStl, 	c3;	EICtl ¬ cLoopBLR, 	c1;{wait for Task2 to transmit & receive packet. Allow a delay of 5 msec}Delay4: EOCtl ¬ cTrn,pCall4, {wake up EtherTask}	c2;        uTask2done ¬ 0, CALL[Delay],	c3, at[0,10];CkLoopL: rEDsave ¬ 0F,               c1, at[0,10,NoReTyRet];         pCall1,	c2;	 CALL[MemCheck],	c3, at[0,10];WdsGood: Noop,	c1, at[0,10,CheckRet];	Noop,	c2;	GOTO[Btest5],	c3;	{LoopBack locally 15 words included Bad CRC in order to check CRC logic}{allow 32 attemps to loopback}Btest5:	EOCtl ¬ 0,	c1, at[1,10,ReTryRet];        EICtl ¬ 0,	c2;	TestC ¬ 6, {real TASK2 starts when TestC is 8}	c3;{15 words packet has been set up in memory started at 14200,  modify the last word to make a packet with bad CRC}	rhMPadd ¬ 1,	c1;	rMPadd ¬ uTrnBufa,	c2;	rMPadd ¬ rMPadd or 0E,	c3;	MAR ¬ [rhMPadd, rMPadd + 0],	c1;	Noop,	c2;	rWork ¬ MD, {2nd word od CRC}	c3;	MAR ¬ [rhMPadd, rMPadd + 0],	c1;	MDR ¬ rWork xor 80, {invert the last bit}	c2;	Noop, 	c3;CleanD:	rEtemp ¬ 1,	c1;	TestC ¬ 8,	c2;	rEDtmp ¬ 20,	c3;		rEDtmp ¬ rEDtmp LRot8, {form a count of 8192}	c1;	rGen ¬ 0E0, 	c2;	R1 ¬ cLpBCStl, 	c3;		EICtl ¬ cLoopBLR, 	c1;	{set LoopBack, LocalLoop, EnRcv bits in EICtl}{wait for Task2 to transmit & receive packet. Allow a delay of 5 msec}Delay5:	EOCtl ¬ cTrn,pCall4, {wake up EtherTask}	c2;        uTask2done ¬ 0, CALL[Delay],	c3, at[1,10];CkLoopC: rEDsave ¬ 0F,               c1, at[1,10,NoReTyRet];         pCall1,	c2;	 CALL[MemCheck],	c3, at[1,10];   {LoopBack from the Net a short packet of 15 words included CRC}{allow 32 attemps to loopback from the net}Btest6:	rEDsave ¬ 20, {allow 32D attemps to loopback},	c1, at[1,10,CheckRet];	uTrnCnt ¬ rEDsave,	c2;	Noop,	c3;{setup packet to be looped back in memory, +1 per byte}	EOCtl ¬ 0,	c1, at[2,10,ReTryRet];        EICtl ¬ 0,	c2;	TestC ¬ 7, {real TASK2 starts when TestC is 8}	c3;	        rhMPadd ¬ 1,	c1;	rMPadd ¬ uTrnBufa, {memory address 14200}	c2;	R1¬2, 	c3;		rEDsave ¬ 0D, 	c1;	rEDtmp ¬ 1,pCall0,	c2;	CALL[MemStore],	c3, at[4,10];	        R1¬0,               c1, at[4,10,MemSRet];EndWB2:	rEDtmp ¬ 0B2, 	c2;{13 words +1 per Byte's CRC is B28B, 07BF}	rEDtmp ¬ rEDtmp LRot8,	c3;	rEDtmp ¬ rEDtmp or 8B,	c1;	rEDsave ¬ 1,pCall0,	c2;	rGen ¬ 07,CALL[MemStore],	c3, at[5,10];	rEDsave ¬ 1,	c1, at[5,10,MemSRet];	rEDtmp ¬ rGen LRot8,pCall0,	c2;	rEDtmp ¬ rEDtmp or 0BF,CALL[MemStore],	c3, at[6,10];	{Clear the Receiving buffer in memory, 16 words}	rEDsave ¬ 10,	c1, at[6,10,MemSRet];	rEDtmp ¬ uRcvBufa,	c2;	rMPadd ¬ uRcvBufa, {RcvBuff address}	c3;	ClrMem:	R1¬3,	c1;	pCall0,	c2;	CALL[MemStore],	c3, at[7,10];ClrDone: Noop,	c1, at[7,10,MemSRet];	 rEtemp ¬ 1,	c2;	 TestC ¬ 8,	c3;	 rGen ¬ 0E0, {reset the flag}	c1;	 rEDtmp ¬ 20,	c2;	 rEDtmp ¬ rEDtmp LRot8, {form a count of 8192}	c3;{set LoopBack, EnRcv bit in EICtl}SLpCtl:	R1 ¬ cLoopSth, {does go out to Net}	c1;	R1 ¬ R1 LRot8, {wake up EtherTask}	c2;{wait for Task2 to transmit & receive packet. Allow a delay of 5 msec}Delay7:	 R1 ¬ R1 or cLoopStl, {LoopBack Status}	c3;         EICtl ¬ cLoopBNR,	c1;         EOCtl ¬ cTrn,pCall4, {wake up EtherTask}	c2;         uTask2done ¬ 0,CALL[Delay],	c3, at[2,10]; CkLoopB: rEDsave ¬ 0F,              c1, at[2,10,NoReTyRet];         pCall1,	c2;	 CALL[MemCheck],	c3, at[2,10];{*********** check out the Defer ***************}Btest9:	EICtl ¬ 0, rEcnt ¬ 0,	c1, at[2,10,CheckRet];	EOCtl ¬ 0,	c2;	rEDtmp ¬ cDefTime,	c3;	TestC ¬ 9,	c1;	EOCtl ¬ cDefTrn,	c2;	uTask2done ¬ ~rMPadd xor rMPadd,	c3;DefDly:	rEDtmp ¬ rEDtmp - 1, ZeroBr,	c1;	[] ¬ rEcnt, ZeroBr, BRANCH[$, DefTmup],	c2;	rGen ¬ rEDtmp - cDefMin, BRANCH[$, DefDly],	c3;	[] ¬ rGen, NegBr,	c1;	BRANCH[ShortT, $],	c2;	Noop, GOTO[DefVerf],	c3;DefTmup:	CANCELBR[$],	c3;DefVerf:	[] ¬ rEcnt, NZeroBr, {set in Task #2}	c1;	rEDtmp ¬ cStTrn, BRANCH[NonWake, $],	c2;	rEDtmp ¬ rEDtmp LRot8,	c3;	[] ¬ EStatus and rEDtmp, NZeroBr, {EnableTrn bit reset?}	c1;	uTask2done ¬ ~rMPadd xor rMPadd, BRANCH[BadSt9, $],	c2;	TestC ¬ 7, GOTO[RunGood],	c3;ShortT:	 GOTO[t9Stop],	c3;BadSt9:	 GOTO[t9Stop],	c3;NonWake:	GOTO[t9Stop],	c3;RunGood:	GOTO[RunGood],	c*,at[0FFF];Delay:	[] ¬ uTask2done,NZeroBr,	c1;	rEDtmp ¬ rEDtmp - 1, ZeroBr, BRANCH[$, LLDone],	c2;	BRANCH[Delay, TimeOut],	c3;	LLDone:	 rMPadd ¬ cLpFlag, CANCELBR[$,1],	c3;{special case?}		[] ¬ uTask2done xor rMPadd, ZeroBr, c1;	rEDtmp ¬ rEtemp and cStColOv,BRANCH[$, SpCaseB],	c2;{Collision/OverRun?}			[] ¬ rEDtmp, NZeroBr, c3;		rEDtmp ¬ cStAlig, BRANCH[$, CollOrOv],	c1;{look at Alig}		[] ¬ rEtemp and rEDtmp,NZeroBr, 	c2;	rGen ¬ rGen LRot8,BRANCH[$, AlignBad],	c3;		CkLoop: rEtemp ¬ rEtemp and ~rGen,c1;	[] ¬ rEtemp xor R1, ZeroBr,	c2;{check status}	[] ¬ uTrnLsts, ZeroBr, BRANCH[StatusBad, $],	c3;{check Tran count}	        BRANCH[TranBad, $],	c1;{check Rcv count}	        [] ¬ uRcvSize, ZeroBr, 	c2;	BRANCH[RecBad, $],	c3;	     Noop,	c1;             pRet4,	c2;	     RET[NoReTyRet],	c3;{Task2 hung-up, something is wrong, must reset the controller}TimeOut:EOCtl ¬ 0,	c1; 	EICtl ¬ 0,pRet4,	c2;	EStrobe, RET[TimeOutRet], {to get out possible jam}	c3;		CollOrOv:  rGen ¬ uTrnCnt,	c2;	   rGen ¬ rGen - 1, ZeroBr,	c3;	   uTrnCnt ¬ rGen, BRANCH[RetryIt1, $],	c1;	    pRet4,	c2;	    RET[CollOrOvRet],	c3;	    RetryIt1:   EOCtl ¬ 0, pRet4,GOTO[RetryIt2],	c2;{a packet coming before Transmit started, so restart this LoopBack Local}SpCaseB:	Noop,	c3;NoLpLc:	rGen ¬ uTrnCnt,	c1;	rGen ¬ rGen - 1, ZeroBr,	c2;	uTrnCnt ¬ rGen, BRANCH[RetryIt, $],	c3;	    Noop,	c1;            pRet4,	c2;	    RET[RecBeforeTranRet],	c3;	    	    		    RetryIt:    EOCtl ¬ 0,	c1;            EICtl ¬ 0, pRet4,	c2;RetryIt2:   EOCtl ¬ 0, RET[ReTryRet],	c3;	    AlignBad:   Noop,	c1;            pRet4,	c2;	    RET[AlignBadRet],	c3;	    StatusBad:  CANCELBR[$],	c1;            pRet4,	c2;	    RET[StatusBadRet],	c3;	    TranBad:    pRet4,	c2;	    RET[TranBadRet],	c3;	    RecBad:      Noop,	c1;             pRet4,	c2;	     RET[RecBadRet],	c3;	    MemStore:    MAR  ¬ [rhMPadd, rMPadd + 0],	c1;	     MDR ¬ rEDtmp, 	c2;	     rEtemp ¬ rEDtmp and 0FF,	c3;	    Xbus ¬ R1 LRot0, XDisp ,	c1;	    DISP4[Pattern],	c2;Pattern:    GOTO[Block],         c3, at[0, 10, Pattern];	    rEtemp ¬ rEtemp-1,GOTO[Sub1],           c3, at[1, 10, Pattern];	    rEtemp ¬ rEtemp+1,GOTO[ADD1],      c3, at[2, 10, Pattern];	    rEDtmp ¬ rMPadd+1,GOTO[Block],      c3, at[3, 10, Pattern];ADD1:       rEDtmp ¬ rEtemp LRot8 ,	c1;	    rEtemp ¬ rEtemp+1,	c2;	    rEDtmp ¬ rEDtmp or rEtemp,GOTO[Block],	c3;	    Sub1:       rEDtmp ¬ rEtemp LRot8 ,	c1;	    rEtemp ¬ rEtemp-1,	c2;	    rEDtmp ¬ rEDtmp or rEtemp,GOTO[Block],	c3;Block:      rEDsave ¬ rEDsave - 1,ZeroBr,	c1;	    rMPadd ¬ rMPadd+1,BRANCH[$, MemDone],	c2;            GOTO[MemStore],	c3;	    		MemDone:    Noop,	c3;            Noop,	c1;	    pRet0,	c2;            RET[MemSRet],	c3;MemCheck:    R1 ¬ uRcvBufa,	c1;	     rMPadd ¬ uTrnBufa, 	c2;	     RH1¬ 1,	c3;	    MemCheck1:    MAR  ¬ [rhMPadd, rMPadd + 0],	c1;	     RH1¬ 1, 	c2;	     rEDtmp ¬ MD,	c3;	     MAR  ¬ [RH1, R1 + 0],	c1;	     Noop, 	c2;	     rGen ¬ MD,	c3;            [] ¬ rEDtmp xor rGen, ZeroBr,	c1;	    BRANCH[CheckErr, Check], 	c2;CheckErr:   Noop,	c3;            Noop,	c1;	    pRet1,	c2;            RET[CkErrRet]	c3;Check:      R1 ¬ R1+1,	c3;            rEDsave ¬ rEDsave - 1,ZeroBr,	c1;	    rMPadd ¬ rMPadd+1,BRANCH[$, CkDone],	c2;            GOTO[MemCheck1],	c3;		CkDone:     Noop,	c3;            Noop,	c1;	    pRet1,	c2;            RET[CheckRet],	c3;	    	    Badt0:	GOTO[t0Stop],	c3;t0Stop:	GOTO[t0Stop],	c*,at[0E0];Badt1:	GOTO[t1Stop],	c1;t1Stop:	GOTO[t1Stop],	c*,at[0E1];Badt2:	GOTO[t2Stop],	c3;t2Stop:	GOTO[t2Stop],	c*,at[0E2];FifoErr0:GOTO[FifoErr0],c*,at[0,10,FifoErrRet];FifoErr1:GOTO[FifoErr1],c*,at[1,10,FifoErrRet];FifoErr2:GOTO[FifoErr2],c*,at[2,10,FifoErrRet];FifoErr3:GOTO[FifoErr3],c*,at[3,10,FifoErrRet];Badt40:	GOTO[Badt40],	c*, at[0,10,TimeOutRet];Badt50:	GOTO[Badt50],	c*, at[1,10,TimeOutRet];Badt70:	GOTO[Badt70],	c*, at[2,10,TimeOutRet];Badt41:	GOTO[Badt41],	c*, at[0,10,RecBeforeTranRet];Badt51:	GOTO[Badt51],	c*, at[1,10,RecBeforeTranRet];Badt71:	GOTO[Badt71],	c*, at[2,10,RecBeforeTranRet];Badt42:	GOTO[Badt42],	c*, at[0,10,CollOrOvRet];Badt52:	GOTO[Badt52],	c*, at[1,10,CollOrOvRet];Badt72:	GOTO[Badt72],	c*, at[2,10,CollOrOvRet];Badt43:	GOTO[Badt43],	c*, at[0,10,AlignBadRet];Badt53:	GOTO[Badt53],	c*, at[1,10,AlignBadRet];Badt73:	GOTO[Badt73],	c*, at[2,10,AlignBadRet];Badt44:	GOTO[Badt44],	c*, at[0,10,StatusBadRet];Badt54:	GOTO[Badt54],	c*, at[1,10,StatusBadRet];Badt74:	GOTO[Badt74],	c*, at[2,10,StatusBadRet];Badt45:	GOTO[Badt45],	c*, at[0,10,TranBadRet];Badt55:	GOTO[Badt55],	c*, at[1,10,TranBadRet];Badt75:	GOTO[Badt55],	c*, at[2,10,TranBadRet];Badt46:	GOTO[Badt46],   c*, at[0,10,RecBadRet];Badt56:	GOTO[Badt56],   c*, at[1,10,RecBadRet];Badt76:	GOTO[Badt76],   c*, at[2,10,RecBadRet];Badt47:	GOTO[Badt47],	c*, at[0,10,CkErrRet];Badt57:	GOTO[Badt57],	c*, at[1,10,CkErrRet];Badt77:	GOTO[Badt77],	c*, at[2,10,CkErrRet];t9Stop:	GOTO[t9Stop],	c*,at[0F6];{**************** TASK #2 *****************}	SetTask[EtherTask]; StartAddress[CkTest];{This is to facilitate for looping a set of tests; all tests are share one TASK, Task 2.}{ Do nothing if TestC has 7 or less}CkTest:	CANCELBR[$, 0F],	c1;	[] ¬ TestC and 8, NZeroBr,	c2;	rhEadr ¬ 1, BRANCH[CkTest, $],	c3;	Ybus ¬ TestC and 3, YDisp,	c1;	DISP2[DoTst], {TestC has 8, 9, A, or B}	c2;DoTst:	GOTO[LoopBkS], {TestC = 8}	c3,at[0C,10,DoTst];	GOTO[DefLog], {TestC = 9}	c3,at[0D,10,DoTst];{******** Btest4, 5, 7's Task2 code with 8 in TestC (sick) ********}{Buffer holds 13 data words, & 2 CRC}LoopBkS:rEcnt ¬ uPreamb,	c1;	rEadr ¬ 80, {to make last 2-bits of Preamb 11}	c2;	EOData ¬ rEcnt LRot0,	c3;{send out four words of Preamble bits}	EStrobe,	c1;	EOData ¬ rEcnt LRot0,	c2;	EStrobe,	c3;	EOData ¬ rEcnt LRot0,	c1;	rEcnt ¬ rEcnt or rEadr,	c2;	EStrobe,	c3;	rEadr ¬ uTrnBufa,	c1;	EOData ¬ rEcnt LRot0	c2;	EStrobe,	c3;	Noop,	c1;	Noop,	c2;	rEcnt ¬ 0F, {15 words}	c3;	MAR ¬ rEadr ¬ [rhEadr, rEadr + 0], GOTO[LLoop],	c1;LpbLoop:	MAR ¬ rEadr ¬ [rhEadr, rEadr + 1], EStrobe, YIODisp,	c1;LLoop:	rEcnt ¬ rEcnt - 1, ZeroBr, DISP4[LData, 0E],	c2;LData:	EOData ¬ MD, BRANCH[LpbLoop, $],	c3,at[0E,10,LData];	EStrobe,	c1;	EOCtl ¬ cTrnLast,	c2;	EStrobe, {This is the actual last word}	c3;	uTrnLsts ¬ rEcnt,	c1;	rEcnt ¬ 15, {about 30 us, bad if too long}	c2;	GOTO[Wait],	c3;{Attention up, must check if collision or overrun occured}	rEtemp ¬ EStatus, CANCELBR[$,1],	c3,at[0F,10,LData];ReTry:	uTrnLsts ¬ rEcnt,	c1;ReTryA:	EStrobe, {end receive mode}	c2;	rEcnt ¬ cLpFlag,	c3;{must be some packet coming in causes RecMode active, so forget the Trn}	EOCtl ¬ 0,	c1;	EICtl ¬ 0,	c2;	uTask2done ¬ rEcnt, GOTO[CkTest],	c3;{Wait for sending out packet, can not use Attn due to false InAttn by lastw}Wait:	Ybus ¬ 0, YIODisp,	c1;WaitLp:	rEcnt ¬ rEcnt - 1, ZeroBr, BRANCH[$, AttenUp],	c2;	BRANCH[Wait, TrnDone],	c3;{see if some packet coming in?}AttenUp:	rEtemp ¬ EStatus, BRANCH[$, T7Time],	c3;	rWork ¬ rEtemp and cStCol,	c1;	[] ¬ rWork, NZeroBr, {collision/overRun?}	c2;	BRANCH[$, ToReTry],	c3;	Ybus ¬ 0, YIODisp, GOTO[WaitLp],	c1;ToReTry:	uTrnLsts ¬ rEcnt, GOTO[ReTryA],	c1;TrnDone:	rEcnt ¬ cStCol, GOTO[ReadSt],	c1;{save status & value of Attn}T7Time:	rEcnt ¬ cStColOv,	c1;ReadSt:	rEtemp ¬ EStatus,	c2;	[] ¬ rEtemp and rEcnt, NZeroBr, {collision/overrun?}	c3;	EtherDisp, Ybus ¬ 0, BRANCH[$, LpCollid],	c1;	rEcnt ¬ cLpFlag, BRANCH[$, T7Attn1],	c2;	GOTO[TrnBad],	c3;{packet transmitted a OK}T7Attn1:	GOTO[LoopRec],	c3;LpCollid:	rEcnt ¬ cLpFlag, CANCELBR[$,1],	c2;	rEtemp ¬ EStatus, GOTO[TrnBad],	c3;TrnBad:	EOCtl ¬ 0,	c1;	EICtl ¬ 0,	c2;	uTask2done ¬ rEcnt, GOTO[CkTest],	c3;{Read words from FIFO}LoopRec:	rEadr ¬ uRcvBufa,	c1;	Noop,	c2;	rEcnt ¬ 0F, {15 words}	c3;	MAR ¬ [rhEadr, rEadr + 0], GOTO[GetWd],	c1;AddWd:	MAR ¬ rEadr ¬ [rhEadr, rEadr + 1], BRANCH[$, RecLast],	c1;GetWd:	MDR ¬ EIData, LOOPHOLE[wok], CANCELBR[RData, 0F],	c2;RData:	rEcnt ¬ rEcnt - 1, ZeroBr, GOTO[AddWd],	c3;{no page crossing}RecLast:	uEDsave ¬ rEtemp, CANCELBR[$,3],	c2;	rEtemp ¬ EStatus,	c3;	Noop,	c1;	EStrobe, {end Receive mode}	c2;	uRcvSize ¬ rEcnt,	c3;	EOCtl ¬ 0,	c1;	EICtl ¬ 0,	c2;	uTask2done ¬ ~rMPadd xor rMPadd, GOTO[CkTest],	c3;{************* Test 9 in Task2, Defer Logic *****************}DefLog:	Ybus ¬ uTask2done, ZeroBr,	c1;	BRANCH[StartD, $],	c2;	GOTO[DefLog],	c3;StartD:	Noop,	c3;	EOCtl ¬ 0,	c1;	rEcnt ¬ ~rEcnt xor rEcnt,	c2;	uTask2done ¬ 0,	c3;Circle:	Ybus ¬ uTask2done, ZeroBr,	c1;	BRANCH[DefDone, $],	c2;	GOTO[Circle],	c3;DefDone:	uTask2done ¬ 0, GOTO[CkTest],	c3;{END}SetTask[5];StartAddress[Task5];Task5: CANCELBR[Task5,0F],     c*;        SetTask[3];StartAddress[Task3];Task3: CANCELBR[Task3,0F],     c*;SetTask[4];StartAddress[Task4];Task4: CANCELBR[Task4,0F],     c*;@


1.1.1.1
log
@first add
@
text
@@
