head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ Copyright (C) 1980  by Xerox Corporation. All rights reserved.  }{File name:  <Workstation>mc>Sunlight-O.mc}		SetTask[0]; StartAddress[ibTests];TERROR1: ClrIntErr,CANCELBR[$,0F],   c*, at[0];         RB ¬0A5 ,   c2;         RA ¬055,   c3;         [] ¬ RB xor R7,ZeroBr,   c1;         BRANCH[TERROR2, $] ,   c2;         GOTO[CHECKDONE],   c3; TERROR2: [] ¬ RA xor R7,ZeroBr ,   c3;         RB ¬085, BRANCH[TERROR3, $],   c1;         R5 ¬0,GOTO[ECCMem],   c2; TERROR3:  [] ¬ RB xor R7,ZeroBr,   c2;          BRANCH[TERROR, $] ,   c3;          R5 ¬1,GOTO[ParityMem],   c1;	  TERROR:   GOTO[TERROR],   c*;		{4.0  IB tests}	Set[Full, 2]; Set[Word,3]; Set[Byte,1]; Set[Empty,0];{IBPtr¬0 should set ibPtr to Word.}ibTests:	R7¬0 ,CANCELBR[$,0F] 	,c1;	IBPtr¬0	,c2;	R1 ¬ ~ErrnIBnStkp	,c3;	R1 ¬ R1 LRot12	,c1;	R1 ¬ R1 and 3	,c2;	R2 ¬ R1 xor Word, ZeroBr	,c3;	DCtl ¬ 3,BRANCH[IBPtr0Bad, IBPtr0Good]	,c1;{IBPtr¬1 should set ibPtr to Byte.}IBPtr0Good:	IBPtr¬1	,c2;	R1 ¬ ~ErrnIBnStkp	,c3;	R1 ¬ R1 LRot12	,c1;	R1 ¬ R1 and 3	,c2;	R2 ¬ R1 xor Byte, ZeroBr	,c3;	BRANCH[IBPtr1Bad, IBPtr1Good]	,c1;{Load IB with 2 bytes (0ABCD) & read each of them (twice) via IBPtr¬n}IBPtr1Good:	R1 ¬ 0AB	,c2;	R1 ¬ R1 LRot8	,c3;	R1 ¬ R1 or 0CD  {R1 ¬ 0ABCD}	,c1;	IB ¬ R1 LRot0	,c2;	IBPtr ¬ 0  {ibFront¬0AB}	,c3;	R2 ¬ 0AB	,c1;	Xbus ¬ 54 {precharge X}	,c2;	R3 ¬ ibNA xor R2, ZeroBr	,c3;	R3 ¬ ibNA xor R2, ZeroBr, BRANCH[IBLeftaBad, IBLeftaGood]	,c1;IBLeftaGood:	R2 ¬ 0CD, BRANCH[IBLeftbBad, IBLeftbGood]	,c2;IBLeftbGood:	IBPtr ¬ 1 {ibFront¬0CD}	,c3;	Xbus ¬ 32 {precharge X}	,c1;	R3 ¬ ibNA xor R2, ZeroBr	,c2;	R3 ¬ ibNA xor R2, ZeroBr, BRANCH[IBRaBad, IBRaGood]	,c3;IBRaGood:	R2 ¬ 0C, BRANCH[IBRbBad, IBRbGood]	,c1;{Try ibLow & ibHigh}IBRbGood:	Xbus ¬ 3 {precharge X}	,c2;	R4 ¬ ibHigh xor R2, ZeroBr	,c3;	R2 ¬ 0D, BRANCH[IBHighBad, IBHighGood]	,c1;IBHighGood:	Xbus ¬ 2 {precharge X}	,c2;	R4 ¬ ibLow xor R2, ZeroBr	,c3;	BRANCH[IBLowBad, IBLowGood]	,c1;{PageCross should cancel IBDisp and AlwaysIBDisp.  ibPtr should still be Byte}IBLowGood:	rhR0 ¬ 1	,c2;	R0 ¬ 0	,c3;	MAR ¬ [rhR0, R0-1]	,c1;	IBDisp, CANCELBR[$,2]	,c2;	Noop 	,c3;	MAR ¬ [rhR0, R0-1]	,c1;	AlwaysIBDisp, CANCELBR[$,2]	,c2;	R2 ¬ ~ErrnIBnStkp	,c3;	R2 ¬ R2 LRot12	,c1;	R2 ¬ R2 and 3	,c2;	R3 ¬ R2 xor Byte, ZeroBr	,c3;	BRANCH[IBPtr1xBad, IBPtr1xGood]	,c1;{Try a Not-Empty refill trap (loc 500) via IBPtr¬0. R4 must be 5 at loc 500}IBPtr1xGood:	IBPtr ¬ 0	,c2;	R4 ¬ 5	,c3;	ClrIntErr  {clear a possible MInt}	,c1;	IBDisp  {should trap}	,c2;	GOTO[IBNullTable]	,c3;NETrap:	R3 ¬ R4 xor 5, ZeroBr	,c1, at[500];	BRANCH[NETrapBad, NETrapGood]	,c2;{Load IB with 4 bytes (0ABCD 5432), execute 3 ¬ib's and an IBDisp which should do an Empty refill trap (loc 400).  R4 must be a 4 at loc 400)}NETrapGood:	IB ¬ R1 LRot0  {IB ¬ 0ABCD}	,c3;	IBPtr¬0, R1 ¬ ~R1  {R1 ¬ 5432}	,c1;	R4 ¬ 4	,c2;	R2 ¬ 0AB	,c3;	Xbus ¬ 54 {precharge X}	,c1;	R3 ¬ ib xor R2, ZeroBr	,c2;	IB ¬ R1 LRot0, BRANCH[IBaBad, IBaGood]	,c3;IBaGood:	R2 ¬ 0CD	,c1;	R3 ¬ ib xor R2, ZeroBr	,c2;	BRANCH[IBbBad, IBbGood]	,c3;IBbGood:	R2 ¬ 54	,c1;	R3 ¬ ib xor R2, ZeroBr	,c2;	BRANCH[IBcBad, IBcGood]	,c3;IBcGood:	R2 ¬ 32	,c1;	R3 ¬ ib xor R2, ZeroBr  {buffer empty now}	,c2;	BRANCH[IBdBad, IBdGood]	,c3;IBdGood:	ClrIntErr  {clear a possible MInt}	,c1;	IBDisp  {should trap}	,c2;	GOTO[IBNullTable]	,c3;ETrap:	R3 ¬ R4 xor 4, ZeroBr	,c1, at[400];	BRANCH[ETrapBad, ETrapGood]	,c2;{Try an MInt trap (on an empty buffer)}ETrapGood:	MesaIntRq	,c3;	R4 ¬ 6  {buffer is still empty}	,c1;	IBDisp  {should trap}	,c2;	GOTO[IBNullTable]	,c3;NEMIntTrap:	GOTO[EMTrapBad]	,c1, at[700];EMIntTrap:	R3 ¬ R4 xor 6, ZeroBr	,c1, at[600];	R2 ¬ 0AA, BRANCH[EMTrapBad, EMTrapG]	,c2;{Try an AlwaysIBDisp to 0AF (with MInt ON)}EMTrapG:	IB ¬ R2 LRot0	,c3;	R4 ¬ R4+0, IBPtr ¬ 1	,c1;	AlwaysIBDisp	,c2;	R4 ¬ 0,ClrIntErr, GOTO[IBTable0F]	,c3;{Try an IBDisp to 05F}IBDispaG:	R2 ¬ 22	,c2;	R2 ¬ R2 LRot8	,c3;	R2 ¬ R2 or 55	,c1;	IB ¬ R2 LRot0  {IB¬2255}	,c2;	R2 ¬ R2 or 77	,c3;	IBPtr ¬ 0	,c1;	Xbus ¬ ib	,c2;	IB ¬ ~R2 LRot0  {IB¬DD88}	,c3;	R4 ¬ 0+0	,c1;	IBDisp	,c2;	GOTO[IBTable0F]	,c3;{Try an AlwaysIBDisp to 0FA}IBDispbG:	R2 ¬ 0FA	,c2;	IB ¬ R2 LRot0	,c3;	R4 ¬ R4+0, IBPtr ¬ 1	,c1;	AlwaysIBDisp	,c2;	R4 ¬ 0, GOTO[IBTableF0]	,c3;{Try an AlwaysIBDisp to 0F5}IBDispcG:	R2 ¬ 0F5	,c2;	IB ¬ R2 LRot8	,c3;	R4 ¬ R4+0, IBPtr ¬ 0	,c1;	AlwaysIBDisp	,c2;	R4 ¬ 0, GOTO[IBTableF0]	,c3;IBNullTable:	Noop, GOTO[IBTrapBad]	,c1, at[800];IBTable0F:	GOTO[IBDispabBad]	,c1, at[80F];	GOTO[IBDispabBad]	,c1, at[81F];	GOTO[IBDispabBad]	,c1, at[82F];	GOTO[IBDispabBad]	,c1, at[83F];	GOTO[IBDispabBad]	,c1, at[84F];	GOTO[IBDispbG]	,c1, at[85F];	GOTO[IBDispabBad]	,c1, at[86F];	GOTO[IBDispabBad]	,c1, at[87F];	GOTO[IBDispabBad]	,c1, at[88F];	GOTO[IBDispabBad]	,c1, at[89F];	GOTO[IBDispaG]	,c1, at[8AF];	GOTO[IBDispabBad]	,c1, at[8BF];	GOTO[IBDispabBad]	,c1, at[8CF];	GOTO[IBDispabBad]	,c1, at[8DF];	GOTO[IBDispabBad]	,c1, at[8EF];IBTableF0:	GOTO[IBDispcdBad]	,c1, at[8F0];	GOTO[IBDispcdBad]	,c1, at[8F1];	GOTO[IBDispcdBad]	,c1, at[8F2];	GOTO[IBDispcdBad]	,c1, at[8F3];	GOTO[IBDispcdBad]	,c1, at[8F4];	R0¬ 20,GOTO[MemTest]	,c1, at[8F5];	GOTO[IBDispcdBad]	,c1, at[8F6];	GOTO[IBDispcdBad]	,c1, at[8F7];	GOTO[IBDispcdBad]	,c1, at[8F8];	GOTO[IBDispcdBad]	,c1, at[8F9];	GOTO[IBDispcG]	,c1, at[8FA];	GOTO[IBDispcdBad]	,c1, at[8FB];	GOTO[IBDispcdBad]	,c1, at[8FC];	GOTO[IBDispcdBad]	,c1, at[8FD];	GOTO[IBDispcdBad]	,c1, at[8FE];	GOTO[IBDispcdBad]	,c1, at[8FF];	{Bad ib breaks}IBPtr0Bad: RErr ¬ 83, GOTO[IBPtr0Bad],	c*;IBPtr1Bad: RErr ¬ 84, GOTO[IBPtr1Bad],	c*;IBLeftaBad: RErr ¬ 85, CANCELBR[IBLeftaBad1],	c*;IBLeftaBad1: RErr ¬ 85, GOTO[IBLeftaBad1],	c*;IBLeftbBad: RErr ¬ 86, GOTO[IBLeftbBad],	c*;IBRaBad: RErr ¬ 87, CANCELBR[IBRaBad1],	c*;IBRaBad1: RErr ¬ 87, GOTO[IBRaBad1],	c*;IBRbBad: RErr ¬ 88, GOTO[IBRbBad],	c*;IBHighBad: RErr ¬ 89, GOTO[IBHighBad],	c*;IBLowBad: RErr ¬ 8A, GOTO[IBLowBad],	c*;IBPtr1xBad: RErr ¬ 8B, GOTO[IBPtr1xBad],	c*;NETrapBad: RErr ¬ 8C, GOTO[NETrapBad],	c*;IBaBad: RErr ¬ 8D, GOTO[IBaBad],	c*;IBbBad: RErr ¬ 8E, GOTO[IBbBad],	c*;IBcBad: RErr ¬ 8F, GOTO[IBcBad],	c*;IBdBad: RErr ¬ 90, GOTO[IBdBad],	c*;ETrapBad: RErr ¬ 91, GOTO[ETrapBad],	c*;EMTrapBad: RErr ¬ 92, GOTO[EMTrapBad],	c*;IBEmptyBad: RErr ¬ 93, GOTO[IBEmptyBad],	c*;IBDispaBad: RErr ¬ 94, GOTO[IBDispaBad],	c*;IBDispbBad: RErr ¬ 95, GOTO[IBDispbBad],	c*;IBDispcBad: RErr ¬ 96, GOTO[IBDispcBad],	c*;IBDispdBad: RErr ¬ 97, GOTO[IBDispdBad],	c*;IBDispabBad: RErr ¬ 98, GOTO[IBDispabBad],	c*;IBDispcdBad: RErr ¬ 99, GOTO[IBDispcdBad],	c*;IBTrapBad: RErr ¬ 9A, GOTO[IBTrapBad],	c*;{Simple mem tests.}SimMARBad:	RErr ¬ 7E, GOTO[SimMARBad],	c*;MDRCanBad:	RErr ¬ 7F, GOTO[MDRCanBad],	c*;{Simple MAR operation}MemTest:	CONF  ¬ R0	,c2;	R0 ¬ 5	,c3;	rhR0 ¬ 0	,c1;	Noop	,c2;	Noop	,c3;	MAR ¬ [rhR0, R0+0]	,c1;	MDR ¬ 0	,c2;		Noop	,c3;	MAR ¬ [rhR0, R0+0]	,c1;	Noop	,c2;	R1 ¬ MD	,c3;	[] ¬ R1, ZeroBr	,c1;	BRANCH[SimMARBad, $]	,c2;	R1¬6	,c3;{Does page cross cancel write?}	MAR¬[rhR0, R1+0FF]	,c1;	MDR ¬ 0F, CANCELBR[$, 2], LOOPHOLE[wok],c2;	Noop	,c3;	MAR ¬ [rhR0, R0+0]	,c1;	Noop	,c2;	R1 ¬ MD	,c3;	[] ¬ R1, ZeroBr	,c1;	BRANCH[MDRCanBad, $]	,c2;	R6¬ 0FF,GOTO[Conf]	,c3;Conf:   EOCtl ¬1,             c1;	R0 ¬ 8,	c2; 	R0 ¬ R0 LRot8,	c3;          KCmd ¬ R0 LRot0,        c1;         R5 ¬ 3F,        c2;         R7 ¬ 0A5,GOTO[SSTORE1],        c3;SSTORE:  MAR ¬ [rhR2, R2+0], 	c1;	 MDR¬R5, 	c2;         R5 ¬ R5-1,	c3;	 {rearrange highest real address bits in rhR2: 4xx53210}SSTORE1: Xbus ¬ R5 LRot12, XDisp, 	   c1;           Noop, DISP4[ssXM, 0C],	   c2;           R2 ¬ R5 xor 0, GOTO[ssXMj],  {0=>0}	c3, at[0C, 10, ssXM];         R2 ¬ R5 xor 90, GOTO[ssXMj],  {1=>8}	c3, at[0D, 10, ssXM];         R2 ¬ R5 xor 30, GOTO[ssXMj],	{2=>1}	c3, at[0E, 10, ssXM];         R2 ¬ R5 xor 0A0, GOTO[ssXMj],	{3=>9}	c3, at[0F, 10, ssXM];ssXMj: rhR2 ¬ R2 LRot0,	   c1;           [] ¬ R5+1, ZeroBr, 	   c2;           R2 ¬ 0, BRANCH[SSTORE,SSTORE2], 	c3;SSTORE2: R5 ¬ 0, 	c1;	 rhR2 ¬ R2 LRot0, 	c2;         R0¬CONF,GOTO[DiskType],	c3;                                DiskType: R0¬R0 and 40, 	   c1;            R0 ¬ R0, ZeroBr, 	   c2;  	  R0¬CONF,BRANCH[JoinIt,Q41], 	c3;	Q41:	Xbus¬ KStatus, XwdDisp	,c1;        R1¬CONF,BRANCH[SA1000, SA4000],c2;SA4000:	R0¬ 80, GOTO[JoinIt],	c3, at[3, 4, SA4000];SA1000:	Noop,c3, at[2, 4, SA4000];        Xbus ¬ KTest, XwdDisp	,  c1;	DISP2[IsSA1000orQuantum,1],	,c2;	IsSA1000orQuantum:	R0 ¬ 0C0 {quantum}, GOTO[JoinIt], 		c3, at[3,4,IsSA1000orQuantum]; 	R0¬0 {sa1000}, GOTO[JoinIt], 		c3, at[1,4,IsSA1000orQuantum]; 		JoinIt:  R1¬ R1 or R0, 	   c1;  JoinIt1: RF ¬ RShift1(RF xor RF), Cin¬1,	   c2;           MCtl ¬RF¬ 2 or RF, 	c3; {% enable large real mem}CHECK: MAR ¬ [rhR2, R2+0], 	c1;       CONF ¬ R1, 	c2;       R4 ¬MD,	c3;CHECK1: R0¬CONF, 	   c1;          [] ¬ R5 xor R4, ZeroBr, 	   c2;          R0¬R0 and 0F0,BRANCH[CHECKDONE,ADD1], 	c3;	ADD1:	R6 ¬ R5, 	c1;	Noop, 	c2;        GOTO[CHECKDONE],	c3;    CHECKDONE: RA ¬ 3F, 	c1;	   [] ¬ R5 xor RA , ZeroBr,	c2;           R5 ¬ R5+1,BRANCH[CHECK3,SendU],	c3;                   		{rearrange highest real address bits in rhR2: 4xx53210}CHECK3:	Xbus ¬ R5 LRot12, XDisp, 	   c1;          DISP4[chXM, 0C],	   c2;          R2 ¬ R5 xor 0, GOTO[chXMj],  {0=>0}	c3, at[0C, 10, chXM];        R2 ¬ R5 xor 90, GOTO[chXMj],  {1=>8}	c3, at[0D, 10, chXM];        R2 ¬ R5 xor 30, GOTO[chXMj],	{2=>1}	c3, at[0E, 10, chXM];        R2 ¬ R5 xor 0A0, GOTO[chXMj],	{3=>9}	c3, at[0F, 10, chXM];chXMj:  Noop,	   c1;  	  rhR2 ¬ R2 LRot0,	 c2;          R2 ¬ 0, GOTO[CHECK],	c3;	SendU:	        R7 ¬055  ,              c1;			        IOPCtl ¬ 2,	c2;    	     	MEMSIZE1¬ R6, GOTO[MemType],     c3; {Set mode of IOP port}	        	    MemType: R2 ¬ 0,             c1;	 rhR2 ¬ R2 LRot0,	c2; 	 MCtl¬ RF+1,	c3; 	          MAR ¬ [rhR2, R2+0], 	c1;	 MDR¬R2, 	c2;         R5¬0,	c3;	 	 MAR ¬ [rhR2, R2+0], 	c1;         Noop, 	c2;         R4 ¬MD,	c3;         R1¬ 080, 	c1;         MCtl¬ R1 or RF, 	c2;         Noop,	c3;         MAR ¬ [rhR2, R2+0], 	c1;	 MDR¬R2, 	c2;         Noop,	c3;	 	 MAR ¬ [rhR2, R2+0], 	c1;         R7 ¬085, 	c2;         R4 ¬MD,	c3;	          Noop, 	c1;ParityMem: Noop, 	c2;ECCMem:    R0¬R0 or R5,	c3;WaitOut:      Xbus ¬ IOPStatus, XLDisp,    c1;{Is IOPReq true?, Put R0 on Y bus}	      BRANCH [WaitOut1, Out, XOdd],   c2;{XOdd => IOPReq, Put R0 on Y bus}WaitOut1:     GOTO[WaitOut],        c3;		Out:	      IOPOData ¬ R0 LRot0,     c3;	{Output value}	        Noop  ,              c1;			       Noop,	c2;    	      Noop ,         c3;	      WaitOut2:    Xbus ¬ IOPStatus, XLDisp,    c1;{Is IOPReq true?, Put R0 on Y bus}	     BRANCH [WaitOut3, Out1, XOdd],   c2;{XOdd => IOPReq, Put R0 on Y bus}WaitOut3:    GOTO[WaitOut2],        c3;		Out1:	     IOPOData ¬ R6 LRot0,GOTO[NOERROR],     c3;	{Output value}NOERROR:	IOPCtl ¬ 0,GOTO[NOERROR],	                           	c*, at[0FFF];SetTask[5];StartAddress[Task5];Task5: CANCELBR[Task5,0F],     c*;        SetTask[3];StartAddress[Task3];Task3: CANCELBR[Task3,0F],     c*;SetTask[2];StartAddress[Task2];Task2: R9¬CONF,CANCELBR[$,0F],     c1;        R9 ¬R9 and 0DF,       c2;        CONF ¬R9,       c3;Task2A:  EOCtl ¬0,    c1;        Noop,       c2;        GOTO[Task2A],  c3;SetTask[4];StartAddress[Task4];Task4: R9¬CONF,CANCELBR[$,0F],     c1;        R9 ¬R9 or 40,       c2;        CONF ¬R9,       c3;        R9¬CONF,     c1;        R9 ¬R9 and 7F,       c2;        CONF ¬R9,       c3;Task4A:  KCmd ¬0,    c1;        Noop,       c2;        GOTO[Task4A],  c3;@


1.1.1.1
log
@first add
@
text
@@
