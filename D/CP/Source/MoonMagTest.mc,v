head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.10;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.10;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ Copyright (C) 1980  by Xerox Corporation. All rights reserved. }SetTask[0]; StartAddress[RecieveU];TERROR:	  R7¬0F,ClrIntErr,CANCELBR[Exit32,0F],   c1, at[0]; 	  Start:      Noop,               c1; {}	    Xbus¬TEST, XDisp ,	c2;	    DISP4[StartTest],	c3;	       StartTest:  R7¬0FF,GOTO[Test0],                      c1, at[0, 10, StartTest];	    R7¬0FF,GOTO[Test1],                      c1, at[1, 10, StartTest];	    R7¬0FF,GOTO[Test2],                      c1, at[2, 10, StartTest];	    R7¬0FF,GOTO[Test3],                      c1, at[3, 10, StartTest];	    R7¬0FF,GOTO[Test4],                      c1, at[4, 10, StartTest];	    R7¬0FF,GOTO[Test5],                        c1, at[5, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[6, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[7, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[8, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[9, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[0A, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[0B, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[0C, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[0D, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[0E, 10, StartTest];            R7¬4,GOTO[Exit32],                      c1, at[0F, 10, StartTest];Test0:   R2 ¬ 0,                 c2; 	 R3 ¬ 0,                c3;	 R4 ¬ 0,                 c1; 	 pCall0,                 c2;          R5 ¬ 0, CALL[SetAdCl],  c3, at[0,10];	   	 R0 ¬ USTATUS,                 c1, at[0,10,SetAdClRet];  	 R1 ¬ LSTATUS,pCall0,         c2;          CALL[CkStatus],         c3, at[0,10];  	 R7¬0,GOTO[Exit32F],                 c1, at[0,10,StatusRet];	 	 	 	 	 Test1:   R0 ¬ COUNT,        c2; 	 R1 ¬ UINITIAL,       c3; 	                 R2 ¬ LINITIAL,        c1; 	 R1 ¬ R1 LRot8 ,       c2;	 R1 ¬ R1 or R2,        c3; 	          R3 ¬ TYPE,        c1; 	 R2 ¬ 1, pCall0,        c2;	 R2 ¬ R2 and R3,CALL[WriteFiFo],c3, at[0,10]; 		 R0 ¬ COUNT,         c1, at[0,10,WFifoRet];	 R1 ¬ UINITIAL,        c2; 	 R3 ¬ LINITIAL,       c3; 	         R1 ¬ R1 LRot8,        c1; 	 R1 ¬ R1 or R3, pCall0,        c2;	 R3 ¬ TYPE, CALL[ReadFiFo],c3, at[0,10]; 	          R0 ¬ USTATUS,                 c1, at[0,10,RFifoRet];  	 R1 ¬ LSTATUS,pCall0,         c2;          CALL[CkStatus],         c3, at[1,10]; 	          R7¬0,GOTO[Exit32F],      c1, at[1,10,StatusRet];	 	 	 Test2:   R2 ¬ 0,                 c2; 	 R3 ¬ 0 ,                c3;	 R4 ¬ 0,                 c1; 	 pCall0,                 c2;          R5 ¬ 0, CALL[SetAdCl],  c3, at[6,10];	   	 R0 ¬ 0,                 c1, at[6,10,SetAdClRet];  	 R1 ¬ 38,pCall0,         c2;          CALL[CkStatus],         c3, at[2,10]; 	 		 R2 ¬ 0FF,                 c1, at[2,10,StatusRet];	 R3 ¬ 0FF ,                c2;	 R4 ¬ 0FF,               c3; 	 	 R5 ¬ 0FF,               c1; 	 pCall0,                 c2;          CALL[SetAdCl],          c3, at[7,10];	   	 R0 ¬ 0E7,               c1, at[7,10,SetAdClRet];  	 R1 ¬ 0C1,pCall0,        c2;          CALL[CkStatus],         c3, at[3,10]; 	 		 R2 ¬ 0AA,                 c1, at[3,10,StatusRet];	 R3 ¬ 0AA ,               c2;	 R4 ¬ 0AA,                c3; 	 	 R5 ¬ 0AA,                c1; 	 pCall0,                 c2;          CALL[SetAdCl],          c3, at[8,10];	   	 R0 ¬ 0A7,                 c1, at[8,10,SetAdClRet];  	 R1 ¬ 0A9,pCall0,          c2;          CALL[CkStatus],         c3, at[4,10]; 	 		 R2 ¬ 55,                 c1, at[4,10,StatusRet];	 R3 ¬ 55 ,               c2;	 R4 ¬ 55,               c3; 	 	 R5 ¬ 55,                 c1; 	 pCall0,                   c2;          CALL[SetAdCl],            c3, at[9,10];	   	 R0 ¬ 45,                 c1, at[9,10,SetAdClRet];  	 R1 ¬ 50,pCall0,          c2;          CALL[CkStatus],           c3, at[5,10]; 	 		 	 		 R7¬0,GOTO[Exit32F],      c1, at[5,10,StatusRet];	 	 	 	 	 	 	 Test3:   R0 ¬ COUNT,        c2; 	 R1 ¬ UINITIAL,       c3; 	                 R2 ¬ LINITIAL,        c1; 	 R1 ¬ R1 LRot8 ,       c2;	 R1 ¬ R1 or R2,        c3; 	          R3 ¬ TYPE,        c1; 	 R2 ¬ 1, pCall0,        c2;	 R2 ¬ R2 and R3,CALL[WriteFiFo],c3, at[1,10]; 		 R0 ¬ COUNT,         c1, at[1,10,WFifoRet];	 R0 ¬ R0 + R0,pCall0,             c2; 	 CALL[WrapFiFo],c3, at[0,10]; 	         R0 ¬ COUNT,         c1, at[0,10,WpFifoRet];	 R1 ¬ UINITIAL,        c2; 	 R3 ¬ LINITIAL,       c3; 	         R1 ¬ R1 LRot8,        c1; 	 R1 ¬ R1 or R3, pCall0,        c2;	 R3 ¬ TYPE, CALL[ReadFiFo],c3, at[1,10]; 	          R0 ¬ USTATUS,                 c1, at[1,10,RFifoRet];  	 R1 ¬ LSTATUS,pCall0,         c2;          CALL[CkStatus],         c3, at[6,10]; 	          R7¬0,GOTO[Exit32F],      c1, at[6,10,StatusRet];	 Test4:    TAddr ¬ 0,	c2;          TCtl ¬ 0 ,	c3;	  	  RF ¬ 40,	c1;	  R9¬ RF LRot8,	c2;	  R9¬ R9 or RB,      c3;	            TCtl ¬ R9 LRot0,  	c1;	  RB ¬ 29,	c2;          RE ¬ 20,	        c3;          	            TAddr ¬ RE LRot0,	c1;          Noop,	        c2;          Noop,  	c3;	           Noop,	c1;          Noop,	        c2;          Noop,	c3;	           TAddr ¬ 0,	c1;          Noop,	        c2;          Noop,  	c3;	 	  TCtl ¬ RB LRot0,	c1;          Noop,	        c2;          R5¬ TStatus,  	c3;	           R0 ¬ USTATUS,                 c1;  	  R1 ¬ LSTATUS,pCall0,         c2;           CALL[CkStatus],         c3, at[7,10]; 	           R7¬0,GOTO[Exit32F],      c1, at[7,10,StatusRet];	 	 Test5:    R0¬ 0FF,	        c2;          RB¬ 29,	c3;	            TCtl¬ RB LRot0,	c1;	  	    WTest5:   ClrRefRq,	c2;          R0 ¬ R0-1 ,ZeroBr,	c3;	  BRANCH[WTest5, $],	c1;          Noop,	        c2;	  Noop,	        c3;          GOTO[Exit32F],      c1;	 	 	 	 CkStatus: R2 ¬ UMASK,	c1;          R4 ¬ LMASK,	c2;	 	    	  R2 ¬ R2  LRot8,	c3;	            R2 ¬ R2 or R4,	c1;	  R5 ¬ R2 and R5,	c2;          UEXPECTED ¬ R0,	c3;	            LEXPECTED ¬ R1,	c1;	    	  R0 ¬ R0 LRot8,	c2;          R0 ¬ R0 or R1,	c3;	  	  Noop,	c1;          [] ¬ R0 xor R5,ZeroBr,	c2;          BRANCH[StatusErr, CkStatusRet],	c3;	      	 	 	 	 CkStatusRet:LOBSERVED ¬ R5,	c1;            R5 ¬ R5 LRot8,pRet0,	c2;	    UOBSERVED ¬ R5,RET[StatusRet],	c3;StatusErr:  LOBSERVED ¬ R5,	c1;            R5 ¬ R5 LRot8,pRet0,	c2;	    UOBSERVED ¬ R5,RET[StatusErrRet],	c3;	    R7¬1, GOTO[Exit32],         c1, at[0,10,StatusErrRet];	    R7¬1, GOTO[Exit32],         c1, at[1,10,StatusErrRet];	    R7¬1, GOTO[Exit32],         c1, at[2,10,StatusErrRet];	    R7¬1, GOTO[Exit32],         c1, at[3,10,StatusErrRet];	    R7¬1, GOTO[Exit32],         c1, at[4,10,StatusErrRet];	    R7¬1, GOTO[Exit32],         c1, at[5,10,StatusErrRet];	    	    R7¬1, GOTO[Exit32],         c1, at[6,10,StatusErrRet];	    R7¬1, GOTO[Exit32],         c1, at[7,10,StatusErrRet];	    	    SetAdCl: R2 ¬ R2 LRot8 ,	        c1;	 TAddr ¬ (R2 or R3) LRot0,	c2;         R4 ¬ R4 LRot8,	                c3;	          TCtl ¬ (R4 or R5) LRot0,	c1;	          pRet0,	                        c2;	 R5 ¬TStatus, RET[SetAdClRet],	c3;	 WriteFiFo:TAddr ¬ 0,	c1;          TCtl ¬ 0 ,	c2;	  RF ¬ 40,	c3;	    	    	  R6 ¬ RF LRot8, c1;          RA¬ 19,	c2;	  RB ¬ 29,	c3;	    	  RD ¬ 10,c1;          TCtl ¬ RB LRot0,	c2;	  RE ¬ 20,	c3;	              R6¬ R6 or 39,	c1;          R9¬ RF LRot8,	c2;WriteAgain:R4 ¬ R0-1,ZeroBr,CANCELBR[$],c3;	  R9¬ R9 or RB,BRANCH[NotLastWord, LastWord],	c1;	  NotLastWord:TCtl ¬ R9 LRot0,	c2;          TOData¬ R1 LRot0,	c3;	    	  TCtl ¬ R6 LRot0,	c1;          [] ¬ R2 ,ZeroBr,	c2;	  BRANCH[IncData, DecCount],	c3;	  	  DecCount:Noop,	c1;         Noop,	        c2;         Noop,	c3;	          R0 ¬ R0-1,ZeroBr,	c1;         R5¬ TStatus, pRet0,BRANCH[WriteAgain, WriteFifoRet] ,	c2;	  WriteFifoRet:TCtl ¬ RB LRot0, RET[WFifoRet],	c3;	  LastWord: R9¬ R9 or R3,	c2;          R6¬ R6 or R3,	c3;	  GOTO[NotLastWord],	c1;	  	    IncData: R1¬ R1+1,	c1;         R1¬ R1 LRot8,	c2;	 R1¬ R1+3,GOTO[DecCount],	c3;	 	 WrapFiFo: R9¬ RF LRot8,      c1;          R9¬ R9 or RB,	c2;	  TCtl ¬ RB LRot0,  	c3;	  TAddr ¬ RD LRot0,	c1;          Noop,	        c2;          Noop,	c3;	           TAddr ¬ 0,	c1;          Noop,	        c2;          Noop,  	c3;	  	           TCtl ¬ R9 LRot0,	c1;	  Noop,	        c2;          Noop,  	c3;	           TAddr ¬ RE LRot0,	c1;          Noop,	        c2;          Noop,  	c3;	           TAddr ¬ 0,	c1;          Noop,	        c2;          Noop,  	c3;	 	  R0 ¬ R0-1,ZeroBr,	c1;         R5¬ TStatus, pRet0,BRANCH[WrapAgain, WrapFifoRet] ,	c2;WrapAgain: CANCELBR[WrapFiFo],	c3;	  WrapFifoRet:TCtl ¬ RB LRot0, RET[WpFifoRet],	c3;	    ReadFiFo : TCtl ¬ RA LRot0,	c1;           Noop,	        c2;           Noop,	c3;	   RDelay:    Noop,	c1;           Noop,	        c2;           Noop,	c3;	   	   Noop,	c1;           Noop,	        c2;           Noop,	c3;	              	   RDDone:    Noop,	c1;           R9¬ TIData,	        c2;           []¬ R9 xor R1,ZeroBr,	c3;	   	   R5¬ TStatus,BRANCH[DataErr, CkType],    c1;CkType :   [] ¬ R2 ,ZeroBr,	c2;	   BRANCH[IncDataR, DecCountR],	c3;	  	  DecCountR: R0 ¬ R0-1,ZeroBr,	c1;           pRet0,BRANCH[ReadAgain, ReadFifoRet] ,	c2;ReadAgain: CANCELBR[RDelay],	c3;	  ReadFifoRet:TCtl ¬ 0, RET[RFifoRet],	c3;  	    IncDataR: R1¬ R1+1 ,	c1;          R1¬ R1 LRot8 ,	c2;	  R1¬ R1+ 3 ,GOTO[DecCountR],	c3;	  DataErr:  LEXPECTED ¬ R1,	c2;          R1 ¬ R1 LRot8,	c3;	  	  UEXPECTED ¬ R1,	c1;	          LOBSERVED ¬ R9,	c2;          R9 ¬ R9 LRot8,	c3;	  	  UOBSERVED ¬ R9,	c1;	  TCtl ¬ 0,pRet0,	c2;          RET[DataErrRet],	c3;	  	            R7¬2, GOTO[Exit32],         c1, at[0,10,DataErrRet];	  R7¬2, GOTO[Exit32],         c1, at[1,10,DataErrRet];	  R7¬2, GOTO[Exit32],         c1, at[2,10,DataErrRet];	  R7¬2, GOTO[Exit32],         c1, at[3,10,DataErrRet];	  R7¬2, GOTO[Exit32],         c1, at[4,10,DataErrRet];	  R7¬2, GOTO[Exit32],         c1, at[5,10,DataErrRet];	    	    	  Exit32:   R8 ¬1, c2;Exit3:    R8 ¬1 ,c3;Exit31:   R8 ¬1 ,c1;Exit32F:  FAULTTYPE ¬ R7 ,c2;          R8 ¬ R8-1,ZeroBr, GOTO[CPassDone],  c3;CPassDone:    BRANCH[CPassDone1, CPassDone2],	c1;CPassDone1:   Noop,	c2;              GOTO[Start],	c3;CPassDone2:   Noop,	c2;              GOTO[CStop],	c3;CStop:        [] ¬ STOPONERR,CANCELBR[$],ZeroBr,	c1;              BRANCH[CStop1, CStop2],	c2;CStop1:       R8¬PASSCOUNT,GOTO[Start],	c3;CStop2:       GOTO[End],	c3;End:          GOTO[SendU],   c1;          	      RecieveU:  CANCELBR[$,0F],         c1;			{Clear flags}	   IOPCtl ¬ 5 ,     c2;		   R1¬0,                  c3;	{Clear data register}	WaitIn:	Xbus ¬ IOPStatus, XLDisp ,     c1;	{Is IOPReq true?, Put R0 on Y bus}	BRANCH [WaitIn1, In, XOdd],     c2;{XOdd => IOPReq, Put R0 on Y bus}WaitIn1:	GOTO[WaitIn],        c3;	In:	IOPCtl ¬ 1 ,               c3;		{Set mode of IOP port, clear Attn}	R0¬IOPIData ,     c1;	{Input value}	R3¬10,        c2;        GOTO[StoreU],        c3;StoreU:	        Noop  ,              c1;			        []¬ R1, AltUaddr,   c2;     	        TEST¬ R0, GOTO[CHECKLU]  ,              c3;			CHECKLU:	R1 ¬ R1 +1 ,              c1;			        [] ¬ R1 and R3, ZeroBr  ,              c2;			        BRANCH [CHECKLU2, CHECKLU1] ,   c3;	CHECKLU1:	Noop,        c1;                GOTO[WaitIn1],        c2;	{Not Done}                CHECKLU2:	FAULTTYPE¬R7¬0,        c1;                IOPCtl ¬ 0,        c2;	                R8¬PASSCOUNT,GOTO[Start],        c3;	{Done}SendU:	        R1¬0,	c2;    	     	IOPCtl ¬ 2 ,         c3;		{Set mode of IOP port}	        R3¬10,	c1;                    Noop,	c2;                    GOTO[GetU],	c3;    WaitOut:    Xbus ¬ IOPStatus, XLDisp,   c1;	{Is IOPReq true?, Put R0 on Y bus}	    BRANCH [WaitOut1, Out, XOdd],   c2;{XOdd => IOPReq, Put R0 on Y bus}WaitOut1:   GOTO[WaitOut],        c3;		Out:	     IOPOData ¬ R0 LRot0,GOTO[GetU],     c3;	{Output value}        	GetU:	     Noop  ,              c1;			     []¬ R1, AltUaddr ,   c2;             R0¬ TEST,GOTO[CHECKSU]  ,              c3;		CHECKSU:     [] ¬ R1 and R3, ZeroBr ,              c1;			     BRANCH [CHECKSU2, CHECKSU1]  ,              c2;			            	CHECKSU1:    R1 ¬ R1 +1,GOTO[WaitOut],        c3; {Not Done}                                CHECKSU2:    IOPCtl ¬ 0,GOTO[RecieveU],        c3;	{Done}SetTask[5];StartAddress[Task5];Task5: CANCELBR[Task5,0F],     c*;        SetTask[3];StartAddress[Task3];Task3: CANCELBR[Task3,0F],     c*;SetTask[2];StartAddress[Task2];Task2: CANCELBR[Task2,0F],     c*;SetTask[4];StartAddress[Task4];Task4: CANCELBR[Task4,0F],     c*;SetTask[1];StartAddress[TestDisp];TestDisp:       Xbus¬TEST, XDisp ,CANCELBR[$, 0F],c1;	        DISP4[RunTest],	c2;	       RunTest:    GOTO[TestDisp],              c3, at[0, 10, RunTest];	    GOTO[TestDisp],              c3, at[1, 10, RunTest];	    GOTO[TestDisp],              c3, at[2, 10, RunTest];	    GOTO[TestDisp],              c3, at[3, 10, RunTest];	    GOTO[TestDisp],              c3, at[4, 10, RunTest];	    R7¬0,GOTO[TestDisp],         c3, at[5, 10, RunTest];            GOTO[TestDisp],              c3, at[6, 10, RunTest];            GOTO[TestDisp],              c3, at[7, 10, RunTest];            GOTO[TestDisp],              c3, at[8, 10, RunTest];            GOTO[TestDisp],              c3, at[9, 10, RunTest];            GOTO[TestDisp],              c3, at[0A, 10, RunTest];            GOTO[TestDisp],              c3, at[0B, 10, RunTest];            GOTO[TestDisp],              c3, at[0C, 10, RunTest];            GOTO[TestDisp],              c3, at[0D, 10, RunTest];            GOTO[TestDisp],              c3, at[0E, 10, RunTest];            GOTO[TestDisp],              c3, at[0F, 10, RunTest];@


1.1.1.1
log
@first add
@
text
@@
