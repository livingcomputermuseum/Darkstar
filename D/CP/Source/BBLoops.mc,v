head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.18;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.18;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{File name bbLoops.mcDescription: BitBlt op-codeAuthor: don DXC     Created: January, 1980Last edited by DEG     :  1-Sep-84 19:20:36: Add copyright noticeLast edited by AEF     : June 18, 1981  8:47 AM: Delete L1Tldaw atLast edited: October 8, 1980  6:35 PM}{ 	Copyright (C) 1980, 1981 by Xerox Corporation.  All rights reserved.}	{L4IClick1 -- ReadSource1}L4I1lsar:	MAR ¬ [rhSrcA,SrcA + 0], sfDisp, BRANCH[L4I1noop1,L4I2noop1X]	,c1;L4I1noop1:	Dst ¬ Dst xor ~Dst, scDisp, sfDISP[L4I1rs]	,c2;L4I1rs:	Src ¬ MD, scDisp, sc2DISP[L4I1sc2]	,c3, at[sf.true,sfM,L4I1rs];	Src ¬ ~MD, scDisp, sc2DISP[L4I1sc2]	,c3, at[sf.comp,sfM,L4I1rs];	{L4IClick2 -- ShiftSource1}L4I1sc2:	Src ¬ Src LRot0, scDisp, sc1DISP[L4I1sc1]	,c1, at[3,10,L4I1sc2];	Src ¬ Src LRot4, scDisp, sc1DISP[L4I1sc1]	,c1, at[7,10,L4I1sc2];	Src ¬ Src LRot8, scDisp, sc1DISP[L4I1sc1]	,c1, at[0B,10,L4I1sc2];	Src ¬ Src LRot12, scDisp, sc1DISP[L4I1sc1]	,c1, at[0F,10,L4I1sc2];L4I1sc1:	Src ¬ RRot1 Src, dirDisp, sc3DISP[L4I1sc3b]	,c2, at[0E,10,L4I1sc1];	Src ¬ Src, dirDisp, sc3DISP[L4I1sc3b]	,c2, at[0F,10,L4I1sc1];L4I1sc3b:	Dst ¬ RRot1 (Src or Q), dirDISP[L4I2lsar]	,c3, at[0D,10,L4I1sc3b];	Dst ¬ LRot1 (Src or Q), dirDISP[L4I2lsar]	,c3, at[0F,10,L4I1sc3b];	{L4IClick3 -- ReadSource2}L4I2lsar:	SrcA ¬ MAR ¬ [rhSrcA,SrcA + 1], sfDisp, GOTO[L4I2noop1]	,c1, at[dir.forward,dirM,L4I2lsar];	SrcA ¬ MAR ¬ [rhSrcA,SrcA - 1], sfDisp, GOTO[L4I2noop1]	,c1, at[dir.backwards,dirM,L4I2lsar];L4I2noop1:	scDisp, sfDISP[L4I2rs]	,c2;L4I2noop1X:	Dst ¬ Dst xor ~Dst, scDisp, sfDISP[L4I2rs]	,c2;L4I2rs:	Src ¬ MD, scDisp, sc2DISP[L4I2sc2]	,c3, at[sf.true,sfM,L4I2rs];	Src ¬ ~MD, scDisp, sc2DISP[L4I2sc2]	,c3, at[sf.comp,sfM,L4I2rs];	{L4IClick4 -- ShiftSource2}L4I2sc2:	Src ¬ Src LRot0, scDisp, sc1DISP[L4I2sc1]	,c1, at[3,10,L4I2sc2];	Src ¬ Src LRot4, scDisp, sc1DISP[L4I2sc1]	,c1, at[7,10,L4I2sc2];	Src ¬ Src LRot8, scDisp, sc1DISP[L4I2sc1]	,c1, at[0B,10,L4I2sc2];	Src ¬ Src LRot12, scDisp, sc1DISP[L4I2sc1]	,c1, at[0F,10,L4I2sc2];L4I2sc1:	Src ¬ RRot1 Src, sc3DISP[L4I2sc3a]	,c2, at[0E,10,L4I2sc1];	Src ¬ Src, sc3DISP[L4I2sc3a]	,c2, at[0F,10,L4I2sc1];L4I2sc3a:	Hold ¬ RRot1 (~Src and Q), GOTO[L4I3ldar]	,c3, at[0D,10,L4I2sc3a];	Hold ¬ LRot1 (~Src and Q), GOTO[L4I3ldar]	,c3, at[0F,10,L4I2sc3a];	{L4IClick5 -- ReadDest}L4I3ldar:	DstA ¬ MAR ¬ [rhDstA,DstA + 0]	,c1;L4I3com:	Hold ¬ Hold xor Dst	,c2;L4I3rd:	Dst ¬ MD	,c3;	{L4IClick6 -- Mask}L4I4m1:	Lcount ¬ Lcount - 1, NegBr	,c1;L4I4m2:	dfDisp, BRANCH[L4I4m3,L4Tshort]	,c2;L4I4m3:	Mask1 ¬ ~Mask1, dfDISP[L4I5m1]	,c3;	{L4IClick7 -- Mask}L4I5m1:	Hold ¬ Hold and ~Mask1, GOTO[L4I5m2]	,c1, at[df.null,dfM,L4I5m1];L4I5m2:	Dst ¬ Dst and Mask1, dirDisp, GOTO[L4I5m3]	,c2;L4I5m3:	Hold ¬ Hold or Dst, scDisp, dirDISP[L4lsar]	,c3;	Hold ¬ Hold or Mask1, GOTO[L4I5m2A]	,c1, at[df.and,dfM,L4I5m1];	Hold ¬ Hold and ~Mask1, GOTO[L4I5m2A]	,c1, at[df.or,dfM,L4I5m1];	Hold ¬ Hold and ~Mask1, GOTO[L4I5m2A]	,c1, at[df.xor,dfM,L4I5m1];L4I5m2A:	dirDisp	,c2;	scDisp, dirDISP[L4lsar]	,c3;	{  L4 INNER LOOP }	{L4Click1 -- ReadSource}L4lsar:	SrcA ¬ MAR ¬ [rhSrcA,SrcA + 1], sfDisp, sc3DISP[L4sc3b]	,c1, at[dir.forward,dirM,L4lsar];L4lsarA:	SrcA ¬ MAR ¬ [rhSrcA,SrcA - 1], sfDisp, sc3DISP[L4sc3b]	,c1, at[dir.backwards,dirM,L4lsar];L4sc3b:	Save ¬ RRot1 (Src or Q), sfDISP[L4rs]	,c2, at[0D,10,L4sc3b];	Save ¬ LRot1 (Src or Q), sfDISP[L4rs]	,c2, at[0F,10,L4sc3b];L4rs:	Src ¬ MD, dfDisp, GOTO[L4ldaw]	,c3, at[sf.true,sfM,L4rs];	Src ¬ ~MD, dfDisp, GOTO[L4ldaw]	,c3, at[sf.comp,sfM,L4rs];	{L4Click2 -- StoreDest}L4ldaw:	MAR ¬ [rhDstA,DstA + 0], scDisp, dfDISP[L4dw]	,c1;L4dw:	MDR ¬ Hold , scDisp, sc1DISP[L4sc1], Write OK	,c2, at[df.null,dfM,L4dw];	MDR ¬ Hold and Dst, scDisp, sc1DISP[L4sc1], Write OK	,c2, at[df.and,dfM,L4dw];	MDR ¬ Hold or Dst, scDisp, sc1DISP[L4sc1], Write OK	,c2, at[df.or,dfM,L4dw];	MDR ¬ Hold xor Dst, scDisp, sc1DISP[L4sc1], Write OK	,c2, at[df.xor,dfM,L4dw];L4sc1:	Src ¬ RRot1 (Src), sc2DISP[L4sc2]	,c3, at[0E,10,L4sc1];	Src ¬ (Src), sc2DISP[L4sc2]	,c3, at[0F,10,L4sc1];	{L4Click3 -- ShiftSource}L4sc2:	Src ¬ Src LRot0, scDisp, GOTO[L4Lcnt]	,c1, at[3,10,L4sc2];	Src ¬ Src LRot4, scDisp, GOTO[L4Lcnt]	,c1, at[7,10,L4sc2];	Src ¬ Src LRot8, scDisp, GOTO[L4Lcnt]	,c1, at[0B,10,L4sc2];	Src ¬ Src LRot12, scDisp, GOTO[L4Lcnt]	,c1, at[0F,10,L4sc2];L4Lcnt:	Lcount ¬ Lcount - 1, dirDisp, NegBr, sc3DISP[L4sc3a]	,c2;L4sc3a:	Hold ¬ RRot1 (~Src and Q), dirDISP[L4ldar]	,c3, at[0D,10,L4sc3a];	Hold ¬ LRot1 (~Src and Q), dirDISP[L4ldar]	,c3, at[0F,10,L4sc3a];	{L4Click4 -- ReadDest}L4ldar:	DstA ¬ MAR ¬ [rhDstA,DstA + 1], GOTO[L4com]	,c1, at[dir.forward,dirM,L4ldar];	DstA ¬ MAR ¬ [rhDstA,DstA - 1], GOTO[L4com]	,c1, at[dir.backwards,dirM,L4ldar];L4com:	Hold ¬ Hold xor Save, dirDisp, BRANCH[L4rd,L4rdA,1]	,c2;L4rd:	Dst ¬ MD, scDisp, dirDISP[L4lsar]	,c3;	{L4Tshort }L4Tshort:	Src ¬ Hold, CANCELBR[$,Sub[dfM,1] ]	,c3;	Mask2 ¬ Umask2, dfDisp	,c1;	Mask2 ¬ Mask2 and Mask1, dfDISP[L12Tdf]	,c2;	{L4TClick1 -- ReadDest}L4TermF:	DstA ¬ MAR ¬ [rhDstA,DstA + 1], GOTO[L4Tcom]	,c1, at[Or[dir.forward,LCeq0],dirM,L4ldar];	DstA ¬ MAR ¬ [rhDstA,DstA - 1], GOTO[L4Tcom]	,c1, at[Or[dir.backwards,LCeq0],dirM,L4ldar];L4Tcom:	Hold ¬ Hold xor Save, DISP2[L4Trd]	,c2;L4Trd:	Dst ¬ MD, GOTO[L4Tm1]	,c3, at[NoPgCr,4,L4Trd];	{L4TClick2 -- Mask}L4Tm1:	Src ¬ Hold, dfDisp	,c1;	Mask2 ¬ Umask2, dfDISP[L12Tdf]	,c2;	{initialization for loops L1 and L2D}	{L1/2 Init Click1 -- ReadSource}L1I1lsar:	MAR ¬ [rhSrcA,SrcA + 0], sfDisp	,c1, at[gr.gray,grM,chooseLoop];	scDisp, sfDISP[L1sf]	,c2;	Src ¬ MD, scDisp, sc2DISP[L1I1sc2]	,c3, at[sf.true,sfM,L1sf];	Src ¬ ~MD, scDisp, sc2DISP[L1I1sc2]	,c3, at[sf.comp,sfM,L1sf];	{L1/2 Init Click2 -- CycleSource}L1I1sc2:	Src ¬ Src LRot0, scDisp, sc1DISP[L1I1sc1]	,c1, at[3,10,L1I1sc2];	Src ¬ Src LRot4, scDisp, sc1DISP[L1I1sc1]	,c1, at[7,10,L1I1sc2];	Src ¬ Src LRot8, scDisp, sc1DISP[L1I1sc1]	,c1, at[0B,10,L1I1sc2];	Src ¬ Src LRot12, scDisp, sc1DISP[L1I1sc1]	,c1, at[0F,10,L1I1sc2];	Src ¬ RRot1 Src, sc3DISP[L1I1sc3b]	,c2, at[0E,10,L1I1sc1];	Src ¬ Src, sc3DISP[L1I1sc3b]	,c2, at[0F,10,L1I1sc1];	Src ¬ RRot1 Src, GOTO[L1I3ldar]	,c3, at[0D,10,L1I1sc3b];	Src ¬ LRot1 Src, GOTO[L1I3ldar]	,c3, at[0F,10,L1I1sc3b];	{L1/2 Init Click3 -- ReadDest}L1I3ldar:	MAR ¬ [rhDstA,DstA + 0]	,c1;	Lcount ¬ Lcount - 1, NegBr	,c2;	Dst ¬ MD, BRANCH[L1I4mask1,SingleDstWExit]	,c3;	{L1/2 Init Click4 -- Mask}L1I4mask1:	Noop	,c1;	dfDisp	,c2;	dfDISP[L12df]	,c3;	{L1 Init Click5 -- Mask}	{df.null  -- will go to loop L1}	Q ¬ Src	,c1, at[df.null,dfM,L12df];	Q ¬ Q and Mask1	,c2;	Dst ¬ Dst and ~Mask1	,c3;	{L1 Init Click6 -- store first end chunk}	MAR ¬ [rhDstA,DstA + 0]	,c1;	MDR ¬ Dst or Q, GOTO[L1Entry]	,c2;	{L2 Init Click5 -- Mask}	{df.not null  -- will go to loop L2}	Q ¬ Src and Dst, GOTO[L2dfnext]	,c1, at[df.and,dfM,L12df];	Q ¬ Src or Dst, GOTO[L2dfnext]	,c1, at[df.or,dfM,L12df];	Q ¬ Src xor Dst, GOTO[L2dfnext]	,c1, at[df.xor,dfM,L12df];L2dfnext:	Q ¬ Q and Mask1	,c2;	Dst ¬ Dst and ~Mask1	,c3;	{L2 Init Click6 -- store first end chunk}	MAR ¬ [rhDstA,DstA + 0]	,c1;	MDR ¬ Dst or Q, GOTO[L2Entry]	,c2;	{  L1 INNER LOOP }	{L1Click1 -- StoreDest}L1Loop:	DstA ¬ MAR ¬ [rhDstA,DstA + 1], BRANCH[$,L1Exit]	,c1;L1pcrGo:	MDR ¬ Src, BRANCH[L1Entry,L1pcr,1]	,c2;L1Entry:	Lcount ¬ Lcount - 1, NegBr, GOTO[L1Loop]	,c3;	{  L2 INNER LOOP }	{L2DClick1 -- StoreDest}L2Loop:	MAR ¬ [rhDstA,DstA + 0], dfDISP[L2Ddw]	,c1;	MDR ¬ Src and Dst, GOTO[L2Entry]	,c2, at[df.and,dfM,L2Ddw];	MDR ¬ Src or Dst, GOTO[L2Entry]	,c2, at[df.or,dfM,L2Ddw];	MDR ¬ Src xor Dst, GOTO[L2Entry]	,c2, at[df.xor,dfM,L2Ddw];L2Entry:	Noop, GOTO[L2LCk2]	,c3;	{L2DClick2 -- ReadDest}L2LCk2:	MAR ¬ DstA ¬ [rhDstA,DstA + 1]	,c1;	Lcount ¬ Lcount - 1, NegBr, BRANCH[$,L2pcr,1]	,c2;L2pcrGo:	Dst ¬ MD, dfDisp, BRANCH[L2Loop,L2Exit]	,c3;	{L1/2  Termination }	{L1 Exit Click1 -- ReadDest}L1Exit:	Noop, BRANCH[$,L1Tpcr,1]	,c2;	Dst ¬ MD, GOTO[L12Tmask]	,c3;	{L1/2 Single dest word exit}SingleDstWExit:	Mask2{Mask1andMask2} ¬ Mask1 and Mask2, dfDisp	,c1;	Noop, dfDISP[L12Tdf]	,c2;	{L2 Exit Click1 -- ReadDest}L2Exit:	dfDisp, CANCELBR[$,0F]	,c1;	dfDISP[L12Tdf]	,c2;	Src ¬ Src, GOTO[L12Tmask]	,c3, at[df.null,dfM,L12Tdf];	Src ¬ Src and Dst, GOTO[L12Tmask]	,c3, at[df.and,dfM,L12Tdf];	Src ¬ Src or Dst, GOTO[L12Tmask]	,c3, at[df.or,dfM,L12Tdf];	Src ¬ Src xor Dst, GOTO[L12Tmask]	,c3, at[df.xor,dfM,L12Tdf];L12Tmask:	Src ¬ Src and Mask2	,c1;	Dst ¬ Dst and ~Mask2	,c2;	Noop	,c3;	{L1TClick3 --StoreDest}	MAR ¬ [rhDstA,DstA + 0]	,c1;	MDR ¬ Src or Dst, GOTO[ItemRefill3]	,c2;{	Src  PageCross	}	rhRet ¬ SRaRet, CANCELBR{CALL}[SrcLRemap,0F] {PageCross}	,c3, at[Or[sf.true,PgCr],sfM,L4I2rs];	rhRet ¬ SRaRet, CANCELBR{CALL}[SrcLRemap,0F] {PageCross}	,c3, at[Or[sf.comp,PgCr],sfM,L4I2rs];{rtn here}	SrcA ¬ MAR ¬ [rhSrcA,SrcA + 0], sfDisp, GOTO[L4I2noop1]	,c1, at[SRaRet,10,SrcRemapReturn];	rhRet ¬ SRcRet, CALL[SrcLRemap] {PageCross}	,c3, at[Or[sf.true,PgCr],sfM,L4rs];	rhRet ¬ SRcRet, CALL[SrcLRemap] {PageCross}	,c3, at[Or[sf.comp,PgCr],sfM,L4rs];{rtn here}	MAR ¬ [rhSrcA,SrcA + 0], sfDisp	,c1, at[SRcRet,10,SrcRemapReturn];	sfDISP[L4rs]	,c2;{	Dst  PageCross	}{L4TrdA:}	{Page Cross}	rhRet ¬ DRaRet, CALL[DstLRemap]	,c3, at[PgCr,4,L4Trd];{rtn here}	DstA ¬ MAR ¬ [rhDstA,DstA + 0]	,c1, at[DRaRet,10,DstRemapReturn];	Noop, GOTO[L4Trd]	,c2;L4rdA:	{Page Cross}	rhRet ¬ DRbRet, CANCELBR[DstLRemap,Sub[dirM,1] ]	,c3;{rtn here}	DstA ¬ MAR ¬ [rhDstA,DstA + 0]	,c1, at[DRbRet,10,DstRemapReturn];	dirDisp, GOTO[L4rd]	,c2;L1pcr:	{Page Cross}	rhRet ¬ ret.L1pcr, CALL[DstLRemap] {PageCross}	,c3;{rtn here}	DstA ¬ MAR ¬ [rhDstA,DstA + 0], GOTO[L1pcrGo]	,c1, at[ret.L1pcr,10,DstRemapReturn];L2pcr:	{Page Cross}	rhRet ¬ ret.L2pcr, {CALL}CANCELBR[DstLRemap]	,c3;{rtn here}	DstA ¬ MAR ¬ [rhDstA,DstA + 0]	,c1, at[ret.L2pcr,10,DstRemapReturn];	Lcount ¬ Lcount, NegBr, GOTO[L2pcrGo]	,c2;L1Tpcr:	{Page Cross}	rhRet ¬ ret.L1Tpcr, CALL[DstLRemap]	,c3;{rtn here}	DstA ¬ MAR ¬ [rhDstA,DstA + 0], GOTO[L1Exit]	,c1, at[ret.L1Tpcr,10,DstRemapReturn];	{END}@


1.1.1.1
log
@first add
@
text
@@
