head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.23;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.23;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{R RXS    MagTape MicrocodeFile: MagTape.mcRevised: R RXS     13-Oct-83 11:00:28  Make IOPage changes for moving the IOPageRevised: R RXS     April 15, 1983  4:09 PM   Add odd byte, start error handelingRevised:  AeF AEF      31-Mar-83 12:57:32 Fix address calculation in case of read block where actual block is smaller than word countRevised:  AeF AEF      24-Mar-83 11:18:37 Move definitions to Dandelion.df, move initialization code to InitDLion.mc, move first memory access in IOCB out of loopRevised:  CRF  July 7, 1982  9:42 AM Deleted WakeupMaskOffset (use Dandelion.df's version).Revised:  R RXS      May 12, 1982  10:09 AM Changed error endingRevised:  R RXS     May 4, 1982  11:53 AM  Added "Running" status word in CSBRevised:  AeF AEF       April 23, 1982  5:15 PM  Changed StartAddress to InitMtRevised:  Dennis DEG        1-Sep-84 19:41:06  Add copyright notice.}{ 	Copyright (C) 1982, 1983 by Xerox Corporation.  All rights reserved.}{This is the start of the MagTape code.  }{definitions:  directions:  In = in to Dandelion, MagTape read                              out = out from Dandelion, MagTape write}{IO commands used:  TIData = Magtape input (to DLion) data	TOData = Magtape output (from DLion) data	TCtl = Load MagTape control register	TAddr = Load MagTape Address control register	TStatus = Get MagTape Status }{The following constants should be moved to Dandelion.df}Set[CTOdByt,4];{OddByte location in TStatus}Set[CTStNNrml,3F];{Start conditions not normal}SetTask[1];StartAddress[MTStart];MTStart:	CANCELBR[$,0F]	,c1;	rhTMa ¬ IOPageHigh	,c2;	rTMa ¬ uIOPage	,c3;	MAR ¬ [rhTMa,rTMa + CTCSBOffset1]	,c1;	MDR ¬ 1, CANCELBR[$,2], LOOPHOLE[wok]	,c2;{Running CSB word ¬ 1}	Noop	,c3;	MAR ¬ [rhTMa,rTMa + CTCSBOffset]	,c1;{get virtual address of IOCB}	rhTMa ¬ 0,CANCELBR[$,2]	,c2;{HI part of virt addr is = 0}	rTMa ¬ MD	,c3;{Get real address of start of IOCB, put IOCB into u-regs}MTCntnu:	Map ¬ [rhTMa,rTMa]	,c1;{get real address of IOCB}	Noop	,c2;{keep virtual address}	rhTWc ¬ rTWc ¬ MD	,c3;	MAR ¬ rTWc ¬ [rhTWc,rTMa]	,c1;{rTWc ¬ (rTWc and FF00) or (rTMa and 0FF)--memory cycle not used}	uThisIOCBAdr ¬ rTWc, CANCELBR[$,2]	,c2;	rTWc ¬ rhTWc	,c3;	uThisIOCBAdrHi ¬ rTWc	,c1;	rTWc ¬ uThisIOCBAdr	,c2;	Noop	,c3;{Transfer IOCB to u-regs.  We do this first memory access separately so that the magtape microcode does not write U register 90.}	MAR ¬ rTWc ¬ [rhTWc, rTWc + 1]	,c1;	Noop, CANCELBR[$, 2]	,c2;	rTMa ¬ MD	,c3;GIOCBLoop:	MAR ¬ [rhTWc, rTWc + 1]	,c1;	Ybus ¬ rTWc, rTWc ¬ rTWc + 1, AltUaddr, NibCarryBr, CANCELBR[$,2]	,c2;	rTMa ¬ MD, uTBlock ¬ rTMa, BRANCH[GIOCBLoop,$]		,c3;{IOCB Word}	rTMa ¬ uTIntBitHld	,c1;{get from IOCB}	uTIntBit ¬ rTMa	,c2;{Put away}	TAddr ¬ uTCmd	,c3;{Set up Tape Addr reg}	Noop	,c1;	rTWc ¬ uTMErRst	,c2;	MCtl ¬ rTWc	,c3;{Clear Tsk 1 mem error}	TCtl ¬ uTCmdNP	,c1;{ControllerClr off if not}	Xbus ¬ uTCmd, XDisp	,c2;	uTHld ¬ rTMa, L5 ¬ 0, DISP4[CmdDcd,8]	,c3;{go to cmd handler}{Command type 0}{Send status to head}{starts directly at TEnd}{Command type I}{Rewind or Unload Tape}{This handler does not check ending status but hands status words to head without checking}MTRwnd:	TCtl ¬ uTCmdP	,c1,at[9,10,CmdDcd]; {Rwnd or UnldCmd sent}	rTWc ¬ TStatus	,c2;	uTStat0 ¬ rTWc	,c3;	TCtl ¬ uTCmdNP 	,c1;{This & previous TCtl ¬ must be in different clicks,- rewind or unload off}	rTWc ¬ CTCmdWasRwnd,GOTO[TSPEnd3]	,c2;{LastIOCB = 1, CmdWasRwnd = 1}{Command Type II}{Erase, EraseSecurity, SpaceForward, SpaceBackward, Noop, Set3200Bpi, Set1600Bpi}MTCmd2:	GOTO[MtCmd32]	,c1,at[0A,10,CmdDcd];{Command Type III}{WriteFileMark, FileSearchForward, FileSearchBackwards}MTCmd3:	Noop	,c1,at[0B,10,CmdDcd];MtCmd32:	TCtl ¬ uTCmdP	,c2;{GO cmd form}	rTWc ¬ uTCmdNP	,c3;	rTWc ¬ rTWc and ~CTForceRqOff	,c1;{ForceTapeReq off}	TCtl ¬ rTWc LRot0	,c2;{no Go form w/ req off}	GOTO[TEnd]	,c3;{Command Type IV-Read MagTape}{uTCmdWc has compliment of number of words to be transfered.}MTCmd4:	rTMa ¬ uTVirtAddrLo,CALL[MTXRmp]	,c1,at[0C,10,CmdDcd];{get real address of mem buffer}	TCtl ¬ uTCmdDaNF	,c3,at[0C,10,MTXRet]; {NOGO form of cmd with DataMode=1 & ForceReq = 0}{Start MT read-wait here for first word strobe from MT}{rTWc already has CTStNNrml = 3F}TRStrt:	rTWc ¬ rTWc and TStatus	,c1;	Ybus ¬ rTWc, ZeroBr	,c2;{is start NonNormal?}	rTWc ¬ rTWc and CTOdByt, BRANCH[TNNrml,$]	,c3;{Bad start?}	MAR ¬ rTMa ¬ [rhTMa,rTMa + 0], GOTO[TRLp2]	,c1;{Start mem cycle, read tape data to mem, check for end of transfer, check for page crossing}{Read MagTape inner loop}TRLoop:	MAR ¬ rTMa ¬  [rhTMa,rTMa + 1],BRANCH[$,TRSEnd2]	,c1;{Set Mem Address}TRLp2:	MDR ¬ rTWc ¬ TIData,BRANCH[$,TRPgCross,1]	,c2;{get byte}TRLp3:	rTWc ¬ uTWc	,c3;{Ready to check word count}{The microcode waits here for a word strobe from MT}	rhTWc ¬ TStatus	,c1;	rTWc ¬ rTWc + 1,ZeroBr	,c2;{Check word count}	uTWc ¬ rTWc,rTWc ¬ rhTWc,NZeroBr,BRANCH[TRLoop,TROverN1]	,c3;{Branch if over}{The previous MAR ¬ instruction generated a page cross branch.  We must re-map the rTMa & rhTMa. }TRPgCross:	uTHldData ¬ rTWc,L5 ¬ 2 	,c3;{Keep data not written to memory}{The following code re-maps the rTMa & rhTMa to the new real memory locations & then goes back to the ReadMagTape loop.  This code uses rTMa & rhTMa since they will be reloaded at the end of Map.}	rTWc ¬ 0FF + 1,CALL[TPgCross]	,c1;{hex 100,- remap mem address}	MAR ¬ rTMa ¬ [rhTMa,0 + 0]	,c1,at[2,10,TPgCrossRet]; {Fix rTMa}	MDR ¬ uTHldData,GOTO[TRLp3]	,c2;{Add one to rTMa address, only because we subtract it again below and can save code this way.}TROverN1:	rTMa ¬ rTMa + 1, CANCELBR[$]	,c1;{Since the rTMa address has already been incremented for the next word when we arrive here because TStatus has become nonzero, we must subtract one from it for the normal case.  For the case where we just page crossed, we must add 0FF to get the correct address of the last word read.  This avoids an extra click in the main read loop.}TRSEnd2:	BRANCH[$, TLastPgCross, 1]	,c2;{ForceReq on & Stat0}	rTMa ¬ rTMa - 1, GOTO[TRIsOdB1]	,c3;TLastPgCross:	rTMa ¬ rTMa + 0FF	,c3;{rTWc has TStatus bits 7-0 from main loop}TRIsOdB1:	rTWc ¬ rTWc and CTOdByt, ZeroBr	,c1;{Is odd byte set?}	BRANCH[TREdOdByt3,$]	,c2;	GOTO[TEnd]	,c3;TREdOdByt3:	Noop	,c3;TREdOdB1:	MAR ¬ rTMa ¬ [rhTMa,rTMa + 1]	,c1;{store odd byte}TREdOdByt2:	MDR ¬ rTWc ¬ TIData, BRANCH[$,TROPgCross,1]	,c2;TREdOdBytG: GOTO[TEnd]	,c3;TNNrml:	Ybus ¬ rTWc, ZeroBr	,c1;{Odd Byte or error?}	uTLastMa ¬ 0, BRANCH[$,TRStEr3]	,c2;{Br if start error}	Noop	,c3;	MAR ¬ [rhTMa,rTMa + 0], GOTO[TREdOdByt2]	,c1;{Put OddByte in mem}TRStEr3:	TCtl ¬ uTCmdNP	,c3;	rTWc ¬ CTStrtErr	,c1;	rTMa ¬ TStatus, GOTO[TSPEnd3]	,c2;TROPgCross:	uTHldData ¬ rTWc, L5 ¬ 3	,c3;{keep data not written to memory}	rTWc ¬ 0FF + 1, CALL[TPgCross]	,c1;{hex 100, remap mem address}	MAR ¬ rTMa ¬ [rhTMa,0 + 0]	,c1,at[3,10,TPgCrossRet];{Fix rTMa}	MDR ¬ uTHldData, GOTO[TREdOdBytG]	,c2;{MagTapeTransferRemap subroutine-get real address of memory buffer for xfer routine}MTXRmp:	rhTMa ¬ uTVirtAddrHi	,c2;		TCtl ¬ uTCmdP	,c3;{Action bit on}	Map ¬ [rhTMa,rTMa]	,c1;{start map cycle}	rTWc ¬ rTMa	,c2;	rhTMa ¬ rTMa ¬ MD	,c3;{real address, almost}	MAR ¬ rTMa ¬ [rhTMa, rTWc]	,c1;{rTMa ¬ (rTMa and 0FF00) or (rTWc and 00FF)-Mem cycle not used}	rTWc ¬ uTCmdWc, CANCELBR[$,2]	,c2;{comp of word count}	uTWc ¬ rTWc	,c3;	TCtl ¬ uTCmdNP,pRet5	,c1; {Action bit off}	rTWc ¬ CTOdByt, RET[MTXRet]	,c2; {CTOdByt = 4}		{Command Type V-Write MagTape}{uTCmdWc has compliment of number of words to be transfered.}MTCmd5:	rTMa ¬ uTVirtAddrLo,CALL[MTXRmp]	,c1,at[0D,10,CmdDcd];{Get real address of mem buffer}	Noop	,c3,at[0D,10,MTXRet];	rTWc ¬ uTWc	,c1;{get woed count}	rTWc ¬ rTWc + 1, ZeroBr	,c2;{was WC = FFFF?}	uTWc ¬ rTWc, BRANCH[$,TWOneWd]	,c3;{only one word-WC now gives actual number of words to be written}	MAR ¬ [rhTMa,rTMa + 0]	,c1;	TCtl ¬ uTCmdDaNF	,c2;{NOGO form of cmd with DataMode=1 & ForceReq = 0}	TOData ¬ MD	,c3;{Wait here for first data req, then wait until IDBY goes true}TWSLp1:	rhTWc ¬ TStatus	,c1;	rTWc ¬ CT0Idby	,c2;{ bit value = 8}	Noop	,c3;	Noop	,c1;	rTWc ¬ rTWc xor rhTWc,ZeroBr	,c2;{comp Busy-Not bit}	rTWc ¬ uTWc,BRANCH[$,TWSLp1]	,c3;{Loop until IDBY or ImmediateHalt is 1}{WriteMagTape inner loop}{Microcode waits here for next MT write strobe.  When strobe received two clicks occur, and the data is transfered on the second click}TWLoop:	rhTWc ¬ TStatus	,c1;{Get mt stat}TWLp2:	rTWc ¬ rTWc + 1,ZeroBr	,c2;{test WC}	Ybus ¬ rhTWc,NZeroBr,BRANCH[$,TWOverN1]	,c3;{check Stat}	MAR ¬ rTMa ¬ [rhTMa,rTMa + 1],BRANCH[$,TWError2]	,c1;{start mem}TWLp12:	uTWc ¬ rTWc,BRANCH[$,TWPgCrossN,1]	,c2;{WC away}	TOData ¬ MD,GOTO[TWLoop]	,c3;{1st byte}{The previous instruction generated a page carry branch. rTMa & rhTMa are now pointing to the beginning of a possibly wrong page.  Re-map rhTMa & rTMa and return to main loop.}TWPgCrossN:	L5 ¬ 0	,c3;	rTWc ¬ 0FF + 1,CALL[TPgCross]	,c1;{PageCross Subroutine}TPgCross:	rTMa ¬ uTVirtAddrLo	,c2;{Lo part of virt address}	rhTMa ¬ uTVirtAddrHi	,c3;	rTMa ¬ rTMa + rTWc,CarryBr	,c1;{add 100}	uTVirtAddrLo ¬ rTMa,BRANCH[TNoC,$]	,c2;{VirtAdd away}	rTMa ¬ rhTMa + 1,LOOPHOLE[byteTiming]	,c3;{Inc HiPart}		uTVirtAddrHi ¬ rTMa 	,c1;{HiPart away}	rhTMa ¬ rTMa LRot0  	,c2;{HiPart away}TNoC:	rTMa¬ uTVirtAddrLo	,c3;{LoPart back}	Map ¬ [rhTMa,rTMa]	,c1;{do remap}	rTWc ¬ uTWc,pRet5	,c2;	rhTMa ¬ rTMa ¬ MD,RET[TPgCrossRet]	,c3;{End of PageCross Subroutine}	MAR ¬ rTMa ¬ [rhTMa,0 + 0],GOTO[TWLp12]	,c1,at[0,10,TPgCrossRet]; {fix up rTMa}{Wait here until IDBY goes true}TWOneWdLp:	Noop	,c3;TWOneWd:	rhTWc ¬ TStatus	,c1;	rTWc ¬ CT0Idby	,c2;{ bit value = 8}	Noop	,c3;	rTWc ¬ rTWc xor rhTWc,ZeroBr	,c1;{comp Busy-Not bit}	rTWc ¬ uTWc,BRANCH[$,TWOneWdLp]	,c2;{Loop until IDBY or ImmediateHalt is 1}	Noop	,c3;	MAR ¬ [rhTMa,rTMa + 0], GOTO[TWOverN2]	,c1;{write one only word}{Write last word onto tape.Before writing last word or last byte, set LastByte or LastWord control bit.}TWOverN1:	MAR ¬ rTMa ¬ [rhTMa,rTMa + 1],CANCELBR[$]	,c1;{last m cycle}TWOverN2:	TCtl ¬ uTCmdWE,BRANCH[$,TWPgCrossE,2]	,c2;{LastByte and ForceReq on}	TOData ¬ MD	,c3;{write word}TWOvLp1:	rhTWc ¬ TStatus	,c1;	rTWc ¬ rhTWc,ZeroBr	,c2;{Test IDBY and ImmediateHalt}	BRANCH[$,TWOvLp1]	,c3;	uTLastMa ¬ rTMa, rTMa ¬ TStatus, GOTO[TEnd2]	,c1;{Write ended}TWPgCrossE:	L5 ¬ 1	,c3;	rTWc ¬ 0FF + 1,CALL[TPgCross]	,c1;	MAR ¬ rTMa ¬ [rhTMa,0 + 0],GOTO[TWOverN2]	,c1,at[1,10,TPgCrossRet];TWError2:	CANCELBR[$,2]	,c2;TWError3:	Noop	,c3;	MAR ¬ [rhTMa,rTMa + 0],GOTO[TWOverN2]	,c1;{To lastbyte}{Command type VI}{Diagnostic commands, StopRunaway}MTCmd6:	rTWc ¬ TStatus	,c1,at[0E,10,CmdDcd];	Noop	,c2;	TCtl ¬ uTCmdP,GOTO[TEnd]	,c3;{Pulse cmd then end}{Command type VII}{Illegal command type}TIlglCmd:	rTWc ¬ CTIlgCmd	,c1,at[0F,10,CmdDcd];	GOTO[TSPEnd3]	,c2;{Normal end: gets current tape status & checks for status errors using mask (uTSMsk) and compare bits (uTSCmp) from IOCB; gets current Next IOCB Virtual Address and ends IOCB string if next IOCB address is 0 or sets up for next IOCB if not zero or if no other condition requires that the IOCB string be stopped; puts u-reg information back into IOCB; interrupts Mesa.}{GetStatus, CmdType 0, starts here}{ForceTapeReq is on and DataMode is off in all cases before coming here}TEnd:	uTLastMa ¬ rTMa, rTMa ¬ TStatus	,c1,at[8,10,CmdDcd];{so that head can calc actual wc}TEnd2:	rTWc ¬ CTMETst	,c2;	rTWc ¬ rTWc and MStatus,ZeroBr	,c3;{Test for MemErr}		TCtl ¬ uTCmdNP,BRANCH[TMEr2,$]	,c1;{ LastByte/Word off;Br if mem error}	rTWc ¬ uTSMsk	,c2;{Test certain bits of stat0}	uTStat0 ¬ rTMa	,c3;TEndA:	rTMa ¬ rTWc and rTMa	,c1;	Ybus ¬ rTMa xor uTSCmp,ZeroBr	,c2;{test ending status}	rhTMa ¬ uThisIOCBAdrHi,BRANCH[TBadEnd1,$]	,c3;{Br if masked bits not= uTSCmp}	rTWc ¬ TStatus	,c1;	rTWc ¬ rTWc and CTImmediateHalt	,c2;{Is ImmediateHalt = 1?}	Ybus ¬ rTWc, ZeroBr	,c3;	rTWc ¬ uTCmdNP,BRANCH[TIEnd2,$]	,c1;{Br if it is}	rTMa ¬ uThisIOCBAdr	,c2;	rTWc ¬ CTContIOCB	,c3;{Set Continue IOCB bit}TEndB:	MAR ¬ [rhTMa,rTMa + 1]	,c1;{get current NextIOCB}	uTStat1 ¬ rTWc, CANCELBR[$,2]	,c2;	rTMa ¬ MD, L5 ¬ 0	,c3;	uTNxtIOCB ¬ rTMa,ZeroBr	,c1;	rTWc ¬ CTLastIOCB,BRANCH[TPutIOCB,TSPEnd3]	,c2;{If another IOCB on string, goto TPutIOCB--if next IOCB = 0, goto TSPEnd3}	TCtl ¬ uTCmdNP	,c1,at[0,10,TPutRet];{End Controller Clear}	rTMa ¬ uTNxtIOCB	,c2;{next Virt IOCB address}	rhTMa ¬ 0,GOTO[MTCntnu] 	,c3;{Continue with next IOCB}{This ENDS the command IF another IOCB will follow}TIEnd2:	rTWc ¬ rTWc or CTIFENBit	,c2;	TCtl ¬ rTWc LRot0	,c3;{IFEN bit (immediateHalt) set}	TCtl ¬ uTCmdNP	,c1;{IFEN off- this must be in different click than previous TCtl ¬}	rTWc ¬ CTImmediateHaltStatBit,GOTO[TSPEnd3]	,c2;{A Memory two-bit error has occured during MagTape operation}TMEr2:	rTWc ¬ CTMemEr, GOTO[TSPEnd3]	,c2;{MemErrorFound & LastIOCB}{Improper end: sets improper end and lastIOCB bits in status word; puts u-reg information into IOCB; interrupts Mesa; waits for next IOCB wakeup}TBadEnd1:	Noop	,c1;	rTWc ¬ CTImprEnd	,c2;{ImproperEnd=1; LastIOCB=1}TSPEnd3:	uTStat1 ¬ rTWc	,c3;TSEnd1:	L5 ¬ 1	,c1;	CALL[TPutIOCB]	,c2;{put IOCB into mem}	Noop	,c1,at[1,10,TPutRet];	rhTMa ¬ IOPageHigh	,c2;{ForceReq off}	rTMa ¬ uIOPage	,c3;	MAR ¬ [rhTMa,rTMa + CTCSBOffset1]	,c1;	MDR ¬ 0, CANCELBR[$,2], LOOPHOLE[wok]	,c2;{Running CSB word ¬ 0}	TCtl ¬ CTEnReq, GOTO[MTStart]	,c3;{Nap; new IOCB, ForceReq off, ControllerClear still on}{This ENDS the IOCB if another IOCB will NOT be done}{Put u-reg information into IOCB; turn ControllerClear on; interrupt Mesa}TPutIOCB:	rhTMa ¬ uThisIOCBAdrHi	,c3;	Noop	,c1;	rTMa ¬ uThisIOCBAdr	,c2;{start of IOCB}TPutIOCBLp:	Noop	,c3;	Noop	,c1;	rTMa ¬ rTMa + 1,AltUaddr,NibCarryBr	,c2;	rTWc ¬ uTBlock, BRANCH[$,TPLpE1]	,c3;{Index thru u regs}	MAR ¬ [rhTMa,rTMa + 0]	,c1;	MDR ¬ rTWc,GOTO[TPutIOCBLp]	,c2;TPLpE1:	rTWc ¬ uTCmdNP	,c1;	rTWc ¬ rTWc and ~CTContClr	,c2;{Turn on Controller Clear}	TCtl ¬ rTWc LRot0	,c3;	rTWc ¬ uWP	,c1;	rTWc ¬ uTIntBit or rTWc,MesaIntRq,pRet5	,c2;	uWP ¬ rTWc,RET[TPutRet]	,c3;{interrupt Mesa}{Memory Refresh Task}SetTask[3];StartAddress[RefreshGo];	Set[HalfFieldSize, 0E0];RefreshGo:	uClockBits ¬ 0, CancelDisp[$]	,c1;	rhTRfsh ¬ IOPageHigh	,c2;RefreshField:	rTRfsh ¬ uIOPage	,c3;	MAR ¬ [rhTRfsh, rTRfsh + WakeupMaskOffset]	,c1;	Noop, CancelPgCross[$, 0]	,c2;	rTRfsh ¬ MD,	c3;	uTWakeup ¬ rTRfsh,	c1;	Noop,	c2;	Noop,	c3;{This code looks this way because uWP must be updated within one click.}	rTRfsh ¬ uWP,	c1;	rTRfsh ¬ uTWakeup or rTRfsh, MesaIntRq,	c2;	uWP ¬ rTRfsh,	c3;	rTRfsh ¬ LShift1 HalfFieldSize, 	c1;	uTRefreshLine ¬ rTRfsh,	c2;	ClrRefRq,	c3;Refresh:	rTRfsh ¬ uClockLow, Refresh,	c1;	rTRfsh ¬ rTRfsh + 1, CarryBr,	c2;	uTRefreshTemp ¬ rTRfsh, BRANCH[$, RefreshCarry],	c3;	Refresh,	c1;	Noop,	c2;Refresh1:	uClockLow ¬ rTRfsh,	c3;	rTRfsh ¬ uTRefreshLine, ZeroBr,	c1;	rTRfsh ¬ rTRfsh - 1, BRANCH[$, RefreshField],	c2;	uTRefreshLine ¬ rTRfsh, ClrRefRq, GOTO[Refresh],	c3;RefreshCarry:	rTRfsh ¬ uClockHigh, Refresh,	c1;	rTRfsh ¬ rTRfsh + 1,	c2;	Noop,	c3;	uClockHigh ¬ rTRfsh,	c1;	rTRfsh ¬ uTRefreshTemp, GOTO[Refresh1],	c2;@


1.1.1.1
log
@first add
@
text
@@
