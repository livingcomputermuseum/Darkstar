head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.25;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.25;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{File name:  ProcListMisc.mcDescription: Miscellaneous Mesa  opcodes,Author:  RXG   ,Created: April 3, 1980, Copyright (C) 1981, 1982, 1983, 1985, 1987 by Xerox Corporation.  All rights reserved. Last Edited: RDH     ,  3-Nov-87  9:34:27 Add check of ProcList for TextBltLast Edited: JAC     , 29-May-85 17:14:34 Add multiport config stuffLast Edited: RDH     , 16-May-85 11:37:51 Add version bytecode.Last Edited: DEG     ,  1-Sep-84 19:42:59 Add copyright noticeLast Edited: AEF     , 31-Aug-83 10:50:05 Move IOPage for larger VMLast Edited: AXD    , 15-Jun-83 19:01:49 new instruction setLast Edited: AEF     ,  4-Jan-83 10:52:30 Fix typo in BLTLR commentLast Edited: AEF     , 22-Dec-82 10:49:15 Make BLTLR microcode implementationLast Edited: AEF     , September 2, 1982  12:19 PM Do STK¬TOS at Unimplemented OpcodesLast Edited: AEF     , August 2, 1982  11:41 AM MaintenancePanelOffsetLast Edited: AEF     , April 29, 1982  1:48 PM Add TStatus to @@INPUT and TAddr to @@OUTPUTLast Edited: AEF     , April 23, 1982  2:01 PM  Add conditional assembly for MagTapeEdited: JGS    , February 24, 1982  2:18 PM Add SPP instEdited: JGS    , November 17, 1981  5:04 PM new instruction setEdited: JGS    , April 23, 1981  8:46 AM: Fix Stack on Misc ~IN[0..15]Last Edited:  JXF     , March 16, 1981  11:51 AM: Allow Block to catch Checksum MiscLast Edited: RXJ     , January 22, 1981  1:11 PM}{Assembly Configs:Config#		File0	Mesa.db1	RavenMesa.db2	TridentMesa.db3	TridentRavenMesa.db4	MagTapeMesa.db5	TridentMagTapeMesa.db6	Multiport}{*****************************************************************************	ESC(L) - Escape operations*****************************************************************************}@@ESCL:	Xbus ¬ ibHigh, XDisp, GOTO[ESCx],		c1, opcode[371'b];@@ESC:	Xbus ¬ ibHigh, XDisp,				c1, opcode[370'b];ESCx:	TT ¬ ib, XDisp, push, DISP4[ESCHi],			c2;	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC0n],	c3, at[0,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC1n],	c3, at[1,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC2n],	c3, at[2,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[3,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[4,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[5,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[6,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC7n],	c3, at[7,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC8n],	c3, at[8,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[9,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[0A,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[0B,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[0C,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[0D,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[0E,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[ESCa,0F],	c3, at[0F,10,ESCHi];ESCa:	PC ¬ PC - 1,							c1;ESCb:	T ¬ 0FF + TT + 1,						c2;ESCc:	G ¬ 1, GOTO[Trapc1],						c3;ESC0n:	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0,10,ESC0n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[1,10,ESC0n];	{@@MW in Process					c1, at[2,10,ESC0n];}	{@@MR in Process					c1, at[3,10,ESC0n];}	{@@NC in Process					c1, at[4,10,ESC0n];}	{@@BC in Process					c1, at[5,10,ESC0n];}	{@@REQ in Process				c1, at[6,10,ESC0n];}	{@@SM in Misc					c1, at[7,10,ESC0n];}	{@@SMF in Misc					c1, at[8,10,ESC0n];}	{@@GMF in Misc					c1, at[9,10,ESC0n];}	{@@AF in Xfer					c1, at[0A,10,ESC0n];}	{@@FF in Xfer					c1, at[0B,10,ESC0n];}	{@@PI in Xfer					c1, at[0C,10,ESC0n];}	{@@PO in Xfer					c1, at[0D,10,ESC0n];}	{@@POR in Xfer					c1, at[0E,10,ESC0n];}	{@@SPP in Process				c1, at[0F,10,ESC0n];}	{@@DI in Xfer					c1, at[0,10,ESC1n];}	{@@EI in Xfer					c1, at[1,10,ESC1n];}	{@@XOR in Stack					c1, at[2,10,ESC1n];}	{@@DAND in Stack					c1, at[3,10,ESC1n];}	{@@DIOR in Stack					c1, at[4,10,ESC1n];}	{@@DXOR in Stack					c1, at[5,10,ESC1n];}	{@@ROTATE in Stack				c1, at[6,10,ESC1n];}	{@@DSHIFT in Stack				c1, at[7,10,ESC1n];}	{@@LINT in Stack					c1, at[8,10,ESC1n];}	{@@JS in Jump					c1, at[9,10,ESC1n];}	{@@RCFS in StringField				c1, at[0A,10,ESC1n];}	{@@RC in Read					c1, at[0B,10,ESC1n];}	{@@UDIV in Stack					c1, at[0C,10,ESC1n];}	{@@LUDIV in Stack				c1, at[0D,10,ESC1n];}	{@@ROB in Read					c1, at[0E,10,ESC1n];}	{@@WOB in Write					c1, at[0F,10,ESC1n];}	{@@DSK in Xfer					c1, at[0,10,ESC2n];}	{@@XE in Xfer					c1, at[1,10,ESC2n];}	{@@XF in Xfer					c1, at[2,10,ESC2n];}	{@@LSK in Xfer					c1, at[3,10,ESC2n];}	{@@BNDCKL in Stack				c1, at[4,10,ESC2n];}	{@@NILCK in Stack				c1, at[5,10,ESC2n];}	{@@NILCKL in Stack				c1, at[6,10,ESC2n];}	{@@BLTLR in Block				c1, at[7,10,ESC2n];}	{@@BLEL in Block					c1, at[8,10,ESC2n];}	{@@BLECL in Block				c1, at[9,10,ESC2n];}	{@@CKSUM in Block				c1, at[0A,10,ESC2n];}	{@@BITBLT in BBInit				c1, at[0B,10,ESC2n];}	IfEqual[ProcList, TRUE, SkipTo[ProcListSoNoTxtBlt], Continue];IfEqual[Config, 0, SkipTo[TextBltImpl], ];ProcListSoNoTxtBlt!@@TXTBLT:	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0C,10,ESC2n];TextBltImpl!@@BYTBLT:	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0D,10,ESC2n];@@BYTBLTR:	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0E,10,ESC2n];	IfEqual[Config, 5, , SkipTo[VersionImpl]];{Version bytecode implemented for all configurations except TridentMagTapeMesa}@@VERSION:	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0F,10,ESC2n];VersionImpl!@@a177:	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0F,10,ESC7n];	{@@INPUT in Misc					c1, at[0,10,ESC8n];}	{@@OUTPUT in Misc				c1, at[1,10,ESC8n];}@@LOADRAMJ:	PC ¬ PC - 1, GOTO[ESCb],			c1, at[2,10,ESC8n];IfEqual[Config, 1, SkipTo[BandBltImpl], ];IfEqual[Config, 3, SkipTo[BandBltImpl], ];@@BANDBLT:	PC ¬ PC - 1, GOTO[ESCb],			c1, at[3,10,ESC8n];BandBltImpl!IfEqual[Config, 6, SkipTo[MultiportImpl], ];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[4,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[5,10,ESC8n];	MultiportImpl!{ a204 and a205 are implemented in the file MultiportMisc.mc. These are special funtions for the Dandelion Multiport Option card. @@a204:	uTemp ¬ TOS, pop, ZeroBr, 			c1, at[4,10,ESC8n];@@a205:  uTemp ¬ TOS, pop, ZeroBr, 			c1, at[5,10,ESC8n];}	PC ¬ PC - 1, GOTO[ESCb],			c1, at[6,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[7,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[8,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[9,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0A,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0B,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0C,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0D,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0E,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],			c1, at[0F,10,ESC8n];{*****************************************************************************	SM	Set Map*****************************************************************************}@@SM:	TOS ¬ TOS and 7, pop,				c1, at[7,10,ESC0n];	TT ¬ STK, pop,							c2;	TT ¬ TT LRot8,							c3;	Xbus ¬ STK, pop,						c1;	T ¬ STK, pop, 							c2;	rhT ¬ T ¬ T LRot8,						c3;	TOS ¬ TOS LRot4, fXpop, push,					c1;	TT ¬ TT and ~0F0,						c2;	TT ¬ TT or TOS, Xbus ¬ TOS LRot12, XDisp,			c3;SMd:	Map ¬ [rhT,T], T ¬ 80, DISP4[SMc,8],				c1;SMc:	MDR ¬ TT and ~T, IBDisp, GOTO[SLa],			c2, at[08,10,SMc];	MDR ¬ TT and ~T, IBDisp, GOTO[SLa],			c2, at[09,10,SMc];	MDR ¬ TT or T, IBDisp, GOTO[SLa],			c2, at[0A,10,SMc];	MDR ¬ TT or T, IBDisp, GOTO[SLa],			c2, at[0B,10,SMc];	MDR ¬ TT and ~T, IBDisp, GOTO[SLa],			c2, at[0C,10,SMc];	MDR ¬ TT and ~T, IBDisp, GOTO[SLa],			c2, at[0D,10,SMc];	MDR ¬ TT and ~T, IBDisp, GOTO[SLa],			c2, at[0E,10,SMc];	MDR ¬ TT or T, IBDisp, GOTO[SLa],			c2, at[0F,10,SMc];{*****************************************************************************	SMF	Set Map Flags*****************************************************************************}@@SMF:	TT ¬ TOS and 7, pop,  					c1, at[8,10,ESC0n];	T ¬ STK, pop, L0¬0,					c2;SMFa:	rhT ¬ T ¬ T LRot8, 					c3;	Map ¬ [rhT,T], { map entry }				c1;	Rx ¬ ~80, 						c2;	TOS ¬ Rx and MD, { mask dp flag }			c3;	TT ¬ TT{new flags} LRot4, fXpop, push,			c1;	Q ¬ ~0F0, 						c2;	[] ¬ TOS LRot0, XwdDisp {old flags},			c3;	Rx ¬ TOS LRot12, XLDisp {old flags}, DISP2[SMFb],	c1;		TOS ¬ TOS and Q, CANCELBR[SMFf,3],			c2, at[0,4,SMFb];	TOS ¬ TOS and Q, CANCELBR[SMFf,3],			c2, at[1,4,SMFb];	TOS ¬ TOS and Q, CANCELBR[SMFf,3],			c2, at[2,4,SMFb];	TOS ¬ TOS and Q, BRANCH[SMFe,SMFf,2],			c2, at[3,4,SMFb];	SMFe:	TT ¬ TOS or 60,	GOTO[SMFc],				c3;SMFf:	TT ¬ TOS or TT,	GOTO[SMFc],				c3;SMFc:	Rx ¬ Rx and 7,							c1;	TOS ¬ TOS LRot8, push,						c2;	STK ¬ Rx, push, L0Disp,						c3;	STK ¬ TOS, push,BRANCH[SMFd, GMFa],				c1;SMFd:	STK ¬ 0,							c2;	Xbus ¬ TT LRot12, XDisp, GOTO[SMd],				c3;{*****************************************************************************	GMF	Get Map Flags*****************************************************************************}@@GMF:	T ¬ STK, pop, L0¬1,				c1, at[9,10,ESC0n];	GOTO[SMFa],							c2;GMFa:	STK ¬ 0, IBDisp, GOTO[SLa],					c2;{*****************************************************************************	INPUT	Input*****************************************************************************}@@INPUT:	Ybus ¬ TOS, YDisp,				c1, at[0,10,ESC8n];	fXpop, push, IBDisp, DISP4[Input],				c2;Input:	TOS ¬ EIData, DISPNI[OpTable],			c3, at[0,10,Input];	TOS ¬ EStatus, DISPNI[OpTable],			c3, at[1,10,Input];	TOS ¬ KIData, DISPNI[OpTable],			c3, at[2,10,Input];	TOS ¬ KStatus, DISPNI[OpTable],			c3, at[3,10,Input];	TOS ¬ MStatus, DISPNI[OpTable],			c3, at[5,10,Input];	TOS ¬ KTest, DISPNI[OpTable],			c3, at[6,10,Input];	TOS ¬ IOPIData, DISPNI[OpTable],		c3, at[8,10,Input];	TOS ¬ IOPStatus, DISPNI[OpTable],		c3, at[9,10,Input];	TOS ¬ TStatus, DISPNI[OpTable],			c3, at[0A,10,Input];{*****************************************************************************	OUTPUT	Output*****************************************************************************}@@OUTPUT:	T ¬ STK, pop, Ybus ¬ TOS, YDisp,		c1, at[1,10,ESC8n];	TOS ¬ STK, pop, IBDisp, DISP4[Output],				c2;Output:	IOPOData ¬ T LRot0, DISPNI[OpTable],		c3, at[0,10,Output];	IOPCtl ¬ T LRot0, DISPNI[OpTable],		c3, at[1,10,Output];	KOData ¬ T LRot0, DISPNI[OpTable],		c3, at[2,10,Output];	KCtl ¬ T LRot0, DISPNI[OpTable],		c3, at[3,10,Output];	EOData ¬ T LRot0, DISPNI[OpTable],		c3, at[4,10,Output];	EICtl ¬ T LRot0, DISPNI[OpTable],		c3, at[5,10,Output];	PCtl ¬ T LRot0, DISPNI[OpTable],		c3, at[9,10,Output];	MCtl ¬ T, DISPNI[OpTable],			c3, at[0A,10,Output];	EOCtl ¬ T LRot0, DISPNI[OpTable],		c3, at[0C,10,Output];	KCmd ¬ T LRot0, DISPNI[OpTable],		c3, at[0D,10,Output];	TAddr ¬ T LRot0, DISPNI[OpTable],		c3, at[0E,10,Output];	POData ¬ T LRot0, DISPNI[OpTable],		c3, at[0F,10,Output];{*****************************************************************************	WR - Write Registers*****************************************************************************}@@WRPSB:	uPSB ¬ TOS,					c1, at[0,10,ESC7n];WRx:	TOS ¬ STK, pop, IBDisp, GOTO[DISPNIonly],		c2;{WRMDS should not update rhG and G if the global frame is not in the MDS. However, there's not enough microcode space to make the change here. Luckily the global frame is always in the MDS. See the correct Daybreak version. AHL}@@WRMDS:	UvMDS ¬ TOS, L0 ¬ 0,				c1, at[1,10,ESC7n];	Q ¬ UvL,						c2;WRMDSc:	rhMDS ¬ UvMDS,						c3;	Map ¬ Q ¬ [rhMDS, Q], L0Disp,				c1;	BRANCH[WRMDSa, WRMDSb],					c2;WRMDSa:	L ¬ rhL ¬ MD,						c3;	MAR ¬ L ¬ [rhL, Q+0],					c1;	Q ¬ UvG, L0 ¬ 1, GOTO[WRMDSc],				c2;WRMDSb:	G ¬ rhG ¬ MD,						c3;	MAR ¬ G ¬ [rhG, Q+0], GOTO[WRx],			c1;@@WRWP:	uWP ¬ TOS, GOTO[WRx],				c1, at[2,10,ESC7n];@@WRWDC:	uWDC ¬ TOS, GOTO[WRx],				c1, at[3,10,ESC7n];@@WRPTC:	uPTC ¬ TOS, GOTO[WRx],				c1, at[4,10,ESC7n];@@WRIT:	T ¬ STK, pop,					c1, at[5,10,ESC7n];	TT ¬ TOS,						c2;	TOS ¬ STK, pop,						c3;	{must write all three clock regs in single click}	uClockHigh ¬ TT,					c1;	uClockLow ¬ T, IBDisp,					c2;	uClockBits ¬ 0, DISPNI[OpTable],			c3;@@WRXTS:	uXTS ¬ TOS, GOTO[WRx],					c1, at[6,10,ESC7n];@@WRMP:	Rx ¬ uIOPage,						c1, at[7,10,ESC7n];	Q ¬ MaintenancePanelOffset,				c2;	rhRx ¬ IOPageHigh,					c3;	MAR ¬ [rhRx, Q + 0],					c1;	MDR ¬ TOS, IBDisp, GOTO[SLa],				c2;	{*****************************************************************************	RR - Read Registers*****************************************************************************}@@RRPSB:	TOS ¬ uPSB, push, GOTO[RRx],			c1, at[8,10,ESC7n];RRx:	push, fZpop, IBDisp, GOTO[DISPNIonly],			c2;@@RRMDS:	TOS ¬ UvMDS, push, GOTO[RRx],			c1, at[9,10,ESC7n];@@RRWP:	TOS ¬ uWP, push, GOTO[RRx],			c1, at[0A,10,ESC7n];@@RRWDC:	TOS ¬ uWDC, push, GOTO[RRx],			c1, at[0B,10,ESC7n];@@RRPTC:	TOS ¬ uPTC, push, GOTO[RRx],			c1, at[0C,10,ESC7n];@@RRXTS:	TOS ¬ uXTS, push, GOTO[RRx],			c1, at[0E,10,ESC7n];@@RRIT:	Q ¬ uClockHigh, push,				c1, at[0D,10,ESC7n];	TOS ¬ RShift1 uClockBits, SE¬0,				c2;	TT ¬ uClockLow, push, GOTO[ADCa],			c3;{*****************************************************************************	VERSION - Give Microcode Version*****************************************************************************}{ See MicrocodeVersion.mesa for the fine print.Fancy macros by DXC, 23-Sep-83 11:20:09}Set[year, 85'd ];Set[month, 5'd ];Set[day, 16'd] ;Set[year, Sub[year, 80'd] ];Set[month, Sub[month, 1] ];{ly = 1 if leap year, else 0}MacroDef[LY, IfAndZero[year, 3, Set[ly, 1], Set[ly, 0] ] ];{nly = number of leap years gone by}MacroDef[NLY, Set[nly, Rshift[Add[year, 3], 2] ] ];{af = 0 if jan or feb, else 1}MacroDef[AF, IfGreater[month, 1, Set[af, 1], Set[af, 0] ] ];{af29 = 1 iff leap year and not jan or feb}MacroDef[AF29, IfEqual[ly, 0, Set[af29, 0], Set[af29, af] ] ];{msmall = num 31 day months passed if month <= july}MacroDef[Msmall, Set[msmall, Rshift[Add[1, month],1] ] ];{mlarge = num 31 day months passed if month > july}MacroDef[Mlarge, Set[mlarge, Rshift[Add[2, month],1] ] ];{n31 = number of 31 day months passed this year}MacroDef[N31, IfGreater[month, 6, Set[n31, mlarge], Set[n31, msmall] ] ];MacroDef[RD00, Set[rd00, Mul[365'd, year] ] ];MacroDef[RD01, Set[rd01, Mul[30'd, month] ] ];MacroDef[Eighty, Set[reldate, Add[reldate, 28853'd] ] ]; {Days from 1901 to 1980}MacroDef[RelDate,       Set[reldate, Add[          rd00,	  rd01,	  day,	  nly,	  af29,	  n31] ] ];MacroDef[RD02, Set[reldate, Sub[reldate, af] ] ];LY; NLY; AF; AF29; Msmall; Mlarge; N31; RD00; RD01; RelDate; Eighty; RD02; RD02;MacroDef[HighHalf, Rshift[#1, 8] ];MacroDef[LowHalf, And[0FF, #1] ];Set[highDate, HighHalf[reldate]];Set[lowDate, LowHalf[reldate]];IfEqual[Config, 5, SkipTo[VersionNotImpl], ];{Version bytecode implemented for all configurations except TridentMagTapeMesa}@@VERSION:	T ¬ 060, push, {DLion, first version with Version}	c1, at[0F,10,ESC2n];	T ¬ T LRot8,						c2;	STK ¬ TOS, push, T ¬ T or 0, {No Float, No Cedar}	c3;		TOS ¬ highDate,						c1;	TOS ¬ TOS LRot8,					c2;	TOS ¬ TOS or lowDate,					c3;		STK ¬ T, GOTO[RRx], 					c1;VersionNotImpl!{*****************************************************************************	Unimplemented Opcodes*****************************************************************************}IfGreater[Config, 0, SkipTo[NoBytePointers], ];@@STC:	T ¬ 0F,							c1, opcode[77'b];	T ¬ T and ~ErrnIBnStkp,					c2;	Ybus ¬ T xor ib, ZeroBr,				c3;	T ¬ sStackError, BRANCH[Trapc2, $], 			c1;	PC ¬ PC + 1, IBDisp, GOTO[DISPNIonly],			c2;@@MBP:	Q ¬ STK, fXpop, fZpop, push,			c1, opcode[175'b];	[] ¬ Q or TOS, ZeroBr, 					c2; 	PC ¬ PC + PC16, BRANCH[$, NxtInstc1],       		c3;	Rx ¬ DLShift1 TOS, Cin ¬ 1,				c1;	TOS ¬ Rx or u8000, 					c2;	STK ¬ Q, GOTO[NxtInstc1], 				c3; 		Set[sBytePointerTrap, 10];	BPErr:	T ¬ sBytePointerTrap, GOTO[Trapc3],			c2;@@RBP:	T ¬ STK, L3¬0, 					c1, opcode[176'b];	Q ¬ T + ibNA, L1¬L1.Push, CarryBr, GOTO[BPSub],	LOOPHOLE[stw],	c2;	@@WBP:	T ¬ STK, L3¬1, 					c1, opcode[177'b];	Q ¬ T + ibNA, L1¬L1.Push, CarryBr, GOTO[BPSub],	LOOPHOLE[stw], 	c2;	BPSub:	Rx ¬ TOS, NegBr, BRANCH[BPNoCr, BPCar],			c3;BPNoCr: BRANCH[BPErr, BPCont],					c1;BPCar:  Rx ¬ Rx + 1, BRANCH[BPErr, BPCont],			c1;	   BPCont:	Rx ¬ Rx and (~u8000), 					c2;	Rx ¬ DRShift1 (Rx xor 1), Cin ¬ 0, 			c3;	rhTT ¬ Rx LRot0, TT ¬ Q, 				c1;	T ¬ T + ib, pop, GOTO[RLSf],				c2;SkipTo[DoneBytePointers];NoBytePointers!	TT ¬ 77'b, push, GOTO[OpcodeTrap],		c1, opcode[77'b];	TT ¬ 175'b, push, GOTO[OpcodeTrap],		c1, opcode[175'b];	TT ¬ 176'b, push, GOTO[OpcodeTrap],		c1, opcode[176'b];	TT ¬ 177'b, push, GOTO[OpcodeTrap],		c1, opcode[177'b];DoneBytePointers!Unimp:	TT ¬ 376'b, push, GOTO[OpcodeTrap],		c1, opcode[376'b];OpcodeTrap:	T ¬ sOpcodeTrap, STK ¬ TOS, pop, GOTO[ESCc],	c2;	{ E N D }	@


1.1.1.1
log
@first add
@
text
@@
