head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ Copyright (C) 1980  by Xerox Corporation. All rights reserved. } {File name:  <Workstation>mc>Sunlight-O.mc}		SetTask[0]; StartAddress[RrhTest];TERROR1:	  ClrIntErr,CANCELBR[$,0F],   c*, at[0];TERROR:	  GOTO[TERROR],   c*;{3b.	R & RH register test.}{Write each R & RH register with its address (R0=0) and complement of address (R0=0FFFF).  "Q xor R0" is the R register address, i.e. Q holds both the address & address complement.}RrhTest:	R0 ¬ 0,CANCELBR[$,0F]	,c1;	uSaveTestCnt ¬ TestCnt	,c2;WriteRAddr1:	Q ¬ R0 {Q¬0 or 0FFFF}	,c3;WriteRAddr:	[] ¬ Q xor R0, YDisp	,c1;	DISP4[WrRAddr]	,c2;WrRAddr:	R0 ¬ Q, rhR0 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[0,10,WrRAddr];	R1 ¬ Q, rhR1 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[1,10,WrRAddr];	R2 ¬ Q, rhR2 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[2,10,WrRAddr];	R3 ¬ Q, rhR3 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[3,10,WrRAddr];	R4 ¬ Q, rhR4 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[4,10,WrRAddr];	R5 ¬ Q, rhR5 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[5,10,WrRAddr];	R6 ¬ Q, rhR6 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[6,10,WrRAddr];	R7 ¬ Q, rhR7 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[7,10,WrRAddr];	R8 ¬ Q, rhR8 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[8,10,WrRAddr];	R9 ¬ Q, rhR9 ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[9,10,WrRAddr];	RA ¬ Q, rhRA ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[0A,10,WrRAddr];	RB ¬ Q, rhRB ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[0B,10,WrRAddr];	RC ¬ Q, rhRC ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[0C,10,WrRAddr];	RD ¬ Q, rhRD ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[0D,10,WrRAddr];	RE ¬ Q, rhRE ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[0E,10,WrRAddr];	RF ¬ Q, rhRF ¬ Q LRot0, GOTO[WrRAddrL]	,c3, at[0F,10,WrRAddr];WrRAddrL:	Q ¬ Q xor R0	,c1;	Q ¬ Q + 1, NibCarryBr	,c2;	Q ¬ Q xor R0, BRANCH[WriteRAddr, ReadRAddr1]	,c3;{Verify the above write.  Each R reg should contain its address or ~address}ReadRAddr1:	Q ¬ R0 {Q¬0 or 0FFFF}, GOTO[ReadRAddrx]	,c1;ReadRAddr2:	[] ¬ Q xor R0, YDisp, GOTO[ReadRAddrx]	,c1;ReadRAddrx:	DISP4[RdRAddr]	,c2;RdRAddr:	[] ¬ R0 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0,10,RdRAddr];	[] ¬ R1 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[1,10,RdRAddr];	[] ¬ R2 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[2,10,RdRAddr];	[] ¬ R3 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[3,10,RdRAddr];	[] ¬ R4 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[4,10,RdRAddr];	[] ¬ R5 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[5,10,RdRAddr];	[] ¬ R6 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[6,10,RdRAddr];	[] ¬ R7 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[7,10,RdRAddr];	[] ¬ R8 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[8,10,RdRAddr];	[] ¬ R9 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[9,10,RdRAddr];	[] ¬ RA xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0A,10,RdRAddr];	[] ¬ RB xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0B,10,RdRAddr];	[] ¬ RC xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0C,10,RdRAddr];	[] ¬ RD xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0D,10,RdRAddr];	[] ¬ RE xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0E,10,RdRAddr];	[] ¬ RF xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0F,10,RdRAddr];{Verify the above write.  Each RH reg should contain its address or ~address}RdRAddrL:	[] ¬ Q xor R0, YDisp, BRANCH[RBad, RGood]	,c1;RGood:	Q ¬ Q and 0FF, DISP4[RdRHAddr]	,c2;RdRHAddr:	[] ¬ rhR0 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0,10,RdRHAddr];	[] ¬ rhR1 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[1,10,RdRHAddr];	[] ¬ rhR2 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[2,10,RdRHAddr];	[] ¬ rhR3 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[3,10,RdRHAddr];	[] ¬ rhR4 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[4,10,RdRHAddr];	[] ¬ rhR5 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[5,10,RdRHAddr];	[] ¬ rhR6 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[6,10,RdRHAddr];	[] ¬ rhR7 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[7,10,RdRHAddr];	[] ¬ rhR8 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[8,10,RdRHAddr];	[] ¬ rhR9 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[9,10,RdRHAddr];	[] ¬ rhRA xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0A,10,RdRHAddr];	[] ¬ rhRB xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0B,10,RdRHAddr];	[] ¬ rhRC xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0C,10,RdRHAddr];	[] ¬ rhRD xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0D,10,RdRHAddr];	[] ¬ rhRE xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0E,10,RdRHAddr];	[] ¬ rhRF xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0F,10,RdRHAddr];RdRHAddrL:	R0 ¬ R0 and ~0FF, BRANCH[RHBad, RHGood]	,c1;RHGood:	Q ¬ Q or R0 {restore Q to 0 or 0FFFF}	,c2;	R0 ¬ (R0 LRot8) or R0 {restore R0 to 0 or 0FFFF}	,c3;	Q ¬ Q xor R0	,c1;	Q ¬ Q + 1, NibCarryBr	,c2;	Q ¬ Q xor R0, BRANCH[ReadRAddr2, $]	,c3;	[] ¬ R0, ZeroBr	,c1;	R0 ¬ ~R0 {R0¬0FFFF}, BRANCH[LinkTest, WriteRAddr1]	,c2;{3c.	Link Register tests. Write each link with address (Q=0) & ~address (Q=0FFFF). R1 holds data from link register, R0 is the address.}{Write Links with their address}LinkTest:	L0 ¬ 0, TestCnt ¬ uSaveTestCnt	,c3;	L1 ¬ 1, TestCnt ¬ TestCnt + 1 {TestCnt=8}	,c1;	L2 ¬ 2	,c2;	L3 ¬ 3	,c3;	L4 ¬ 4	,c1;	L5 ¬ 5	,c2;	L6 ¬ 6	,c3;	L7 ¬ 7, Q ¬ 0	,c1;	R0 ¬ 0, GOTO[RdLAddr]	,c2;{Verify the above write.  Each Link reg should contain its address or complement address}ReadLAddr:	[] ¬ R0, YDisp	,c1;	DISP3[RdLAddr]	,c2;RdLAddr:	L0Disp, GOTO[RdLAddrL]	,c3, at[0,10,RdLAddr];	L1Disp, GOTO[RdLAddrL]	,c3, at[1,10,RdLAddr];	L2Disp, GOTO[RdLAddrL]	,c3, at[2,10,RdLAddr];	L3Disp, GOTO[RdLAddrL]	,c3, at[3,10,RdLAddr];	L4Disp, GOTO[RdLAddrL]	,c3, at[4,10,RdLAddr];	L5Disp, GOTO[RdLAddrL]	,c3, at[5,10,RdLAddr];	L6Disp, GOTO[RdLAddrL]	,c3, at[6,10,RdLAddr];	L7Disp, GOTO[RdLAddrL]	,c3, at[7,10,RdLAddr];RdLAddrL:	DISP4[LinkValue]	,c1;LinkValue:	R1 ¬  0 , GOTO[LinkValueL]	,c2, at[0,10,LinkValue];	R1 ¬  1 , GOTO[LinkValueL]	,c2, at[1,10,LinkValue];	R1 ¬  2 , GOTO[LinkValueL]	,c2, at[2,10,LinkValue];	R1 ¬  3 , GOTO[LinkValueL]	,c2, at[3,10,LinkValue];	R1 ¬  4 , GOTO[LinkValueL]	,c2, at[4,10,LinkValue];	R1 ¬  5 , GOTO[LinkValueL]	,c2, at[5,10,LinkValue];	R1 ¬  6 , GOTO[LinkValueL]	,c2, at[6,10,LinkValue];	R1 ¬  7 , GOTO[LinkValueL]	,c2, at[7,10,LinkValue];	R1 ¬  8 , GOTO[LinkValueL]	,c2, at[8,10,LinkValue];	R1 ¬  9 , GOTO[LinkValueL]	,c2, at[9,10,LinkValue];	R1 ¬ 0A , GOTO[LinkValueL]	,c2, at[0A,10,LinkValue];	R1 ¬ 0B , GOTO[LinkValueL]	,c2, at[0B,10,LinkValue];	R1 ¬ 0C , GOTO[LinkValueL]	,c2, at[0C,10,LinkValue];	R1 ¬ 0D , GOTO[LinkValueL]	,c2, at[0D,10,LinkValue];	R1 ¬ 0E , GOTO[LinkValueL]	,c2, at[0E,10,LinkValue];	R1 ¬ 0F , GOTO[LinkValueL]	,c2, at[0F,10,LinkValue];LinkValueL:	R1 ¬ R1 xor Q	,c3;	R1 ¬ R1 and 0F	,c1;	Noop	,c2;	[] ¬ R0 xor R1, ZeroBr	,c3;	BRANCH[LinkBad, LinkGood]	,c1;LinkGood:	[] ¬ R0 xor 7, ZeroBr	,c2;	R0 ¬ R0 + 1, BRANCH[ReadLAddr, $]	,c3;	Noop	,c1;	[] ¬ Q, ZeroBr	,c2;	BRANCH[UTest, WrLCAddr]	,c3;{WriteLinks with ~address.}WrLCAddr:	Q ¬ ~Q {Q¬0FFFF}	,c1;	L0 ¬ 0F	,c2;	L1 ¬ 0E	,c3;	L2 ¬ 0D	,c1;	L3 ¬ 0C	,c2;	L4 ¬ 0B	,c3;	L5 ¬ 0A	,c1;	L6 ¬ 9	,c2;	L7 ¬ 8, R0 ¬ 0, GOTO[ReadLAddr]	,c3;{3d.	SU regs test}{Simple U reg tests.  Can we write UA5 with 0's?}UTest:	UA5 ¬ 0, CANCELBR[$, 0F]	,c1;	[] ¬ UA5, ZeroBr	,c2;	TestCnt ¬ TestCnt + 1 {TestCnt=9}, BRANCH[UA5ZeroBad, UA5ZeroGd]	,c3;{Can we write UA5 with 1's?}UA5ZeroGd:	UA5 ¬ ~RA xor RA	,c1;	[] ¬ ~UA5, ZeroBr	,c2;	BRANCH[UA5OneBad, UA5OneGd]	,c3;{Can we write U5A with 0's?}UA5OneGd:	U5A ¬ 0, CANCELBR[$, 0F]	,c1;	[] ¬ U5A, ZeroBr	,c2;	Q ¬ 0, BRANCH[U5AZeroBad, U5AZeroGd]	,c3;{Can we write U5A with 1's?}U5AZeroGd:	U5A ¬ ~R5 xor R5	,c1;	[] ¬ ~U5A, ZeroBr	,c2;	R0 ¬ 0A, BRANCH[U5AOneBad, U5AOneGd]	,c3;{Can we address U5A via AltUaddr?}U5AOneGd:	[] ¬ R0, AltUaddr	,c1;	[] ¬ ~U5, ZeroBr	,c2;	Q ¬ 0, BRANCH[U5OneBad, WriteUAddr2]	,c3;{Complete U reg test. Write all U regs with their addresses (Q=0) and with the inverse of their address (Q=0FFFF). R0 holds U addr.}WriteUAddr2:	R0 ¬ 0, GOTO[WriteUAddrx] {Q=0}	,c1;WriteUAddr1:	R0 ¬ 0, GOTO[WriteUAddrx]	,c1;WriteUAddr:	Xbus ¬ R0 LRot12, XDisp	,c1;WriteUAddrx:	R0 ¬ R0 xor Q, Ybus ¬ R0, AltUaddr, DISP4[WrUAddr]	,c2;WrUAddr:	U0 ¬ R0, GOTO[WrUAddrL]	,c3, at[0,10,WrUAddr];	U1 ¬ R0, GOTO[WrUAddrL]	,c3, at[1,10,WrUAddr];	U2 ¬ R0, GOTO[WrUAddrL]	,c3, at[2,10,WrUAddr];	U3 ¬ R0, GOTO[WrUAddrL]	,c3, at[3,10,WrUAddr];	U4 ¬ R0, GOTO[WrUAddrL]	,c3, at[4,10,WrUAddr];	U5 ¬ R0, GOTO[WrUAddrL]	,c3, at[5,10,WrUAddr];	U6 ¬ R0, GOTO[WrUAddrL]	,c3, at[6,10,WrUAddr];	U7 ¬ R0, GOTO[WrUAddrL]	,c3, at[7,10,WrUAddr];	U8 ¬ R0, GOTO[WrUAddrL]	,c3, at[8,10,WrUAddr];	U9 ¬ R0, GOTO[WrUAddrL]	,c3, at[9,10,WrUAddr];	UA ¬ R0, GOTO[WrUAddrL]	,c3, at[0A,10,WrUAddr];	UB ¬ R0, GOTO[WrUAddrL]	,c3, at[0B,10,WrUAddr];	UC ¬ R0, GOTO[WrUAddrL]	,c3, at[0C,10,WrUAddr];	UD ¬ R0, GOTO[WrUAddrL]	,c3, at[0D,10,WrUAddr];	UE ¬ R0, GOTO[WrUAddrL]	,c3, at[0E,10,WrUAddr];	UF ¬ R0, GOTO[WrUAddrL]	,c3, at[0F,10,WrUAddr];WrUAddrL:	R0 ¬ R0 xor Q	,c1;	R0 ¬ R0 + 1, PgCarryBr	,c2;	BRANCH[WriteUAddr, ReadUAddr1]	,c3;{Verify the above write.  Each U reg should contain its address or complement address}ReadUAddr2:	CANCELBR[ReadUAddr]	,c3;ReadUAddr1:	R0 ¬ 0, GOTO[ReadUAddrx]	,c1;ReadUAddr:	Xbus ¬ R0 LRot12, XDisp	,c1;ReadUAddrx:	[] ¬ R0, AltUaddr, DISP4[RdUAddr]	,c2;RdUAddr:	R1 ¬ U0 , GOTO[RdUAddrL]	,c3, at[0,10,RdUAddr];	R1 ¬ U1 , GOTO[RdUAddrL]	,c3, at[1,10,RdUAddr];	R1 ¬ U2 , GOTO[RdUAddrL]	,c3, at[2,10,RdUAddr];	R1 ¬ U3 , GOTO[RdUAddrL]	,c3, at[3,10,RdUAddr];	R1 ¬ U4 , GOTO[RdUAddrL]	,c3, at[4,10,RdUAddr];	R1 ¬ U5 , GOTO[RdUAddrL]	,c3, at[5,10,RdUAddr];	R1 ¬ U6 , GOTO[RdUAddrL]	,c3, at[6,10,RdUAddr];	R1 ¬ U7 , GOTO[RdUAddrL]	,c3, at[7,10,RdUAddr];	R1 ¬ U8 , GOTO[RdUAddrL]	,c3, at[8,10,RdUAddr];	R1 ¬ U9 , GOTO[RdUAddrL]	,c3, at[9,10,RdUAddr];	R1 ¬ UA , GOTO[RdUAddrL]	,c3, at[0A,10,RdUAddr];	R1 ¬ UB , GOTO[RdUAddrL]	,c3, at[0B,10,RdUAddr];	R1 ¬ UC , GOTO[RdUAddrL]	,c3, at[0C,10,RdUAddr];	R1 ¬ UD , GOTO[RdUAddrL]	,c3, at[0D,10,RdUAddr];	R1 ¬ UE , GOTO[RdUAddrL]	,c3, at[0E,10,RdUAddr];	R1 ¬ UF , GOTO[RdUAddrL]	,c3, at[0F,10,RdUAddr];RdUAddrL:	R1 ¬ R1 xor Q	,c1;	[] ¬ R1 xor R0, ZeroBr	,c2;	BRANCH[UBad, UGood]	,c3;UGood:	R0 ¬ R0 + 1, PgCarryBr	,c1;	[] ¬ Q, ZeroBr, BRANCH[ReadUAddr2, $]	,c2;	Q ¬ ~Q, BRANCH[STKtst, WriteUAddr1]	,c3;{check stackP addressing.  Read low 16 U registers via stackP}STKtst:	R0 ¬ stackP ¬ 0	,c1;STKLp:	Noop	,c2;	Xbus ¬ 0 {precharge X}	,c3;	Q ¬ ~STK xor R0, NZeroBr	,c1;	R0 ¬ R0 + 1, NibCarryBr, BRANCH[$, STKAddrBad]	,c2;	BRANCH[$, NOERROR1]	,c3;	push, GOTO[STKLp]	,c1;{R0 contains the U reg address, R1 contains the data from the U reg (or compl of data if Q=0FFF}UBad:	RErr ¬ 75, GOTO[UBad]	,c*;U5OneBad:	RErr ¬ 76, GOTO[U5OneBad]	,c*;UA5ZeroBad:	RErr ¬ 77, GOTO[UA5ZeroBad]	,c*;UA5OneBad:	RErr ¬ 78, GOTO[UA5OneBad]	,c*;U5AOneBad:	RErr ¬ 79, GOTO[U5AOneBad]	,c*;U5AZeroBad:	RErr ¬ 7A, GOTO[U5AZeroBad]	,c*;STKAddrBad:	RErr ¬ 0B0, CANCELBR[STKAddrBad1]	,c*;STKAddrBad1:	RErr ¬ 0B0, GOTO[STKAddrBad1]	,c*;{Q holds the R register address (or ~Q if R0=0FFFF).}RBad:	RErr ¬ 7B, CANCELBR[RBad1, 0F]	,c*;RBad1:	RErr ¬ 7B, GOTO[RBad1]	,c*;{Q holds the RH register address (or ~Q if R0=0FFFF).}RHBad:	RErr ¬ 7C, GOTO[RHBad]	,c*;{R0 is the link address.  R1 holds the contents of the Link reg.}LinkBad:	RErr ¬ 7D, GOTO[LinkBad]	,c*;NOERROR1:	GOTO[NOERROR],	                           	c*;NOERROR:	GOTO[NOERROR],	                           	c*, at[0FFF];@


1.1.1.1
log
@first add
@
text
@@
