head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ Copyright (C) 1980  by Xerox Corporation. All rights reserved. } {File name:  <Workstation>mc>Sunlight-O.mc} 		SetTask[0]; StartAddress[Go];TERROR1:	  ClrIntErr,CANCELBR[$,0F],   c*, at[0];TERROR:	  GOTO[TERROR],   c*;{0.  Branch Tests}{Turn off IO devices}{In the following branch tests, branch conditions are not specified in c3 so the TC registers is not implicitly tested.}{Can we do a Cycle2 branch?  Is Cycle2 stuck 0?}Go:	RErr ¬ 0,CANCELBR[$, 0F],	c1, at[0AA0];	XC2npcDisp,	c2;	BRANCH[C2Bad0x, C2Good0x, 0D],	c3;C2Br:	GOTO[BranchBad],	c1, at[0,10];	GOTO[BranchBad],	c1, at[1,10,C2Br];	GOTO[BranchBad],	c1, at[2,10,C2Br];	GOTO[BranchBad],	c1, at[3,10,C2Br];	GOTO[BranchBad],	c1, at[4,10,C2Br];	GOTO[BranchBad],	c1, at[5,10,C2Br];	GOTO[BranchBad],	c1, at[6,10,C2Br];	GOTO[BranchBad],	c1, at[7,10,C2Br];	GOTO[BranchBad],	c1, at[8,10,C2Br];	GOTO[BranchBad],	c1, at[9,10,C2Br];	GOTO[BranchBad],	c1, at[0A,10,C2Br];	GOTO[BranchBad],	c1, at[0B,10,C2Br];	GOTO[BranchBad],	c1, at[0C,10,C2Br];C2Bad0x:	GOTO[C2Bad0],	c1, at[0D,10,C2Br];	GOTO[BranchBad],	c1, at[0E,10,C2Br];{Is Cycle2 stuck 1?}C2Good0x:	XC2npcDisp,	c1, at[0F,10,C2Br];	BRANCH[C2Good1, C2Bad1, 0D],	c2;{Can we do a NegBr?  Is F.0 stuck 0?  Secondary test of aF=7 in bit 0.}C2Good1:	Noop,	c3;	[] ¬ ~R0 xor R0, NegBr,	c1;	BRANCH[NegBad0, NegGood0],	c2;{Is F.0 stuck 1?}NegGood0:	Noop,	c3;	[] ¬ 0 {doesn't use X bus}, NegBr,	c1;	BRANCH[NegGood1, NegBad1],	c2;{Can we do a ZeroBr?  Is FZero stuck 0?}NegGood1:	Noop,	c3;	[] ¬ 0, ZeroBr,	c1;	BRANCH[ZeroBad0, ZeroGood0],	c2;{Is FZero stuck 1?}ZeroGood0:	Noop,	c3;	[] ¬ ~R0 xor R0, ZeroBr,	c1;	BRANCH[ZeroGood1, ZeroBad1],	c2;{Can we do a NZeroBr?  Is FNonZero stuck 0?}ZeroGood1:	Noop,	c3;	[] ¬ ~R0 xor R0, NZeroBr,	c1;	BRANCH[NZeroBad0, NZeroGood0],	c2;{Is FNonZero stuck 1?}NZeroGood0:	Noop,	c3;	[] ¬ 0, NZeroBr,	c1;	BRANCH[NZeroGood1, NZeroBad1],	c2;{Can we do an OvBr?  Is Ovr stuck 0? Secondary test of RShift1.}NZeroGood1:	R0 ¬ RShift1 (~R0 xor R0),  {R0 ¬ 7FFF}	c3;	R0 ¬ R0 + R0, PgCrOvDisp,	c1;	R2 ¬ 0, BRANCH[OvBad0, OvGood0, 2],	c2;{Is Ovr stuck 1?}OvGood0:	R0 ¬ 0,	c3;	R2 ¬ R0 + 0, PgCrOvDisp,	c1;	ClrIntErr, BRANCH[OvGood1, OvBad1, 2],	c2;{Can we do a MesaIntBr?  Is MesaInt stuck 0? Secondary test of ClrIntErr & MesaIntRq.}OvGood1:	MesaIntRq,	c3;	MesaIntBr,	c1;	BRANCH[MIBad0, MIGood0],	c2;{Is MesaInt stuck 1?}MIGood0:	ClrIntErr,	c3;	MesaIntBr,	c1;	BRANCH[MIGood1, MIBad1],	c2;{R0 register test.  Can we write R0 with 0's?}MIGood1:	R0 ¬ 0	,c3;	[] ¬ R0, ZeroBr	,c1;	BRANCH[R0ZeroBad, R0ZeroGd]	,c2;{Can we write R0 with 1's?}R0ZeroGd:	R0 ¬ ~R0 {R0¬0FFFF}	,c3;	[] ¬ ~R0, ZeroBr	,c1;	BRANCH[R0OneBad, QTest]	,c2;{Q register test.  Can we write Q with 0's?}QTest:	Q ¬ 0	,c3;	[] ¬ Q, ZeroBr	,c1;	BRANCH[QZeroBad, QZeroGd]	,c2;{Can we write Q with 1's?}QZeroGd:	Q ¬ ~Q {Q¬0FFFF}	,c3;	[] ¬ ~Q, ZeroBr	,c1;	BRANCH[QOneBad, QOneGd]	,c2;{Can we do a NibCarryBr?  Is NibCarry stuck 0?}QOneGd:	R0 ¬ 0,	c3;	[] ¬ -R0 {doens't use x bus}, NibCarryBr,	c1;	BRANCH[NibCBad0, NibCGood0],	c2;{Is NibCarry stuck 1?}NibCGood0:	Noop,	c3;	[] ¬ R0 + 0, NibCarryBr,	c1;	BRANCH[NibCGood1, NibCBad1],	c2;{Can we do a PgCarryBr? Is PageCarry stuck 0? (add test)}NibCGood1:	R0 ¬ ~R0 xor R0,	c3;	[] ¬ R0 + 1, PgCarryBr,	c1;	BRANCH[PgCyBad0, PgCyGood0],	c2;{Is PageCarry stuck 1? (add test)}PgCyGood0:	R0 ¬ 0,	c3;	[] ¬ R0 + 0, PgCarryBr,	c1;	BRANCH[PgCyGood1, PgCyBad1],	c2;{Can we do a PgCrossBr?  Is PageCross stuck 0? (subtract test) Does aF.2 flip result?}PgCyGood1:	R0 ¬ 0,	c3;	[] ¬ R0 - 1, PgCrOvDisp,	c1;	BRANCH[PgCBad0a, PgCGood0a, 1],	c2;{Is PageCross stuck 1? (subtract test)}PgCGood0a:	R0 ¬ 1,	c3;	[] ¬ R0 - 1, PgCrOvDisp,	c1;	BRANCH[PgCGood1a, PgCBad1a, 1],	c2;{Is PageCross stuck 0? (add test)}PgCGood1a:	R0 ¬ ~R0 xor R0,	c3;	[] ¬ R0 + 1, PgCrOvDisp,	c1;	BRANCH[PgCBad0b, PgCGood0b, 1],	c2;{Is PageCross stuck 1? (add test)}PgCGood0b:	R0 ¬ 0,	c3;	[] ¬ R0 + 0, PgCrOvDisp,	c1;	BRANCH[PgCGood1b, PgCBad1b, 1],	c2;{Can we do a CarryBr?  Is Carry stuck 0?}PgCGood1b:	R0 ¬ ~R0 xor R0,	c3;	[] ¬ R0 + 1, CarryBr,	c1;	BRANCH[CarryBad0, CarryGood0],	c2;{Is Carry stuck 1?}CarryGood0:	R0 ¬ 0,	c3;	[] ¬ R0 + 0, CarryBr,	c1;	BRANCH[CarryGood1, CarryBad1],	c2;{Can we do a XRefBr?  Is X.11 stuck 0? Secondary test of constant on X.11}CarryGood1:	Xbus ¬ 0 {precharge X},	c3;	Xbus ¬ (~R0 xor R0) LRot0, XRefBr,	c1;	BRANCH[XRefBad0, XRefGood0],	c2;{Is X.11 stuck 1?}XRefGood0:	Xbus ¬ (~R0 xor R0) LRot0 {precharge X},	c3;	Xbus ¬ 0, XRefBr,	c1;	BRANCH[XRefGood1, XRefBad1],	c2;{Can we do a XDisp?  Is X[12-15] stuck 0? Can we put a nibble onto X bus?}XRefGood1:	R0 ¬ 0, Xbus ¬ 0 {precharge X},	c3;	Xbus ¬ 0F, XDisp,	c1;	R1 ¬ R0, ZeroBr, DISP4[XDispT0],	c2;XDispT0:	CANCELBR[XDispBad0],	c3, at[0,10];	CANCELBR[XDispBad0],	c3, at[1,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[2,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[3,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[4,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[5,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[6,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[7,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[8,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[9,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[0A,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[0B,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[0C,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[0D,10,XDispT0];	CANCELBR[XDispBad0],	c3, at[0E,10,XDispT0];{Is X[12-15] stuck 1?}XDispGood0:	Xbus ¬ 0F {precharge X},  BRANCH[XwdDisp0, $],	c3, at[0F,10,XDispT0];	Xbus ¬ 0,  XDisp,	c1;	R1 ¬ R1 + 1, DISP4[XDispT1],	c2;{Is X[9,10] stuck 1?}XwdDisp0:	Xbus ¬ 0,  XwdDisp,	c1;	R1 ¬ R1 + 10, DISP4[XDispT1, 0C],	c2;XDispT1:	GOTO[XDispGood1],	c3, at[0,10];	GOTO[XDispBad1],	c3, at[1,10,XDispT1];	GOTO[XDispBad1],	c3, at[2,10,XDispT1];	GOTO[XDispBad1],	c3, at[3,10,XDispT1];	GOTO[XDispBad1],	c3, at[4,10,XDispT1];	GOTO[XDispBad1],	c3, at[5,10,XDispT1];	GOTO[XDispBad1],	c3, at[6,10,XDispT1];	GOTO[XDispBad1],	c3, at[7,10,XDispT1];	GOTO[XDispBad1],	c3, at[8,10,XDispT1];	GOTO[XDispBad1],	c3, at[9,10,XDispT1];	GOTO[XDispBad1],	c3, at[0A,10,XDispT1];	GOTO[XDispBad1],	c3, at[0B,10,XDispT1];	GOTO[XDispGood1],	c3, at[0C,10,XDispT1];	GOTO[XDispBad1],	c3, at[0D,10,XDispT1];	GOTO[XDispBad1],	c3, at[0E,10,XDispT1];	GOTO[XDispBad1],	c3, at[0F,10,XDispT1];{Can we do a XwdDisp?  Is X[9,10] stuck 0?}XDispGood1:	Noop,	c1;	[] ¬ R0, ZeroBr, {come through here twice}	c2;	R0 ¬ ~R0 xor R0, Xbus ¬ 0 {precharge X}, BRANCH[XwdGood1, $],	c3;	Xbus ¬ R0 LRot0, XwdDisp,	c1;	[] ¬ R0, ZeroBr, DISP4[XDispT0, 0C],	c2;{Can we do a YDisp?  Is Y[12-15] stuck 0? Secondary test of nibble}XwdGood1:	Ybus ¬ 0F, YDisp,	c1;	DISP4[YDispT0],	c2;YDispT0:	GOTO[YDispBad0],	c3, at[0,10,YDispT0];	GOTO[YDispBad0],	c3, at[1,10,YDispT0];	GOTO[YDispBad0],	c3, at[2,10,YDispT0];	GOTO[YDispBad0],	c3, at[3,10,YDispT0];	GOTO[YDispBad0],	c3, at[4,10,YDispT0];	GOTO[YDispBad0],	c3, at[5,10,YDispT0];	GOTO[YDispBad0],	c3, at[6,10,YDispT0];	GOTO[YDispBad0],	c3, at[7,10,YDispT0];	GOTO[YDispBad0],	c3, at[8,10,YDispT0];	GOTO[YDispBad0],	c3, at[9,10,YDispT0];	GOTO[YDispBad0],	c3, at[0A,10,YDispT0];	GOTO[YDispBad0],	c3, at[0B,10,YDispT0];	GOTO[YDispBad0],	c3, at[0C,10,YDispT0];	GOTO[YDispBad0],	c3, at[0D,10,YDispT0];	GOTO[YDispBad0],	c3, at[0E,10,YDispT0];{Is X[12-15] stuck 1?}YDispGood0:	Ybus ¬ 0F {precharge Y},	c3, at[0F,10,YDispT0];	Ybus ¬ 0, YDisp,	c1;	DISP4[YDispT1],	c2;YDispT1:	Xbus ¬ 0 {precharge X}, GOTO[YDispGood1],	c3, at[0,10,YDispT1];	GOTO[YDispBad1],	c3, at[1,10,YDispT1];	GOTO[YDispBad1],	c3, at[2,10,YDispT1];	GOTO[YDispBad1],	c3, at[3,10,YDispT1];	GOTO[YDispBad1],	c3, at[4,10,YDispT1];	GOTO[YDispBad1],	c3, at[5,10,YDispT1];	GOTO[YDispBad1],	c3, at[6,10,YDispT1];	GOTO[YDispBad1],	c3, at[7,10,YDispT1];	GOTO[YDispBad1],	c3, at[8,10,YDispT1];	GOTO[YDispBad1],	c3, at[9,10,YDispT1];	GOTO[YDispBad1],	c3, at[0A,10,YDispT1];	GOTO[YDispBad1],	c3, at[0B,10,YDispT1];	GOTO[YDispBad1],	c3, at[0C,10,YDispT1];	GOTO[YDispBad1],	c3, at[0D,10,YDispT1];	GOTO[YDispBad1],	c3, at[0E,10,YDispT1];	GOTO[YDispBad1],	c3, at[0F,10,YDispT1];{Can we do a XLDisp?  Is X.8 stuck 0? Secondary test of constant on X.8}YDispGood1:	Xbus ¬ (~R0 xor R0) LRot0, XLDisp,	c1;	BRANCH[X8Bad0, X8Good0,1],	c2;{Is X.8 stuck 1?}X8Good0:	Xbus ¬ (~R0 xor R0) LRot0 {precharge X},	c3;	Xbus ¬ 0, XLDisp,	c1;	R0 ¬ ~R0 xor R0, BRANCH[X8Good1, X8Bad1,1],	c2;{Can we do a XHDisp?  Is X.0 stuck 0? Secondary test of LRot0}X8Good1:	Xbus ¬ 0 {precharge X},	c3;	Xbus ¬ (~R0 xor R0) LRot0, XHDisp,	c1;	BRANCH[X0Bad0, X0Good0,2],	c2;{Is X.0 stuck 1?}X0Good0:	TestCnt ¬ TestCnt + 1, { TestCnt=1 }	c3;	Xbus ¬ 0, XHDisp,	c1;	R0 ¬ ~R0 xor R0, BRANCH[NOERROR1, X0Bad1,2],	c2;BranchBad:	RErr ¬ 1, GOTO[BranchBad],	c*;C2Bad0:	RErr ¬ 2, GOTO[C2Bad0],	c*;C2Bad1:	RErr ¬ 3, GOTO[C2Bad1],	c*;NegBad0:	RErr ¬ 4, GOTO[NegBad0],	c*;NegBad1:	RErr ¬ 5, GOTO[NegBad1],	c*;ZeroBad0:	RErr ¬ 6, GOTO[ZeroBad0],	c*;ZeroBad1:	RErr ¬ 7, GOTO[ZeroBad1],	c*;NZeroBad0:	RErr ¬ 8, GOTO[NZeroBad0],	c*;NZeroBad1:	RErr ¬ 9, GOTO[NZeroBad1],	c*;OvBad0:	RErr ¬ 0A, GOTO[OvBad0],	c*;OvBad1:	RErr ¬ 0B, GOTO[OvBad1],	c*;MIBad0:	RErr ¬ 0C, GOTO[MIBad0],	c*;MIBad1:	RErr ¬ 0D, GOTO[MIBad1],	c*;R0ZeroBad:	RErr ¬ 0E, GOTO[R0ZeroBad]	,c*;R0OneBad:	RErr ¬ 0F, GOTO[R0OneBad]	,c*;QZeroBad:	RErr ¬ 10, GOTO[QZeroBad]	,c*;QOneBad:	RErr ¬ 11, GOTO[QOneBad]	,c*;NibCBad0:	RErr ¬ 12, GOTO[NibCBad0],	c*;NibCBad1:	RErr ¬ 13, GOTO[NibCBad1],	c*;PgCyBad0:	RErr ¬ 14, GOTO[PgCyBad0],	c*;PgCyBad1:	RErr ¬ 15, GOTO[PgCyBad1],	c*;PgCBad0a:	RErr ¬ 16, GOTO[PgCBad0a],	c*;PgCBad1a:	RErr ¬ 17, GOTO[PgCBad1a],	c*;PgCBad0b:	RErr ¬ 18, GOTO[PgCBad0b],	c*;PgCBad1b:	RErr ¬ 19, GOTO[PgCBad1b],	c*;CarryBad0:	RErr ¬ 1A, GOTO[CarryBad0],	c*;CarryBad1:	RErr ¬ 1B, GOTO[CarryBad1],	c*;XRefBad0:	RErr ¬ 1C, GOTO[XRefBad0],	c*;XRefBad1:	RErr ¬ 1D, GOTO[XRefBad1],	c*;XDispBad0:	RErr ¬ 1E, GOTO[XDispBad0],	c*;XDispBad1:	RErr ¬ 1F, GOTO[XDispBad1],	c*;YDispBad0:	RErr ¬ 20, GOTO[YDispBad0],	c*;YDispBad1:	RErr ¬ 21, GOTO[YDispBad1],	c*;X8Bad0:	RErr ¬ 22, GOTO[X8Bad0],	c*;X8Bad1:	RErr ¬ 23, GOTO[X8Bad1],	c*;X0Bad0:	RErr ¬ 24, GOTO[X0Bad0],	c*;X0Bad1:	RErr ¬ 25, GOTO[X0Bad1],	c*;NOERROR1:	GOTO[NOERROR],	                           	c*;NOERROR:	GOTO[NOERROR],	                           	c*, at[0FFF];@


1.1.1.1
log
@first add
@
text
@@
