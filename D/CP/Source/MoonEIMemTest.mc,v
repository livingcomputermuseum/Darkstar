head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.08;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.08;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ Copyright (C) 1980, 1984  by Xerox Corporation. All rights reserved. }{Purcell    6-Feb-84 12:54:01  Added AdjustQ for 8mb real mem}MacroDef[ThenElse, BRANCH[#2, #1]];	Set[PicLenShifted, 0CA]; {PicLength = 328'x = 808'd. PicLenShifted = RShift2 PicLength}{Format of Display Control Block}	Set[IOPageHigh, 0];	Set[IOPage, 0];	Set[DCBLoc, 08];	Set[WakeupLoc, 0];	Set[DBitsLoc, 1];	Set[BorderLoc, 2];	Set[cursorXLoc, 3];	Set[cursorYLoc, 4];	Set[cursorMapLoc, 5];RegDef[acR, R, 0];	{Contains picture pattern -- used by Emulator task}RegDef[rA, R, 0];	{Test Use -- used by Emulator task}RegDef[rB, R, 1];	{Test Use -- used by Emulator task}{RegDef[TT, R, 2], RegDef[rhTT, RH, 2];	{Test Use -- used by Emulator task}}RegDef[rC, R, 3];	{Test Use -- used by Emulator task}RegDef[rD, R, 4];	{Used by Emulator}RegDef[Random, R, 5];	{Used by Emulator}RegDef[patternMode, U, 0];	{0=> checkerboard, otherwise chevron}RegDef[cursorMode, U, 1];	{0=> slash in cursor, non-zero=> flower in cursor}RegDef[moveMode, U, 2];	{0=> no movement, non-zero=> random Walk}{Emulator task. Initialize Display Control Register, cursor, and paint pattern}	SetTask[0]; StartAddress[Start];TERROR0:	  ClrIntErr,CANCELBR[TERROR1,0F],   c*, at[0];TERROR1:  RCTEMP¬TEST,   c2 ;          RCTEMP¬RCTEMP xor 4,ZeroBr,   c3 ;          BRANCH[TERROR,$],   c1;	  {restore ADDRESSU from RF}  	  ADDRESSU ¬ RF LRot0,GOTO[RUNLIST4Y],	c2;	    TERROR:	  RCTEMP¬FAULTTYPE,   c2 ;          R0¬INMAP,ZeroBr,   c3 ;          RCTEMP¬RCTEMP or 4,BRANCH[MDATAERR1,TERROR2],   c1;	   {restore ADDRESSU from RF}  	           TERROR2:  ADDRESSU ¬ RF LRot0,   c2 ;          Noop,   c3 ;          GOTO[DATAERR1],   c1;Start: rC ¬ LShift1 0FF, SE¬1, CANCELBR[$, 0F]	,c1;	rC ¬ LShift1 rC, SE¬1	,c2;	rC ¬ LShift1 rC, SE¬1	,c3;	u7FF ¬ rC	,c1;	rC ¬ LShift1 rC, SE¬1	,c2;	rC ¬ LShift1 rC, SE¬1	,c3;	u1FFF ¬ rC	,c1;	rC ¬ LShift1 rC, SE¬1	,c2;	        u3FFF ¬ rC	,c3;		rD¬ 3,	c1; {808 visible lines}	rD¬ rD LRot8,	c2;	rD¬ rD or 28,	c3;walk:	DCtl ¬ 1	,c1;ChkBound:	rA ¬ uInitPicLength	,c2;	[] ¬ rD - rA, NegBr {Y>=328?}	,c3;	BRANCH[$, YBotOK]	,c1;	rD ¬ 0, GOTO[ChkYTop]	,c2;YBotOK:	Noop	,c2;ChkYTop:	[] ¬ rD, NegBr {Y<0?}	,c3;	rB ¬ u3FF, BRANCH[YTopOK, $]	,c1;	rD ¬ rA - 1 {rD¬327}, GOTO[ChkDone]	,c2;YTopOK:	Noop	,c2;ChkDone:	rC ¬ rC and rB{cursorX and 3FF}, GOTO[RecieveU]	,c3;StartM:	RCTEMP¬STYPE,	c1;            TYPE¬RCTEMP,	 c2;	        RCTEMP¬USEED,	c3;            RCTEMP¬USEED,	c1;            RCTEMP¬RCTEMP LRot8,	 c2;	        R0¬ LSEED,	c3;            RCTEMP¬RCTEMP or R0,	c1;            SEED¬RCTEMP ,	 c2;	        R1 ¬43,	c3;            DCtl ¬ R1 LRot0 ,GOTO[RUNLIST],            c1;    	           RUNLIST: pCall4,	c2;RUNLISTX: CALL[SETUP],	c3, at[0,10];         RCTEMP¬TEST, GOTO[RUNL],  c1, at[0, 10, RunRet];RUNL: RCTEMP¬RCTEMP LRot0,XDisp ,	c2;	        DISP4[RunTest],	c3;	       RunTest: GOTO[RUNLIST1],	c1, at[0, 10, RunTest];	    GOTO[RUNLIST2],	c1, at[1, 10, RunTest];	    GOTO[RUNLIST1],	c1, at[2, 10, RunTest];	    RCTEMP¬MCTLDATA,GOTO[ECCTEST],	c1, at[3, 10, RunTest];	    RCTEMP¬MCTLDATA, GOTO[TRAPTEST],	c1, at[4, 10, RunTest];	    RF¬MPAGEE,GOTO[RUNLIST2A],	c1, at[5, 10, RunTest]; RUNLIST1: pCall4,	c2;            CALL[SETUP],	c3, at[1,10];    Noop,            c1, at[1,10,RunRet];	pCall4,	c2;	CALL[SSTORE],	c3, at[2,10];    R0¬DELAYV,GOTO[Delay],	  c1, at[2,10,RunRet];Delay: R1¬ R0 LRot4,            c2;          Delay1:[]¬R0 , ZeroBr,  c3;   R0¬R0 - 1,BRANCH[$,Delay2],  c1;   GOTO[Delay1],       c2;Delay2: RCTEMP¬TEST,	c2;	[]¬R1 , ZeroBr,  c3;   R1¬R1 - 1,BRANCH[$,RUNL1],  c1;   GOTO[Delay1],       c2;RUNL1:   RCTEMP¬RCTEMP LRot0,XDisp ,	c2;	        DISP4[RunTest1],	c3;	       RunTest1: GOTO[RUNLIST4],	c1, at[0, 10, RunTest1];	  GOTO[RUNLIST2],	c1, at[1, 10, RunTest1];	  GOTO[RUNLIST2],	c1, at[2, 10, RunTest1];	  GOTO[RUNLIST2],	c1, at[3, 10, RunTest1];	       RUNLIST2:        pCall4,	c2;                 Noop,	CALL[SETUP],	c3, at[3,10];                     Noop,            c1, at[3,10,RunRet];	         pCall4,	c2;	         CALL[CHECK],	c3, at[4,10];                 R4 ¬ SEED,   c1, at[4,10,RunRet];     	         [] ¬ R6 xor 1,ZeroBr,	c2;		 BRANCH[RUNLIST4X,$],	c3;                 RF¬MPAGEE,            c1;RUNLIST2A:	 pCall4,	c2;	         CALL[SETUP],	c3, at[5,10];		                          R3¬ RF LRot8,            c1,at[5,10,RunRet];	         R1¬ MBANKE,pCall4,	c2;	         CALL[MAP],	c3, at[6,10];RUNLIST4: Noop,            c2;RUNLIST4Y: R4 ¬ SEED,            c3;RUNLIST4X: RCTEMP ¬ NODATAINC,            c1, at[6,10,RunRet];             [] ¬ RCTEMP, ZeroBr,  c2;              RCTEMP ¬ NOTYPEINC,BRANCH[CHECKINC1,DATAINC],     c3;CHECKINC1: [] ¬ RCTEMP, ZeroBr,  c1;              RCTEMP ¬ PASSCOUNT,BRANCH[CHECKPASS,TYPEINC],     c2;TYPEINC:    RF ¬ R6+1 ,     c3;            RF ¬RF xor 5,     c1;            RF ¬ RF ,ZeroBr ,     c2;	                R6 ¬ R6+1, BRANCH[TYPE0,TYPE1],     c3;	      TYPE0:       GOTO[TYPE3],   c1;TYPE1:       R6 ¬ 0,   c1;TYPE3:       TYPE ¬ R6 ,     c2;	     GOTO[CHECKINC1],     c3;   DATAINC: R0 ¬ R4 LRot8,     c1;            R0 ¬  R0+1,     c2;            R0  ¬   R0 and 0FF ,    c3;            UWSEED ¬ R0 ,     c1;            R4 ¬ R4 +1,     c2;            R4 ¬R4 and 0FF,     c3;            LWSEED ¬ R4 ,     c1;            R0 ¬R0 LRot8,     c2;            R4 ¬R4 or R0,     c3;            SEED ¬ R4 ,     c1;            Noop,     c2;            Noop,GOTO[CHECKINC1],     c3;       CHECKPASS:  RCTEMP ¬ RCTEMP-1,ZeroBr,    c3;                 PASSCOUNT ¬ RCTEMP,BRANCH[RUNLIST,PASSDONE1],  c1;  PASSDONE1:  RCTEMP ¬ 1,     c2;                PASSCOUNT ¬ RCTEMP,     c3;                RCTEMP¬STOPONERR,   c1 ;                RCTEMP¬RCTEMP xor 2,ZeroBr,   c2 ;                BRANCH[PASSDONE2,$],   c3;                GOTO[RUNLIST],     c1;               PASSDONE2:  Noop,     c1;                pCall6,     c2;                CALL[ULOG],	 c3, at[3,10];             PASSDONE: GOTO[SendU],   c1, at[3,10,LogRet];RUNLISTRET:    Noop,	c1;                pRet4,	c2;	            RET[RunRet],	c3;	            	            ECCTEST:   RCTEMP ¬ LShift1 RCTEMP,  c2;              R0 ¬ RCTEMP LRot8,	c3;              R0 ¬ R0 and 1,	c1;              R0 ¬ LShift1 R0,  c2;              R0 ¬ LShift1 R0,	c3;              RCTEMP ¬ RCTEMP or R0,	c1;              RCTEMP ¬ RCTEMP and 0FF,  c2;              MCTLDATA ¬ RCTEMP,	c3;	      GOTO[RUNLIST1],	c1;             TRAPTEST: RCTEMP ¬ LShift1 RCTEMP,  c2;              R0 ¬ RCTEMP LRot8,	c3;              R0 ¬ R0 and 1,	c1;              R0 ¬ LShift1 R0,  c2;              R0 ¬ LShift1 R0,	c3;              RCTEMP ¬ RCTEMP or R0,	c1;              RCTEMP ¬ RCTEMP and 0FF,  c2;              MCTLDATA ¬ RCTEMP,	c3;	      {% enable large real memory: MCtl ¬ 8002h or xx}              Noop,		c1;	      RCTEMP¬ RRot1 (RCTEMP + RCTEMP +1), 	c2;              MCtl ¬ 2 or RCTEMP,	c3;	      Q ¬ ADDRESSU, L3 ¬ 9,		c1;	      RF{ADDRESSU} ¬ Q, CALL[AdjustQ],	c2;              ADDRESSU ¬ Q LRot0,			c3, at[9, 10, AdjustRet];		      MAR ¬ [ADDRESSU, ADDRESSL+0], 	c1;	      MDR¬R4, 	c2;              RCTEMP¬STOPONERR,	c3;              MAR ¬ [ADDRESSU, ADDRESSL+0], 	c1;	      EXPECTED¬R4,	c2;              OBSERVED¬MD ,	c3;	      RCTEMP¬RCTEMP xor 2,ZeroBr,   c1 ;              ADDRESSU ¬ RF LRot0, BRANCH[TRAPERR1,TRAPERR2],   c2 ;TRAPERR1:     GOTO[TRAPERR], 	c3;TRAPERR2:     GOTO[NoTraperror], 	c3;TRAPERR:     RCTEMP¬FAULTTYPE,	 c1;             RCTEMP¬RCTEMP or 8,pCall6, c2;             FAULTTYPE¬RCTEMP,CALL[ULOG],	 c3, at[2,10];             NoTraperror: GOTO[SendU],   c1, at[2,10,LogRet];                           {SUBROUTINES*************************************}{enable large real memory: MCtl ¬ 2 or xx}SETUP:  R1¬MCTLDATA,	c1;        R1¬ RRot1 (R1 + R1 +1),           c2;        MCtl ¬ 2 or R1,	c3;	        RCTEMP¬TEST,	c1;	RCTEMP¬RCTEMP and 7,	c2;	TEST¬RCTEMP,	c3;        FAULTTYPE¬0,	c1;	R1¬BANKE,	c2;	ADDRESSU¬BANKS,	c3;        ADDRESSL¬PAGES,	c1;	ADDRESSL¬ADDRESSL LRot8 ,	c2;	R3¬WORDS,	c3;        ADDRESSL¬ADDRESSL or R3,	c1;	IADDRESSU¬BANKE,	c2;        IADDRESSL¬PAGEE,	c3;	IADDRESSL¬IADDRESSL LRot8 ,	c1;	R3¬WORDE,	c2;        IADDRESSL¬IADDRESSL or R3,	c3;        R3¬PAGEE ,	c1;	R3¬R3 LRot8,	c2;        R4¬WORDE	c3;	R3¬R3 or R4 ,	c1;	R4¬SEED,	c2;        R6¬TYPE,GOTO[RUNLISTRET],	c3;	{SUBROUTINES*************************************}{R1=BANKE}{ADDRESSL=PAGES,WORDS ADDRESSU=BANKS}{IADDRESSL=PAGEE,WORDE IADDRESSU=BANKE}{R3=PAGEE,WORDE }{R4=SEED}{R5=MODIFIER}{R6=TYPE}{RF holds ADDRESSH}{RIADD holds IADDRESSH}{Q, L3 smashed by AdjustQ}{rearrange highest real address bits in ADDRESSU: 4xx53210}SSTORE:	Q ¬ ADDRESSU, L3 ¬ 5,		c1;	RF{ADDRESSU} ¬ Q, CALL[AdjustQ],	c2;        ADDRESSU ¬ Q LRot0,			c3, at[5, 10, AdjustRet];		Q ¬ IADDRESSU, L3 ¬ 6,		c1;	RIADD{IADDRESSU} ¬ Q, CALL[AdjustQ],	c2;        IADDRESSU ¬ Q LRot0,			c3, at[6, 10, AdjustRet];		[] ¬ R6, YDisp, 	c1;	        DISP4[STYPE, 08],   c2;STYPE:     R5¬0, GOTO[SSTORE3],           c3, at[08,10,STYPE];           R4¬ADDRESSL, GOTO[SSTORE2],  c3, at[09,10,STYPE];           R5¬R4, GOTO[SSTORE3],        c3, at[0A,10,STYPE];           R5¬0, GOTO[SSTORE3],         c3, at[0B,10,STYPE];           R5¬0, GOTO[SSTORE1],         c3, at[0C,10,STYPE];           SSTORE1:	[] ¬ R6, YDisp, 	c1;	        DISP4[STYPE1, 08],   c2;STYPE1:    Noop, GOTO[SSTORE3],                c3, at[08,10,STYPE1];           R4¬ ADDRESSL, GOTO[SSTORE2],        c3, at[09,10,STYPE1];           R4¬ R4 + R5, GOTO[SSTORE3],         c3, at[0A,10,STYPE1];           R4¬ R4 xor ~R5, GOTO[SSTORE3],      c3, at[0B,10,STYPE1];           R4 ¬ RF xor 0FF,                c3, at[0C,10,STYPE1];	   R4¬ R4 LRot8 ,	c1;           R4¬ R4 or RF ,	c2;           GOTO[SSTORE3],        c3;           SSTORE2: MAR ¬ [IADDRESSU, IADDRESSL+0], 	c1;	MDR ¬  IADDRESSL, 	c2;        Noop,	c3;SSTORE3: MAR ¬ [ADDRESSU, ADDRESSL+0], 	c1;	 MDR¬R4, 	c2;         [] ¬ ADDRESSL xor R3, ZeroBr,	c3;         ADDRESSL ¬ ADDRESSL +1 , BRANCH[SDOAGAIN,SLMATCH],	c1;SDOAGAIN: IADDRESSL ¬ IADDRESSL -1,	c2;         GOTO[SSTORE1],	c3;        SLMATCH: RIADD{IADDRESSU} ¬ RIADD -1, L3 ¬ 7,	c2;	Q ¬ RIADD, CALL[AdjustQ],		c3;	IADDRESSU ¬ Q LRot0,			c1, at[7, 10, AdjustRet];	Noop,					c2;	R5 ¬ R5 + RF{ADDRESSU} +1,		c3;		[] ¬ RF{ADDRESSU} xor R1, ZeroBr, L3 ¬ 8,	   c1;          RF ¬ RF+1 , BRANCH[SDOAGAIN1,SUMATCH], 	c2;	                 SDOAGAIN1:  Q ¬ RF{ADDRESSU}, CALL[AdjustQ], 	   c3;              ADDRESSU ¬ Q LRot0,	c1, at[8, 10, AdjustRet];	    IADDRESSL¬PAGEE,	c2;	    IADDRESSL¬IADDRESSL LRot8 ,	c3;	    RCTEMP¬WORDE,	c1;            IADDRESSL¬IADDRESSL or RCTEMP,  c2;            ADDRESSL¬PAGES,	c3;	    ADDRESSL¬ADDRESSL LRot8 ,	c1;	    RCTEMP¬WORDS,	c2;            ADDRESSL¬ADDRESSL or RCTEMP, GOTO[SSTORE1]	c3;SUMATCH:   ADDRESSU ¬ RF LRot0, GOTO[RUNLISTRET],	c3;         {SUBROUTINES*************************************}{R1=BANKE}{ADDRESSL=PAGES,WORDS ADDRESSU=BANKS}{R3=PAGEE,WORDE }{R4=SEED}{R5=MODIFIER}{R6=TYPE}{OBSERVED=OBSERVED}{EXPECTED=EXPECTED}{RF ¬ ADDRESSU}{smashes Q}{rearrange highest real address bits in ADDRESSU: 4xx53210}CHECK:   	Q ¬ ADDRESSU, L3 ¬ 1,	c1;	RF{ADDRESSU} ¬ Q, CALL[AdjustQ], c2;	ADDRESSU ¬ Q LRot0,	c3, at[1, 10, AdjustRet];			[] ¬ R6, YDisp, 	c1;	        INMAP¬0,DISP4[CTYPE, 08],   c2;CTYPE:     R5¬0,  GOTO[CHECK2],            c3, at[08,10,CTYPE];           R4¬ADDRESSL, GOTO[CHECK2],      c3, at[09,10,CTYPE];           R5¬R4,GOTO[CHECK2],             c3, at[0A,10,CTYPE];           R5¬0, GOTO[CHECK2],             c3, at[0B,10,CTYPE];           R5¬0, GOTO[CHECK1],             c3, at[0C,10,CTYPE];           CHECK1:  	[] ¬ R6, YDisp, 	c1;	        DISP4[CTYPE1, 08],   c2;CTYPE1:    Noop, GOTO[CHECK2],                c3, at[08,10,CTYPE1];           R4¬ ADDRESSL, GOTO[CHECK2],        c3, at[09,10,CTYPE1];           R4¬ R4 + R5, GOTO[CHECK2],         c3, at[0A,10,CTYPE1];           R4¬ R4 xor ~R5, GOTO[CHECK2],      c3, at[0B,10,CTYPE1];           R4¬ RF xor 0FF,                 c3, at[0C,10,CTYPE1];	   R4¬ R4 LRot8,	c1;           R4¬ R4 or RF ,	c2;           GOTO[CHECK2],        c3;           CHECK2: MAR ¬ [ADDRESSU, ADDRESSL+0], 	c1;	EXPECTED¬~R4,	c2;        OBSERVED¬MD ,	c3;       CHECKENTRY: [] ¬ OBSERVED xor R4, NZeroBr, 	   c1;         EXPECTED¬R4,BRANCH[$,DATAERR{restore ADDRESSU}], 	c2;       [] ¬ ADDRESSL xor R3, ZeroBr,	c3;       ADDRESSL ¬ ADDRESSL +1 ,BRANCH[CDOAGAIN,CLMATCH],	c1;CDOAGAIN: Noop,	c2;CDOAGAIN2:GOTO[CHECK1],	c3;        CLMATCH: ADDRESSU ¬ RF LRot0,	c2;         R5 ¬ R5 + RF{ADDRESSU}+1,       c3;                [] ¬ RF{ADDRESSU} xor R1, ZeroBr, L3 ¬ 2,   c1;          RF ¬ RF+1, BRANCH[CDOAGAIN1,CUMATCH], 	c2;	                 CDOAGAIN1:  Q ¬ RF{ADDRESSU}, CALL[AdjustQ], c3;            ADDRESSU ¬ Q LRot0,	c1, at[2, 10, AdjustRet];            ADDRESSL¬PAGES,	c2;	    ADDRESSL¬ADDRESSL LRot8 ,	c3;	    RCTEMP¬WORDS,	c1;            ADDRESSL¬ADDRESSL or RCTEMP, GOTO[CDOAGAIN2]	c2;	    CUMATCH:     Noop,	 c3;             [] ¬ FAULTTYPE, NZeroBr,            c1;             BRANCH[$,Derror],            c2;             GOTO[RUNLISTRET],	c3;Derror:      RCTEMP¬STOPONERR,	 c3;             RCTEMP¬RCTEMP xor 2,ZeroBr,	c1;             BRANCH[Derror1,Derror2],   c2 ;Derror1:     GOTO[Dataerror],   c3;Derror2:     GOTO[RUNLISTRET],     c3;         DATAERR:	ADDRESSU ¬ RF{ADDRESSU} LRot0,	c3;		Noop,	c1;		Noop,	c2;	        RCTEMP¬FAULTTYPE,	 c3;                RCTEMP¬RCTEMP or 1,            c1;DATAERR1:      FAULTTYPE¬RCTEMP,pCall6,            c2;               EXPECTED¬R4, CALL[ULOG],	c3, at[0,10];                 Noop,	  c1, at[0,10,LogRet];	         [] ¬ STOPONERR, ZeroBr,	  c2;	         BRANCH[DataNoStop,Dataerror],	 	c3;DataNoStop:  Q ¬ ADDRESSU, L3 ¬ 3,	c1;	     RF{ADDRESSU} ¬ Q, CALL[AdjustQ], c2;	     ADDRESSU ¬ Q LRot0,	c3, at[3, 10, AdjustRet];             EXPECTED¬R4,   c1;             OBSERVED¬R4,   c2;             GOTO[CHECKENTRY],	 c3;Dataerror:   GOTO[SendU],   c1;             {SUBROUTINES*************************************}{Q=BANK on entry}{Q=Adjusted Bank on exit}{uses 3 cycles = 1 click}{Link3 return thru AdjustRet}AdjustQ:	Xbus ¬ Q{BANK} LRot12, XDisp, c*;	DISP4[AdjTab, 0C], pRet3,	c*;		Q ¬ Q xor 0{0=>0}, RET[AdjustRet],	c*, at[0C, 10, AdjTab];	Q ¬ Q xor 90{1=>8}, RET[AdjustRet],	c*, at[0D, 10, AdjTab];	Q ¬ Q xor 30{2=>1}, RET[AdjustRet],	c*, at[0E, 10, AdjTab];	Q ¬ Q xor 0A0{3=>9}, RET[AdjustRet],	c*, at[0F, 10, AdjTab];	                          {SUBROUTINES*************************************}{R1=BANKE}{ADDRESSL=PAGES,WORDS ADDRESSU=BANKS}{R3=PAGEE,WORDE }{R4=SEED}{R5=MODIFIER}{R6=TYPE}{OBSERVED=OBSERVED}{EXPECTED=EXPECTED}MAP:	RCTEMP ¬ MAP,                                    c1;        [] ¬ RCTEMP,ZeroBr,	c2;        RCTEMP ¬ 1,  BRANCH[MAPOFF,MAPON] ,	c3;MAPOFF: INMAP¬0, 	c1;	        GOTO[MUMATCH], 	c2;MAPON: INMAP¬RCTEMP,GOTO[MDOAGAIN], 	c1;                  MAP2: Map ¬ [ADDRESSU, ADDRESSL+0], 	c1;       OBSERVED¬~EXPECTED,	c2;       OBSERVED¬MD ,	c3;MAPENTRY: [] ¬ OBSERVED xor EXPECTED, NZeroBr, 	   c1;         BRANCH[$,MDATAERR], 	c2;       [] ¬ ADDRESSL xor R3, ZeroBr,	c3;       ADDRESSL ¬ ADDRESSL +0FF+1 ,BRANCH[MDOAGAIN,MLMATCH],	c1;MDOAGAIN: EXPECTED ¬ ADDRESSL LRot8,	c2;        EXPECTED ¬ EXPECTED and 0FF,	c3;        RCTEMP ¬ ADDRESSL,                                   c1;        ADDRESSL ¬ ADDRESSU ,	c2;        ADDRESSL ¬ ADDRESSL LRot8 ,	c3;    EXPECTED ¬ EXPECTED or ADDRESSL,                              c1;        ADDRESSL ¬ RCTEMP ,	c2;        GOTO[MAP2],	c3;       MLMATCH: RCTEMP ¬ ADDRESSL,	c2;        ADDRESSL ¬ ADDRESSU,                               c3;        [] ¬ ADDRESSL xor R1, ZeroBr, 	   c1;       ADDRESSL ¬ ADDRESSL +1, BRANCH[MDOAGAIN1,MUMATCH], 	c2;	                 MDOAGAIN1:  ADDRESSU ¬ ADDRESSL LRot0, 	c3;         ADDRESSL ¬ RCTEMP , GOTO[MDOAGAIN],	c1;         MUMATCH:      Noop,	 c3;              [] ¬ FAULTTYPE, NZeroBr,            c1;              BRANCH[$,MDerror],            c2;              GOTO[RUNLISTRET],	c3;MDerror:  RCTEMP¬STOPONERR,	 c3;          RCTEMP¬RCTEMP xor 2,ZeroBr,	c1;          BRANCH[MDerror1,MDerror2],   c2 ;MDerror1: GOTO[MapDataerror],   c3;MDerror2: GOTO[RUNLISTRET],     c3;       MDATAERR:    RCTEMP¬FAULTTYPE,	 c3;             RCTEMP¬RCTEMP or 2,            c1;MDATAERR1:   FAULTTYPE¬RCTEMP,pCall6,            c2;             CALL[ULOG],	c3, at[1,10];             Noop,	  c1, at[1,10,LogRet];	     [] ¬ STOPONERR, ZeroBr,	  c2;	     BRANCH[MDataNoStop,MapDataerror],	 	c3;MDataNoStop: EXPECTED¬R4,   c1;             OBSERVED¬R4,   c2;             GOTO[MAPENTRY],	 c3;MapDataerror:  GOTO[SendU],   c1;             {SUBROUTINES*************************************}ULOG:    	RCTEMP¬ADDRESSL,	c1;	        ADDRESSL¬ADDRESSU,	c2;	        WBANKS¬ADDRESSL,	c3;                ADDRESSL¬RCTEMP and 0FF ,	c1;	        WWORDS¬ADDRESSL ,	c2;	        ADDRESSL¬RCTEMP,	c3;                RCTEMP¬RCTEMP LRot8 ,	c1;	        RCTEMP¬RCTEMP and 0FF ,	c2;                WPAGES¬RCTEMP ,	c3;                RCTEMP¬OBSERVED and 0FF,	c1;	        LOBSERVED¬RCTEMP,	c2;	        RCTEMP¬OBSERVED LRot8,	c3;                RCTEMP¬RCTEMP and 0FF,	c1;	        UOBSERVED¬RCTEMP,	c2;	        RCTEMP¬EXPECTED	and 0FF,c3;                LEXPECTED¬RCTEMP,	c1;	        RCTEMP¬EXPECTED LRot8,	c2;	        RCTEMP¬RCTEMP and 0FF,	c3;	        UEXPECTED¬RCTEMP ,	c1;                RCTEMP¬SEED ,	c2;	        RCTEMP¬ RCTEMP and 0FF ,	c3;                LWSEED¬RCTEMP ,	c1;                RCTEMP¬SEED ,	c2;	        RCTEMP¬ RCTEMP LRot8 ,	c3;                RCTEMP¬RCTEMP and 0FF ,	c1;                UWSEED¬RCTEMP,	c2;	        GOTO[ULogRet],	c3;  	   	         ULogRet:        Noop,	c1;                pRet6,	c2;	        RET[LogRet],	c3;RecieveU:	Noop,         c1;			{Clear flags}	IOPCtl ¬ 5 ,     c2;	{Set mode of IOP port, + Attn to indicate proceed to IOP}	R1¬0,                            c3;				{Clear data register}	WaitIn:	Xbus ¬ IOPStatus, XLDisp ,     c1;	{Is IOPReq true?, Put R0 on Y bus}	BRANCH [WaitIn1, In, XOdd],     c2;	{XOdd => IOPReq, Put R0 on Y bus}WaitIn1:	GOTO[WaitIn],        c3;	In:	IOPCtl ¬ 1 ,                       c3;		{Set mode of IOP port, clear Attn}	R0¬IOPIData ,     c1;	{Input value}	R3¬10,        c2;    R4¬20,GOTO[StoreU],        c3;StoreU:	[] ¬ R1 and R3, ZeroBr  ,              c1;			        []¬ R1, AltUaddr,BRANCH [SecondLU, FirstLU] ,   c2;FirstLU:	    BANKS¬ R0, GOTO[CHECKLU]  ,              c3;		SecondLU:	STOPONERR¬ R0, GOTO[CHECKLU]  ,              c3;		CHECKLU:	R1 ¬ R1 +1 ,              c1;			            [] ¬ R1 and R4, ZeroBr  ,              c2;			            BRANCH [CHECKLU2, CHECKLU1] ,   c3;	CHECKLU1:	Noop,        c1;                GOTO[WaitIn1],        c2;	{Not Done}                CHECKLU2:	Noop,        c1;                IOPCtl ¬ 0,        c2;	                GOTO[StartM],        c3;	{Done}SendU:	R1¬0,	c2;    	     	IOPCtl ¬ 2 ,         c3;		{Set mode of IOP port}	        R3¬10,	c1;                R4¬10,	c2;                GOTO[GetU],	c3;    WaitOut:	Xbus ¬ IOPStatus, XLDisp,        c1;	{Is IOPReq true?, Put R0 on Y bus}	BRANCH [WaitOut1, Out, XOdd],   c2;	{XOdd => IOPReq, Put R0 on Y bus}WaitOut1:	GOTO[WaitOut],        c3;		Out:	IOPOData ¬ R0 LRot0,GOTO[GetU],     c3;	{Output value}        	GetU:	     Noop  ,              c1;			        []¬ R1, AltUaddr ,   c2;SecondSU:	    R0¬ STOPONERR, GOTO[CHECKSU]  ,              c3;		CHECKSU:	[] ¬ R1 and R4, ZeroBr ,              c1;			            BRANCH [CHECKSU2, CHECKSU1]  ,              c2;			            	CHECKSU1:	R1 ¬ R1 +1,GOTO[WaitOut],        c3; {Not Done}                                CHECKSU2:	IOPCtl ¬ 0,GOTO[RecieveU],        c3;	{Done}SetTask[5];StartAddress[Task5];Task5: CANCELBR[Task5,0F],     c*;SetTask[4];StartAddress[Task4];Task4: CANCELBR[Task4,0F],     c*;        SetTask[3];StartAddress[Task3];Task3: CANCELBR[Task3,0F],     c*;SetTask[2];StartAddress[Task2];Task2: CANCELBR[Task2,0F],     c*;@


1.1.1.1
log
@first add
@
text
@@
