head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.07;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.07;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ Copyright (C) 1979, 1980  by Xerox Corporation. All rights reserved. } {File name:  CursorTest.mc Description: Microcode to test out Display interface., Author: Pitts PXJ   , Created: November 26, 1979  10:55 PM, Last Edited: PXJ   , September 25, 1980  11:11 AM		R. RXG   , May 15, 1980  7:27 PM}MacroDef[ThenElse, BRANCH[#2, #1]];	Set[PicLenShifted, 0CA]; {PicLength = 328'x = 808'd. PicLenShifted = RShift2 PicLength}{Format of Display Control Block}	Set[IOPageHigh, 1];	Set[IOPage, 40];	Set[DCBLoc, 0EB];	Set[WakeupLoc, 0];	Set[DBitsLoc, 1];	Set[BorderLoc, 2];	Set[cursorXLoc, 3];	Set[cursorYLoc, 4];	Set[cursorMapLoc, 5];RegDef[acR, R, 0];	{Contains picture pattern -- used by Emulator task}RegDef[rA, R, 0];	{Test Use -- used by Emulator task}RegDef[rB, R, 1];	{Test Use -- used by Emulator task}{RegDef[TT, R, 2], RegDef[rhTT, RH, 2];	{Test Use -- used by Emulator task}}RegDef[rC, R, 3];	{Test Use -- used by Emulator task}RegDef[rD, R, 4];	{Used by Emulator}RegDef[Random, R, 5];	{Used by Emulator}RegDef[patternMode, U, 0];	{0=> checkerboard, otherwise chevron}RegDef[cursorMode, U, 1];	{0=> slash in cursor, non-zero=> flower in cursor}RegDef[moveMode, U, 2];	{0=> no movement, non-zero=> random Walk}{Emulator task. Initialize Display Control Register, cursor, and paint pattern}	SetTask[0]; StartAddress[Go];TERROR1:	  ClrIntErr,CANCELBR[$,0F],   c*, at[0];TERROR:	  GOTO[TERROR],   c*;Go:	R0¬1,CANCELBR[$,0F]	,c1,at[0FF0];	moveMode ¬ R0	,c2;	cursorMode ¬ R0	,c3;               patternMode¬R0	,c1;	Noop	,c2;	Noop	,c3;               rC ¬ LShift1 0FF, SE¬1, CANCELBR[$, 0F]	,c1;	rC ¬ LShift1 rC, SE¬1	,c2;	rC ¬ LShift1 rC, SE¬1	,c3;	u7FF ¬ rC	,c1;	rC ¬ LShift1 rC, SE¬1	,c2;	rC ¬ LShift1 rC, SE¬1	,c3;	u1FFF ¬ rC	,c1;	rC ¬ LShift1 rC, SE¬1	,c2;	u3FFF ¬ rC	,c3;	Noop,	c1; {set Mem Control reg}{Don't start display yet}	DCtl¬ 0,	c2; {reset Display}	Noop,	c3; {Clear Disk Control reg}	rD¬ 3,	c1; {808 visible lines}	rD¬ rD LRot8,	c2;	rD¬ rD or 28,	c3;PaintScreen:	TT¬ 0,	c1;	rhTT¬ 0,	c2; {Use Low 64K bank only}	Xbus¬ patternMode, XDisp,	c3;	DISP4[patternDisp, 0C],	c1;patternDisp:	GOTO[doChk],	c2, at[0C, 10, patternDisp];	GOTO[doChv],	c2, at[0D, 10, patternDisp];	GOTO[doStripe],	c2, at[0E, 10, patternDisp];	GOTO[doStripe],	c2, at[0F, 10, patternDisp];{-------------------------------------stripe pattern-------------------------------------}doStripe:	acR¬ 0,	c3; {Clear Display}	Noop,	c1;	Noop,	c2;	rC¬ 0FF'x,	c3;	{100x words per page}strDPY:	MAR¬ [rhTT, TT + 0],	c1;  {Paint the line}	MDR¬ acR,	c2;	TT¬ TT + 1,	c3;	[]¬ TT and rC, ZeroBr,	c1;	acR¬ ~acR, ThenElse[strPage, strDPY1],	c2;strDPY1:	GOTO[strDPY],	c3;strPage:	Noop,	c3;	rD¬ rD-4,  {one page is 4 lines}	c1;	[]¬ rD, NegBr,	c2;	ThenElse[$, strDPY],	c3;	GOTO[moreZap],	c1;{-------------------------------------end stripe pattern-------------------------------------}{-------------------------------------checkerboard pattern-------------------------------------}doChk:	acR¬ 0F'x,	c3; {Clear Display}	rC¬ acR LRot8, {acR¬ acR or (acR LRot8) fails}	c1;	acR¬ acR or rC,	c2;	rC¬ 0FF'x,	c3;	{100x words per page}chkDPY:	MAR¬ [rhTT, TT + 0],	c1;  {Paint the line}	MDR¬ acR,	c2;	TT¬ TT + 1,	c3;	[]¬ TT and rC, ZeroBr,	c1;	ThenElse[chkPage, chkDPY1],	c2;chkDPY1:	GOTO[chkDPY],	c3;chkPage:	Noop,	c3;	rD¬ rD-4,  {one page is 4 lines}	c1;	[]¬ rD, NegBr,	c2;	acR¬ ~acR, ThenElse[endChk, chkDPY],	c3;endChk:	GOTO[moreZap],	c1;{-------------------------------------end checkerboard pattern-------------------------------------}{-------------------------------------chevron pattern-------------------------------------}doChv:	rC¬ 3F'x,	c3;	{40x words per line}	acR¬ 80'x,	c1;	acR¬ acR LRot8,	c2;	Noop,	c3;chvDPY:	MAR¬ [rhTT, TT + 0],	c1;  {Paint the line}	MDR¬ acR,	c2;	TT¬ TT + 1,	c3;	[]¬ TT and rC, ZeroBr,	c1;	ThenElse[chvLine, chvDPY1],	c2;chvDPY1:	GOTO[chvDPY],	c3;chvLine:	Noop,	c3;	Noop,	c1;	rD¬ rD-1, ZeroBr,	c2;	acR¬ acR RRot1, ThenElse[endChv, chvDPY],	c3;endChv:	GOTO[moreZap],	c1;{-------------------------------------end chevron pattern-------------------------------------}moreZap:	Noop,	c2;	Noop,	c3;moreZap1:	MAR¬ [rhTT, TT+0],	c1;	MDR¬ acR xor ~acR,	c2;	Noop,	c3;	Noop,	c1;	TT¬ TT+1, ZeroBr,	c2;	ThenElse[zapDone, moreZap1],	c3;{initialize cursor at center of display}zapDone:	rhTT¬ IOPageHigh,	c1;	TT¬ IOPage,	c2;	TT ¬ TT LRot8,	c3;	TT ¬ TT or DCBLoc	,c1;	uDCBLoc ¬ TT	,c2;	Noop	,c3;	MAR¬ [rhTT, TT+WakeupLoc],	c1;	MDR¬ 0, WriteOK, CANCELBR[$, 2]	c2;	acR¬ 2'x,	c3;	MAR¬ [rhTT, TT+DBitsLoc],	c1;	MDR¬ 0, WriteOK, CANCELBR[$, 2]	c2;	acR¬ acR LRot8,	c3;	MAR¬ [rhTT, TT+cursorXLoc],	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;initX:	acR¬ LShift1 PicLenShifted,	c3;	MAR¬ [rhTT, TT+cursorYLoc],	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;initY:	Noop,	c3;	Noop,	c1;	[]¬ cursorMode, ZeroBr,	c2;	TT ¬ TT+cursorMapLoc, ThenElse[slash, flower],	c3;{-------------------------------------slash in cursor-------------------------------------}slash:	rB¬ 80'x,	c1;	rB¬ rB LRot8,	c2;	rB¬ rB or 1,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR xor ~acR, WriteOK, CANCELBR[$, 2],	c2;slash0:	acR¬ 2,	c3;	rC¬ 0E'x,	c1;	Noop,	c2;	Noop,	c3;slash1:	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR or rB, WriteOK, CANCELBR[$, 2],	c2;slash2:	acR¬ acR LRot1,	c3;	Noop,	c1;	rC¬ rC-1, ZeroBr,	c2;	ThenElse[slash3, slash1],	c3;slash3:	MAR¬ [rhTT, TT+0],	c1;	MDR¬ acR xor ~acR,	c2;slash4:	DCtl ¬ 1 {EnableDisplay}, GOTO[walk],	c3;{-------------------------------------flower in cursor-------------------------------------}flower:	MAR¬  [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ 60'x, WriteOK, CANCELBR[$, 2],	c2;flower0:	acR¬ 1,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 94'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower1:	acR¬ 1,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 0E'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower2:	acR¬ 1,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 1F'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower3:	acR¬ 2,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 1F'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower4:	acR¬ 2,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 0E'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower5:	acR¬ 2,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 4'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower6:	acR¬ 2,	c3;	acR¬ acR LRot8,	c1;	Noop,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower7:	acR¬ 2'x,	c3;	acR¬ acR LRot8,	c1;	Noop,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower8:	acR¬ 2'x,	c3;	acR¬ acR LRot8,	c1;	Noop,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower9:	acR¬ 2'x,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 3'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower10:	acR¬ 0F1'x,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 0F'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower11:	acR¬ 0F9'x,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 1E'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower12:	acR¬ 7D'x,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 38'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower13:	acR¬ 3F'x,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 0F0'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT], TT¬ TT+1,	c1;	MDR¬ acR, WriteOK, CANCELBR[$, 2],	c2;flower14:	acR¬ 3'x,	c3;	acR¬ acR LRot8,	c1;	acR¬ acR or 80'x,	c2;	Noop,	c3;	MAR¬ [rhTT, TT+0],	c1;	MDR¬ acR,	c2;flower15:	DCtl ¬ 1 {EnableDisplay}, GOTO[walk],	c3;walk:	Noop	,c1;	[]¬ moveMode, ZeroBr,	c2;	TT ¬ uDCBLoc, ThenElse[xyWrite, xyMove],	c3;{Random walk according to Random ¬ (805 * Random + 3619) mod 10000}xyMove:	MAR¬ [rhTT, TT+cursorXLoc],	c1;	rA ¬ LShift1 Random, CANCELBR[$,0]	c2;	rC ¬ MD,	c3;	MAR¬ [rhTT, TT+cursorYLoc],	c1;	rA ¬ LShift1 rA, {rA=Random*2­2} CANCELBR[$,0]	c2;	rD ¬ MD,	c3;	rB ¬ Random and 1F,	c1;	rB ¬ rB LRot12,	c2;	rB ¬ RRot1 rB, {rB=Random*2­11}	c3;	Random ¬ Random + rA, {Random=Random+Random*2­2}	c1;	Random ¬ Random + rB, {Random=Random+Random*2­2+Random*2­11},	c2;	rA ¬ 36	c3;	rA ¬ rA LRot8	,c1;	rA ¬ rA or 19 {rA¬3619}	,c2;	Random ¬ Random + rA	,c3;	Xbus ¬ Random LRot4, XDisp	,c1;	DISP4[North, 8]	,c2;North:	GOTO[IncrY]	,c3, at[8,10,North];NE:	rC ¬ rC + 15, GOTO[IncrY]	,c3, at[9,10,North];East:	rC ¬ rC + 15, GOTO[NoAdjust]	,c3, at[0A,10,North];SE:	rC ¬ rC + 15, GOTO[DecrY]	,c3, at[0B,10,North];South:	GOTO[DecrY]	,c3, at[0C,10,North];SW:	rC ¬ rC - 15, GOTO[DecrY]	,c3, at[0D,10,North];West:	rC ¬ rC - 15, GOTO[NoAdjust]	,c3, at[0E,10,North];NW:	rC ¬ rC - 15, GOTO[IncrY]	,c3, at[0F,10,North];NoAdjust:	GOTO[ChkBound]	,c1;IncrY:	rD ¬ rD + 15, GOTO[ChkBound]	,c1;DecrY:	rD ¬ rD - 15, GOTO[ChkBound]	,c1;ChkBound:	rA ¬ uInitPicLength	,c2;	[] ¬ rD - rA, NegBr {Y>=328?}	,c3;	BRANCH[$, YBotOK]	,c1;	rD ¬ 0, GOTO[ChkYTop]	,c2;YBotOK:	Noop	,c2;ChkYTop:	[] ¬ rD, NegBr {Y<0?}	,c3;	rB ¬ u3FF, BRANCH[YTopOK, $]	,c1;	rD ¬ rA - 1 {rD¬327}, GOTO[ChkDone]	,c2;YTopOK:	Noop	,c2;ChkDone:	rC ¬ rC and rB{cursorX and 3FF}, GOTO[xyWrite]	,c3;xyWrite:	MAR¬ [rhTT, TT+cursorXLoc],	c1;	MDR¬ rC, WriteOK, CANCELBR[$, 2],	c2;	Noop,	c3;	MAR¬ [rhTT, TT+cursorYLoc],	c1;	MDR¬ rD, WriteOK, CANCELBR[$, 2],	c2;	rA ¬ 8, GOTO[wait],	c3;wait:	MesaIntBr,	c1;	BRANCH[NoInt, Int],	c2;NoInt:	GOTO[wait],	c3;Int:	ClrIntErr	,c3;	Noop	,c1;	rA ¬ rA - 1, ZeroBr	,c2;	BRANCH[wait, walk]	,c3;SetTask[5];StartAddress[Task5];Task5: CANCELBR[Task5,0F],     c*;        SetTask[3];StartAddress[Task3];Task3: CANCELBR[Task3,0F],     c*;SetTask[2];StartAddress[Task2];Task2: CANCELBR[Task2,0F],     c*;SetTask[4];StartAddress[Task4];Task4: CANCELBR[Task4,0F],     c*;@


1.1.1.1
log
@first add
@
text
@@
