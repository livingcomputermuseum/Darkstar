head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ Copyright (C) 1980  by Xerox Corporation. All rights reserved. }{File name:  <Workstation>mc>Sunlight-O.mc}		SetTask[0]; StartAddress[Go];TERROR1:	  ClrIntErr,CANCELBR[$,0F],   c*, at[0];TERROR:	  GOTO[TERROR],   c*;{1.  LRotn test & bus tests.}{These tests check for stuck at faults on either the X or Y bus; the A bypass or F bus; or the LRotn cycler.  A fault on either the X,Y, F or A bus will be caught by LRot0Bad0 or LRot0Bad1.}{Is LRot0 stuck 0?}Go:	R0 ¬ 0,CANCELBR[$,0F], 	c1;               R0 ¬ ~R0 , 	c2;               R2 ¬ (R0 LRot0),  {R0 had 0FFFF}	c3;	R0 ¬ R2 xor R0, ZeroBr,	c1;{Is LRot0 stuck 1?}	R3 ¬ R0 LRot0, BRANCH[LRot0Bad1, $],{R0 = 0}	c2;	R1 ¬ R3, ZeroBr,	c3;{Is RRot0 stuck 0?}	R3 ¬ (R2 RRot1), BRANCH[LRot0Bad0, $],{R2=FFFF}	c1;	R2 ¬ R2 xor R3, ZeroBr,	c2;{Is RRot0 stuck 1?}	R1 ¬ R2 RRot1, BRANCH[RRot0Bad1, $],{R2=0}	c3;	[] ¬ R1, ZeroBr, {R3 = FFFF}	c1;{Is cycleY ok?}	R0 ¬ R3 LRot1, pCall1, BRANCH[RRot0Bad0, $],	c2;	[] ¬ R0 xor R3, ZeroBr,	c3;	BRANCH[LRot0YBad, $],	c1;	Noop,	c2;{Is LRot4 stuck 0?}LRot0Good1:	R2 ¬ (R0 LRot4),  {R0 had FFFF}	c3;	R0 ¬ R2 xor R0, ZeroBr,	c1;	R1 ¬ 0, BRANCH[LRot4Bad0, LRot4Good0],	c2;{Is LRot4 stuck 1?}LRot4Good0:	R3 ¬ R1 LRot4,	c3;	R1 ¬ R3 xor R1, ZeroBr,	c1;	R0 ¬ ~R0 xor R0, BRANCH[LRot4Bad1, LRot4Good1],	c2;{Is LRot8 stuck 0?}LRot4Good1:	R2 ¬ (R0 LRot8),  {R0 had FFFF}	c3;	R0 ¬ R2 xor R0, ZeroBr,	c1;	R1 ¬ 0, BRANCH[LRot8Bad0, LRot8Good0],	c2;{Is LRot8 stuck 1?}LRot8Good0:	R3 ¬ R1 LRot8,	c3;	R1 ¬ R3 xor R1, ZeroBr,	c1;	R0 ¬ ~R0 xor R0, BRANCH[LRot8Bad1, LRot8Good1],	c2;{Is LRot12 stuck 0?}LRot8Good1:	R2 ¬ (R0 LRot12),  {R0 had FFFF}	c3;	R0 ¬ R2 xor R0, ZeroBr,	c1;	R1 ¬ 0, BRANCH[LRot12Bad0, LRot12Gd0],	c2;{Is LRot12 stuck 1?}LRot12Gd0:	R3 ¬ R1 LRot12,	c3;	R1 ¬ R3 xor R1, ZeroBr,	c1;	TestCnt ¬ TestCnt + 1, {TestCnt=2} BRANCH[LRot12Bad1, LRot12Gd1],	c2;{2a.  constant on X bus.}{Check whether Nibble and byte can place all their bits onto the X bus.}{Check that 0 thru F can be placed onto X bus.  This primarily tests the S241 which places a Nibble onto Xbus.  Instruction at NibTable actually tests internal zero.}LRot12Gd1:	R0 ¬ 0, YDisp,	c3;NibGood:	R1 ¬ R0 + 1, NibCarryBr, DISP4[NibTable],	c1;NibTable:	R2 ¬ 0 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[0, 10, NibTable];	R2 ¬ 1 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[1, 10, NibTable];	R2 ¬ 2 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[2, 10, NibTable];	R2 ¬ 3 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[3, 10, NibTable];	R2 ¬ 4 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[4, 10, NibTable];	R2 ¬ 5 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[5, 10, NibTable];	R2 ¬ 6 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[6, 10, NibTable];	R2 ¬ 7 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[7, 10, NibTable];	R2 ¬ 8 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[8, 10, NibTable];	R2 ¬ 9 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[9, 10, NibTable];	R2 ¬ 0A xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[0A, 10, NibTable];	R2 ¬ 0B xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[0B, 10, NibTable];	R2 ¬ 0C xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[0C, 10, NibTable];	R2 ¬ 0D xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[0D, 10, NibTable];	R2 ¬ 0E xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c2, at[0E, 10, NibTable];	R2 ¬ 0F xor R0, ZeroBr, BRANCH[NibTestFail, ByteTest], c2, at[0F, 10, NibTable];NibLoop:	R0 ¬ R1, YDisp, BRANCH[NibBad, NibGood],	c3;NibFail:	CANCELBR[NibBug],	c3;NibTestFail:	CANCELBR[NibBug],	c3;NibBug:	GOTO[NibBad],	c1;{Check that 0 thru F0 (incr. by 10) can be placed onto X bus.  This primarily tests the S257 which places bits 0-3 of constant onto X bus.}ByteTest:	R3 ¬ 0, BRANCH[Nib0FBad,ByteCont],	c3;ByteCont:	R3 ¬ R3 + 1, YDisp,	c1;	R2 ¬ R3 LRot4, DISP4[ByteTable],	c2;ByteTable:	R2 ¬ 0, GOTO[ByteLast],     c3, at[0, 10, ByteTable];	R0 ¬ 10, GOTO[ByteLoop],      c3, at[1, 10, ByteTable];	R0 ¬ 20, GOTO[ByteLoop],      c3, at[2, 10, ByteTable];	R0 ¬ 30, GOTO[ByteLoop],      c3, at[3, 10, ByteTable];	R0 ¬ 40, GOTO[ByteLoop],      c3, at[4, 10, ByteTable];	R0 ¬ 50, GOTO[ByteLoop],      c3, at[5, 10, ByteTable];	R0 ¬ 60, GOTO[ByteLoop],      c3, at[6, 10, ByteTable];	R0 ¬ 70, GOTO[ByteLoop],      c3, at[7, 10, ByteTable];	R0 ¬ 80, GOTO[ByteLoop],      c3, at[8, 10, ByteTable];	R0 ¬ 90, GOTO[ByteLoop],      c3, at[9, 10, ByteTable];	R0 ¬ 0A0, GOTO[ByteLoop],     c3, at[0A, 10, ByteTable];	R0 ¬ 0B0, GOTO[ByteLoop],     c3, at[0B, 10, ByteTable];	R0 ¬ 0C0, GOTO[ByteLoop],     c3, at[0C, 10, ByteTable];	R0 ¬ 0D0, GOTO[ByteLoop],     c3, at[0D, 10, ByteTable];	R0 ¬ 0E0, GOTO[ByteLoop],     c3, at[0E, 10, ByteTable];	R0 ¬ 0F0, GOTO[ByteLoop],     c3, at[0F, 10, ByteTable];ByteLoop:	R2 ¬ R0 xor R2, ZeroBr,	c1;	BRANCH[ByteBad, ByteGood],	c2;ByteGood: GOTO[ByteCont],	c3;ByteLast:	R2 ¬ 0 xor R2, ZeroBr,	c1;	BRANCH[ByteBug, ByteDone],	c2;ByteDone: TestCnt ¬ TestCnt + 1, { TestCnt=3 }	c3;	R2 ¬ 0,	c1;	R0 ¬ 0, GOTO[LogicTest],	c2;{2.b	Logic tests.  Check that logical operations work with no stuck results.}{or}{Can we do "0 or 0"?}LogicTest:	R1 ¬ ~R1 xor R1, {R0 is set to Zero in ByteTest}	c3;	R2 ¬ R0 or R2, ZeroBr, {R2 is Zero from ByteTest}	c1;	R3 ¬ ~R3 xor R3, BRANCH[S0or0Bad, S0or0Good],	c2;{Can we do "0 or 1"?}S0or0Good:	R2 ¬ R1 or R2,	c3;	R3 ¬ R3 xor R2, ZeroBr,	c1;	R2 ¬ ~R2 xor R2, BRANCH[S0or1Bad, S0or1Good],	c2;{Can we do "1 or 0"?}S0or1Good:	R2 ¬ R2 or R0,	c3;	R1 ¬ R1 xor R2, ZeroBr,	c1;	R0 ¬ ~R0 xor R0, BRANCH[S1or0Bad, S1or0Good],	c2;{Can we do "1 or 1"?}S1or0Good:	R2 ¬ R2 or R3,	c3;	R0 ¬ R0 xor R2, ZeroBr,	c1;	R3 ¬ ~R3 xor R3, BRANCH[S1or1Bad, S1or1Good],	c2;{and}{Can we do "0 and 0"?}S1or1Good:	R0 ¬ 0,	c3;	R0 ¬ R0 and R0, ZeroBr,	c1;	R1 ¬ ~R1 xor R1, BRANCH[S0and0Bad, S0and0Good],	c2;{Can we do "0 and 1"?}S0and0Good:	Noop,	c3;	R1 ¬ R0 and R1, ZeroBr,	c1;	R2 ¬ ~R2 xor R2, BRANCH[S0and1Bad, S0and1Good],	c2;{Can we do "1 and 0"?}S0and1Good:	Noop,	c3;	R0 ¬ R2 and R0, ZeroBr,	c1;	R1 ¬ ~R1 xor R1, BRANCH[S1and0Bad, S1and0Good],	c2;{Can we do "1 and 1"?}S1and0Good:	R3 ¬ R2 and R3,	c3;	R1 ¬ R1 xor R3, ZeroBr,	c1;	R2 ¬ 0,BRANCH[S1and1Bad, S1and1Good],	c2;{~R and S}{Can we do "~0 and 0"?}S1and1Good:	R3 ¬ ~R3 xor R3,	c3;	R2 ¬ ~R2 and R2, ZeroBr, { R2 had 0 }	c1;	R1 ¬ ~R1 xor R1, BRANCH[N0and0Bad, N0and0Good],	c2;{Can we do "~0 and 1"?}N0and0Good:	R1 ¬ ~R2 and R1,	c3;	R3 ¬ R3 xor R1, ZeroBr, { R3 had FFFF }	c1;	R2 ¬ ~R2 xor R2, BRANCH[N0and1Bad, N0and1Good],	c2;{Can we do "~1 and 0"?}N0and1Good:	R0 ¬ 0,	c3;	R0 ¬ ~R1 and R0, ZeroBr,	c1;	R3 ¬ ~R3 xor R3, BRANCH[N1and0Bad, N1and0Good],	c2;{Can we do "~1 and 1"?}N1and0Good:	R0 ¬ 0,	c3;	R3 ¬ ~R2 and R3, ZeroBr,	c1;	R3 ¬ ~R3 xor R3, BRANCH[N1and1Bad, N1and1Good],	c2;{xor}{Can we do "0 xor 0"?}N1and1Good:  Noop,	c3;	R0 ¬ R0 xor R0, ZeroBr, {R0 had 0 }	c1;	R1 ¬ ~R1 xor R1, BRANCH[S0xor0Bad, S0xor0Good],	c2;{Can we do "0 xor 1"?}S0xor0Good:	R1 ¬ R0 xor R1,	c3;	R3 ¬ R3 xor R1, ZeroBr,	c1;	R2 ¬ ~R2 xor R2, BRANCH[S0xor1Bad, S0xor1Good],	c2;{Can we do "1 xor 0"?}S0xor1Good:	R0 ¬ R2 xor R0,	c3;	R0 ¬ R0 xor R2, ZeroBr,	c1;	R3 ¬ ~R3 xor R3, BRANCH[S1xor0Bad, S1xor0Good],	c2;{Can we do "1 xor 1"?}S1xor0Good:	R2 ¬ ~R2 xor R2,	c3;	R2 ¬ R2 xor R3, ZeroBr,	c1;	R1 ¬ ~R1 xor R1, BRANCH[S1xor1Bad, S1xor1Good],	c2;{xnor}{Can we do "~0 xor 0"?}S1xor1Good:	R0 ¬ ~R0 xor R0,	c3;	R1 ¬ R1 xor R0, ZeroBr,	c1;	R2 ¬ ~R2 xor R2, BRANCH[N0xor0Bad, N0xor0Good],	c2;{Can we do "~0 xor 1"?}N0xor0Good:	R0 ¬ 0,	c3;	R2 ¬ ~R0 xor R2, ZeroBr,	c1;	R1 ¬ ~R1 xor R1, BRANCH[N0xor1Bad, N0xor1Good],	c2;{Can we do "~1 xor 0"?}N0xor1Good:	R2 ¬ ~R0,	c3;	R0 ¬ ~R1 xor R0, ZeroBr,	c1;	BRANCH[N1xor0Bad, N1xor0Good],	c2;{Can we do "~1 xor 1"?}N1xor0Good:	R2 ¬ ~R2 xor R2,	c3;	R2 ¬ R1 xor R2, ZeroBr,	c1;	TestCnt ¬ TestCnt + 1 {TestCnt=4}, BRANCH[N1xor1Bad, N1xor1Good],	c2;{2.c	Shift/cycle tests.}{The single bit shifting hardware is tested in two steps: (1) internal/intra 2901 shifting and (2) external shift ends.  (1) is tested by right/left shifting a solitary 1/0 through an R resister (and Q).  (2) is tested by trying 0/1 ShiftEnds for each of the 4 types of long/short/shifting/cyclying.  A third test compares the results of LRotn with 4n single bit shifts.}{(1):  Shift a solitary 1 right throught R0, and then back left again from where it started.}N1xor1Good:	R0 ¬ RShift1 0, SE¬1,  {R0¬8000'x}	c3;	R1 ¬ 15'd,	c1;ShiftR1Loop:	R0 ¬ RShift1 R0, SE¬0,	c2;	R1 ¬ R1 - 1, ZeroBr,	c3;	BRANCH[ShiftR1Loop, ShiftR1Done],	c1;{R0 should be 1.}ShiftR1Done:	R2 ¬ R0 xor 1, ZeroBr,	c2;	BRANCH[ShiftR1Bad, ShiftR1Good],	c3;{Now start shifting Solitary 1 back to the left.}ShiftR1Good:	R1 ¬ 15'd,	c1;ShiftL1Loop:	R0 ¬ LShift1 R0, SE¬0,	c2;	R1 ¬ R1 - 1, ZeroBr,	c3;	BRANCH[ShiftL1Loop, ShiftL1Done],	c1;{R0 should be 8000'x now.}ShiftL1Done:	R2 ¬ RShift1 0, SE¬1,	c2;	R2 ¬ R0 xor R2, ZeroBr,	c3;	BRANCH[ShiftL1Bad, ShiftL1Good],	c1;{Now shift a solitary 0 right/left through R0.}ShiftL1Good:	R0 ¬ RShift1 (~R0 xor R0), SE¬0,  {R0¬7FFF'x}	c2;	R1 ¬ 15'd,	c3;ShiftR0Loop:	R0 ¬ RShift1 R0, SE¬1,	c1;	R1 ¬ R1 - 1, ZeroBr,	c2;	BRANCH[ShiftR0Loop, ShiftR0Done],	c3;{R0 should be FFFE'x.}ShiftR0Done:	R2 ¬ ~1 xor R0, ZeroBr,	c1;	BRANCH[ShiftR0Bad, ShiftR0Good],	c2;{Now start shifting Solitary 0 back to the left.}ShiftR0Good:	R1 ¬ 15'd,	c3;ShiftL0Loop:	R0 ¬ LShift1 R0, SE¬1,	c1;	R1 ¬ R1 - 1, ZeroBr,	c2;	rhR2 ¬ 0FF, BRANCH[ShiftL0Loop, ShiftL0Done],	c3;{R0 should be 7FFF'x now.}ShiftL0Done:	R2 ¬ RShift1 (~R2 xor R2), SE¬0,	c1;	R2 ¬ R0 xor R2, ZeroBr,	c2;	Q ¬ 0, BRANCH[ShiftL0Bad, ShiftL0Good],	c3;{Double Shifts, cycleX}ShiftL0Good:	R2 ¬ RShift1 (~R2 xor R2), SE ¬ 0, {R2 has 7FFF}	c1;	R3 ¬ ~R2, {R3 has 8000}	c2;	R4 ¬ -2, {R4 has FFFE}	c3;{DRShift1 SE=0,R=FFFE,Q=0}	R5 ¬ DRShift1 R4, SE ¬ 0, {Q has 0}	c1;	[] ¬ R5 xor R2, ZeroBr,	c2;	[] ¬ R3 xor Q, ZeroBr, BRANCH[DRSftBad0, $],	c3;	R5 ¬ 1, BRANCH[DRSftBadQ1, $],	c1;	Q ¬ ~R2 xor R2,	c2;{DRShift1 SE=1,R=1,Q=FFFF}	R5 ¬ DRShift1 R5, SE ¬ 1,	c3;	[] ¬ R5 xor R3, ZeroBr,	c1;	R5 ¬ R2 xor Q, ZeroBr, BRANCH[DRSftBad1, $],	c2;	Q ¬ R3, BRANCH[DRSftBadQ0, $],	c3;{DLShift1 R=0,Q=8000,SE=1}	R5 ¬ DLShift1 R5, SE ¬ 1,	c1;	[] ¬ R5 xor 1, ZeroBr,	c2;	[] ¬ Q, ZeroBr, BRANCH[DLSftBad0, $],	c3;	R5 ¬ ~R5 xor R5, BRANCH[DLSftBadQ0, $],	c1;	Q ¬ R2,	c2;{DLShift1 R=FFFF,Q=7FFF,SE=0}	R5 ¬ DLShift1 R5, SE ¬ 0,	c3;	R5 ¬ R5 xor R4, ZeroBr,	c1;	[] ¬ ~Q, ZeroBr, BRANCH[DLSftBad1, $],	c2;	BRANCH[DLSftBadQ1, $],	c3;{DALShift1 R=0,Q=FFFF,SE=1}	R5 ¬ DALShift1 R5, SE ¬ 1,	c1;	[] ¬ R4 xor Q, ZeroBr,	c2;	Q ¬ R5 xor 1, ZeroBr, BRANCH[DALSftBadQ0, $],	c3;	R5 ¬ ~R5 xor R5, BRANCH[DALSftBad1, $],	c1;{DALShift1 R=FFFF,Q=0,SE=0}	R5 ¬ DALShift1 R5, SE ¬ 0,	c2;	[] ¬ R5 xor R4, ZeroBr,	c3;	R5 ¬ Q xor 1, ZeroBr, BRANCH[DALSftBad0, $],	c1;{DARShift1 SE=1,R=0,Q=xx}	R5 ¬ DARShift1 (R5 - R5), BRANCH[DALSftBadQ1, $],	c2;	[] ¬ R5 xor R3, ZeroBr,	c3;	R5 ¬ ~R5 xor R5, BRANCH[DARSftBad1, $],	c1;{DARShift1 SE=0,R=FFFF,Q=xx}	R5 ¬ DARShift1 (R5 + 0),	c2;	R5 ¬ R5 xor R2, ZeroBr,	c3;{cycleY}	Q ¬ 0, BRANCH[DARSftBad0, $],	c1;	R5 ¬ DRShift1 R4, SE ¬ 0, pCall1 {force cycleY},	c2;	[] ¬ R5 xor R2, ZeroBr, GOTO[LRotnTest],	c3;{2.d	LRotn/cycle tests.}{This test places a 1 or 0 in every bit position and then LRotn's (n=0,4,8,12) it and compares the result with the same value shifted via LRot1's.R0 = 0, 4, 8, 0C for LRot0, LRot4, LRot8, LRot12	R1 = 1, 2, 4, ..., 8000 and then FFFE, FFFD, ...., 7FFFR2 = LRotn'd value of R0R3 = LRot1'd value of R0.  {R2 should always equal R3}R4 = temp}LRotnTest:	R1 ¬ 1  {start with ..001}, BRANCH[DRZSftBad0, $]	,c1;NextPh:	R0 ¬ 0	,c2;NextRot:	Noop	,c3;	R4 ¬ R0, YDisp	,c1;	R3 ¬ R1, DISP4[LRotn]	,c2;LRotn:	R2 ¬ R1 LRot0, GOTO[L1Rot]	,c3, at[0,10,LRotn];	R2 ¬ R1 LRot4, GOTO[L1Rot]	,c3, at[4,10,LRotn];	R2 ¬ R1 LRot8, GOTO[L1Rot]	,c3, at[8,10,LRotn];	R2 ¬ R1 LRot12, GOTO[L1Rot]	,c3, at[0C,10,LRotn];L1Rot:	R4 ¬ R4 - 1, NegBr	,c1;	BRANCH[$, LRotComp]	,c2;	R3 ¬ R3 LRot1, GOTO[L1Rot]	,c3;LRotComp:	Q ¬ R2 {LRotn} xor R3 {LRot1}, NZeroBr	,c3;	R0 ¬ R0 + 4, NibCarryBr, BRANCH[$, BadLRot]	,c1;	R0 ¬ R0 and 0F, BRANCH[NextRot, $]	,c2;	R1 ¬ R1 LRot1	,c3; 	R4 ¬ R1 and 7	,c1;	[] ¬ R4 xor 1, NZeroBr  {have we returned to start:  ..001 or ..110?}	,c2;	[] ¬ R4 xor 6, NZeroBr, BRANCH[$, LRotP2]	,c3;	R1 ¬ ~R1, CANCELBR[NextPh]	,c1;LRotP2:	BRANCH[$, Ph2Cont]	,c1;	Noop	,c2; 	GOTO[ArithTest]	,c3;Ph2Cont:	GOTO[NextRot]	,c2; {2.e	Arithmetic, intra-carry tests, Cin¬pc16}{Test sum of 1010+1100 in each nibble of ALU and look for carry into next stage.  Cin=0}ArithTest:	R0 ¬ 0A	,c1;	R1 ¬ 0C	,c2;	Q ¬ R0 + R1 {Q = 0016}	,c3;	R2 ¬ 16	,c1;	[] ¬ Q xor R2, ZeroBr	,c2;	BRANCH[Sum12Bad, Sum12Good]	,c3;Sum12Good:	R0 ¬ R0 LRot4 {R0 = 00A0}	,c1;	R1 ¬ R1 LRot4 {R1 = 00C0}	,c2;	Q ¬ R0 + R1 {Q = 0160}	,c3;	R2 ¬ R2 LRot4	,c1;	[] ¬ Q xor R2, ZeroBr	,c2;	BRANCH[Sum8Bad, Sum8Good]	,c3;Sum8Good:	R0 ¬ R0 LRot4 {R0 = 0A00}	,c1;	R1 ¬ R1 LRot4 {R1 = 0C00}	,c2;	Q ¬ R0 + R1 {Q = 1600}	,c3;	R2 ¬ R2 LRot4	,c1;	[] ¬ Q xor R2, ZeroBr	,c2;	R2 ¬ 6, BRANCH[Sum4Bad, Sum4Good]	,c3;Sum4Good:	R0 ¬ R0 LRot4 {R0 = A000}	,c1;	R1 ¬ R1 LRot4 {R1 = C000}	,c2;	Q ¬ R0 + R1, CarryBr {Q = 6000}	,c3;	R2 ¬ R2 LRot12, BRANCH[Sum0CyBd, Sum0CyGd]	,c1;Sum0CyGd:	[] ¬ Q xor R2, ZeroBr	,c2;	BRANCH[Sum0Bad, Sum0Good]	,c3;{Test subtraction of 0011 - 1001 in each nibble of ALU and look for carry into next stage.  Cin=1}Sum0Good:	R0 ¬ 3	,c1;	R1 ¬ 9	,c2;	Q ¬ R0 - R1 {Q ¬ -6}	,c3;	Noop	,c1;	[] ¬ Q xor ~5, ZeroBr	,c2;	BRANCH[Sub12Bad, Sub12Good]	,c3;Sub12Good:	R0 ¬ R0 LRot4 {R0 = 0030}	,c1;	R1 ¬ R1 LRot4 {R1=0090}	,c2;	Q ¬ R0 - R1 {Q ¬ FFA0}	,c3;	R2 ¬ ~5F	,c1;	[] ¬ Q xor R2, ZeroBr	,c2;	R2 ¬ 0FA, BRANCH[Sub8Bad, Sub8Good]	,c3;Sub8Good:	R0 ¬ R0 LRot4 {R0 = 0300}	,c1;	R1 ¬ R1 LRot4 {R1=0900}	,c2;	Q ¬ R0 - R1 {Q ¬ FA00}	,c3;	R2 ¬ R2 LRot8 	,c1;	[] ¬ Q xor R2, ZeroBr	,c2;	R2 ¬ 0A, BRANCH[Sub4Bad, Sub4Good]	,c3;Sub4Good:	R0 ¬ R0 LRot4 {R0 = 3000}	,c1;	R1 ¬ R1 LRot4 {R1=9000}	,c2;	Q ¬ R0 - R1 {Q ¬ A000}	,c3;	R2 ¬ R2 LRot12 	,c1;	R3 ¬ Q xor R2, ZeroBr	,c2;	BRANCH[Sub0Bad, Sub0Good]	,c3;{Test complete carry propagation first with Cin=1, then Cin=0.}Sub0Good:	R1 ¬ R3 - 1 {R1¬FFFF, Cin=0} {R3=0 from above} 	,c1;	R2 ¬ R1 + 1 {R2¬0, Cin=1}, ZeroBr	,c2;	BRANCH[ArithBad, ArithGood]	,c3;{Try Cin=pc16, XC2npcDisp.  First set pc16=1.}ArithGood:	XC2npcDisp	,c1;	R0 ¬ 0, BRANCH[NoFlip, Flip, 0E]	,c2;NoFlip:	GOTO[TestCinpc16]	,c3;Flip:	Cin ¬ pc16, GOTO[TestCinpc16]	,c3;TestCinpc16:	R1 ¬ R0 + PC16 {pc16=1}, Xbus¬rhR1 {force fXCin¬pc16}	,c1;	R2 ¬ R1 xor 1, ZeroBr	,c2;	BRANCH[PC16OneBad, PC16OneGd]	,c3;PC16OneGd:	R2 ¬ R0 + PC16 {pc16=0}, ZeroBr, pCall0 {force fZCin¬pc16}	,c1;	TestCnt ¬ TestCnt + 1 {TestCnt=5}, BRANCH[PC16ZBad, PC16ZGd]	,c2;PC16ZGd:	GOTO[CheckStkP]	,c3;{2.f	stackP tests.}CheckStkP:	stackP ¬ R1 ¬ 0F,	c1;	R2 ¬ ErrnIBnStkp and R1, ZeroBr,	c2;	stackP ¬ R2, BRANCH[StckP1Bad, $],	c3;{Try all versions of push & pop}	[] ¬ ~ErrnIBnStkp and R1, ZeroBr, {stkP=0}	c1;	push {fXpush}, Xbus ¬ 5, XRefBr, BRANCH[Stack0Bad, $],	c2;	push {fYpush}, rhR1 ¬ R1 LRot0, CANCELBR[$],	c3;	push {fZpush}, pCall1, MesaIntBr, {stkP = 3}	c1;	R3 ¬ ~ErrnIBnStkp and R1, CANCELBR[$]	c2;	[] ¬ R3 xor 3, ZeroBr,	c3;	BRANCH[StackPsBad, $],	c1;	fXpop,	c2;	fZpop,	c3;	push, pop,	c1;	R3 ¬ ~ErrnIBnStkp and R1,	c2;	[] ¬ R3 xor 1, ZeroBr,	c3;	TestCnt ¬ TestCnt + 1 {TestCnt=6}, BRANCH[StackPoBad, MAReffect],	c1;{2.g	MAR¬" effects  (See memory test for MDR¬ cancelled.  See ibTest for IBDisp canceled.}{Check for branch in INIA.10. High half function "0 or B".}MAReffect:	R0 ¬ ~R0 xor R0 {R0¬0FFFF}	,c2;	rhR1 ¬ 0, R1 ¬ 0	,c3;{Before MAR: R0=FFFF, R1=0.  After MAR: R1=0}	MAR ¬ R1 ¬ [rhR1, R0+1]	,c1;	BRANCH[MarPgCr1Bd, MarPgCr1Gd, 1]	,c2;MarPgCr1Gd:	Noop 	,c3;	Noop	,c1;	[] ¬ R1, ZeroBr  {no carry into high half?}	,c2;	R0 ¬ 0, BRANCH[MarHigh0Bd, MarHigh0Gd]	,c3;{Before MAR: R0=0, R1=0.  After MAR: R1=FF}MarHigh0Gd:	MAR ¬ R1 ¬ [rhR1, R0-1]	,c1;	BRANCH[MarPgCr0Bd, MarPgCr0Gd, 1]	,c2;MarPgCr0Gd:	Noop 	,c3;      R2 ¬ 0FF	,c1;      [] ¬ R1 xor R2, ZeroBr  {no carry into high half?}	,c2;      TestCnt ¬ TestCnt + 1 {TestCnt=7}, BRANCH[MarHigh1Bd, NOERROR1]	,c3;LRot0Bad1:	RErr ¬ 26, GOTO[LRot0Bad1],	c*;LRot0Bad0:	RErr ¬ 27, GOTO[LRot0Bad0],	c*;RRot0Bad1:	RErr ¬ 28, GOTO[RRot0Bad1],	c*;RRot0Bad0:	RErr ¬ 29, GOTO[RRot0Bad0],	c*;LRot0YBad:	RErr ¬ 2A, GOTO[LRot0YBad],	c*;LRot4Bad0:	RErr ¬ 2B, GOTO[LRot4Bad0],	c*;LRot4Bad1:	RErr ¬ 2C, GOTO[LRot4Bad1],	c*;LRot8Bad0:	RErr ¬ 2D, GOTO[LRot8Bad0],	c*;LRot8Bad1:	RErr ¬ 2E, GOTO[LRot8Bad1],	c*;LRot12Bad0:	RErr ¬ 2F, GOTO[LRot12Bad0],	c*;LRot12Bad1:	RErr ¬ 30, GOTO[LRot12Bad1],	c*;{R0 contains the intented value, x}NibBad:	RErr ¬ 31, CANCELBR[NibBad1], 	c*;NibBad1:	RErr ¬ 31, GOTO[NibBad1], 	c*;ByteBad:	RErr ¬ 32, CANCELBR[ByteBad1], 	c*;ByteBad1:	RErr ¬ 32, GOTO[ByteBad1], 	c*;ByteBug:	RErr ¬ 33, GOTO[ByteBug],	c*;S0or0Bad:	RErr ¬ 34, GOTO[S0or0Bad],	c*;S0or1Bad:	RErr ¬ 35, GOTO[S0or1Bad],	c*;S1or0Bad:	RErr ¬ 36, GOTO[S1or0Bad],	c*;S1or1Bad:	RErr ¬ 37, GOTO[S1or1Bad],	c*;S0and0Bad:	RErr ¬ 38, GOTO[S0and0Bad],	c*;S0and1Bad:	RErr ¬ 39, GOTO[S0and1Bad],	c*;S1and0Bad:	RErr ¬ 3A, GOTO[S1and0Bad],	c*;S1and1Bad:	RErr ¬ 3B, GOTO[S1and1Bad],	c*;N0and0Bad:	RErr ¬ 3C, GOTO[N0and0Bad],	c*;N0and1Bad:	RErr ¬ 3D, GOTO[N0and1Bad],	c*;N1and0Bad:	RErr ¬ 3E, GOTO[N1and0Bad],	c*;N1and1Bad:	RErr ¬ 3F, GOTO[N1and1Bad],	c*;S0xor0Bad:	RErr ¬ 40, GOTO[S0xor0Bad],	c*;S0xor1Bad:	RErr ¬ 41, GOTO[S0xor1Bad],	c*;S1xor0Bad:	RErr ¬ 42, GOTO[S1xor0Bad],	c*;S1xor1Bad:	RErr ¬ 43, GOTO[S1xor1Bad],	c*;N0xor0Bad:	RErr ¬ 44, GOTO[N0xor0Bad],	c*;N0xor1Bad:	RErr ¬ 45, GOTO[N0xor1Bad],	c*;N1xor0Bad:	RErr ¬ 46, GOTO[N1xor0Bad],	c*;N1xor1Bad:	RErr ¬ 47, GOTO[N1xor1Bad],	c*;Sum12Bad:	RErr ¬ 48, GOTO[Sum12Bad]	,c*;Sum8Bad:	RErr ¬ 49, GOTO[Sum8Bad]	,c*;Sum4Bad:	RErr ¬ 4A, GOTO[Sum4Bad]	,c*;Sum0Bad:	RErr ¬ 4B, GOTO[Sum0Bad]	,c*;Sum0CyBd:	RErr ¬ 4C, GOTO[Sum0CyBd]	,c*;Sub12Bad:	RErr ¬ 4D, GOTO[Sub8Bad]	,c*;Sub8Bad:	RErr ¬ 4E, GOTO[Sub8Bad]	,c*;Sub4Bad:	RErr ¬ 4F, GOTO[Sub4Bad]	,c*;Sub0Bad:	RErr ¬ 50, GOTO[Sub0Bad]	,c*;ArithBad:	RErr ¬ 51, GOTO[ArithBad]	,c*;PC16OneBad:	RErr ¬ 52, GOTO[PC16OneBad]	,c*;PC16ZBad:	RErr ¬ 53, GOTO[PC16ZBad]	,c*;MarPgCr1Bd:	RErr ¬ 54, GOTO[MarPgCr1Bd]	,c*;MarHigh0Bd:	RErr ¬ 55, GOTO[MarHigh0Bd]	,c*;MarPgCr0Bd:	RErr ¬ 56, GOTO[MarPgCr0Bd]	,c*;MarHigh1Bd:	RErr ¬ 57, GOTO[MarHigh1Bd]	,c*;ShiftR1Bad:	RErr ¬ 58, GOTO[ShiftR1Bad],	c*;ShiftL1Bad:	RErr ¬ 59, GOTO[ShiftL1Bad],	c*;ShiftR0Bad:	RErr ¬ 5A, GOTO[ShiftR0Bad],	c*;ShiftL0Bad:	RErr ¬ 5B, GOTO[ShiftL0Bad],	c*;StckP1Bad:	RErr ¬ 5C, CANCELBR[StckP1Bad1],	c*;Stack0Bad:	RErr ¬ 5D, CANCELBR[Stack0Bad1],	c*;StackPsBad:	RErr ¬ 5E, CANCELBR[StackPsBad1],	c*;StackPoBad:	RErr ¬ 5F, CANCELBR[StackPoBad1],	c*;DRSftBad0:	RErr ¬ 60, CANCELBR[DRSftBad01],	c*;DRSftBadQ1: RErr ¬ 61, CANCELBR[DRSftBadQ11],	c*;DRSftBad1:	RErr ¬ 62, CANCELBR[DRSftBad11],	c*;DRSftBadQ0: RErr ¬ 63, CANCELBR[DRSftBadQ01],	c*;DLSftBad0:	RErr ¬ 64, CANCELBR[DLSftBad01],	c*;DLSftBadQ1: RErr ¬ 65, CANCELBR[DLSftBadQ11],	c*;DLSftBad1:	RErr ¬ 66, CANCELBR[DLSftBad11],	c*;DLSftBadQ0: RErr ¬ 67, CANCELBR[DLSftBadQ01],	c*;DALSftBadQ0: RErr ¬ 68, CANCELBR[DALSftBadQ01],	c*;DALSftBad1: RErr ¬ 69, CANCELBR[DALSftBad11],	c*;DALSftBad0: RErr ¬ 70, CANCELBR[DALSftBad01],	c*;DALSftBadQ1: RErr ¬ 71, CANCELBR[DALSftBadQ11],	c*;DARSftBad0:	RErr ¬ 72, GOTO[DARSftBad01],	c*;DARSftBad1: RErr ¬ 73, GOTO[DARSftBad11],	c*;DRZSftBad0:	RErr ¬ 74, CANCELBR[DRZSftBad01],	c*;BadLRot:	RErr ¬ 0AF, CANCELBR[BadLRot1]	,c*;StckP1Bad1:	RErr ¬ 5C, GOTO[StckP1Bad1],	c*;Stack0Bad1:	RErr ¬ 5D, GOTO[Stack0Bad1],	c*;StackPsBad1:	RErr ¬ 5E, GOTO[StackPsBad1],	c*;StackPoBad1:	RErr ¬ 5F, GOTO[StackPoBad1],	c*;DRSftBad01:	RErr ¬ 60, GOTO[DRSftBad01],	c*;DRSftBadQ11: RErr ¬ 61, GOTO[DRSftBadQ11],	c*;DRSftBad11:	RErr ¬ 62, GOTO[DRSftBad11],	c*;DRSftBadQ01: RErr ¬ 63, GOTO[DRSftBadQ01],	c*;DLSftBad01:	RErr ¬ 64, GOTO[DLSftBad01],	c*;DLSftBadQ11: RErr ¬ 65, GOTO[DLSftBadQ11],	c*;DLSftBad11:	RErr ¬ 66, GOTO[DLSftBad11],	c*;DLSftBadQ01: RErr ¬ 67, GOTO[DLSftBadQ01],	c*;DALSftBadQ01: RErr ¬ 68, GOTO[DALSftBadQ01],	c*;DALSftBad11: RErr ¬ 69, GOTO[DALSftBad11],	c*;DALSftBad01: RErr ¬ 70, GOTO[DALSftBad01],	c*;DALSftBadQ11: RErr ¬ 71, GOTO[DALSftBadQ11],	c*;DARSftBad01:	RErr ¬ 72, GOTO[DARSftBad01],	c*;DARSftBad11: RErr ¬ 73, GOTO[DARSftBad11],	c*;DRZSftBad01:	RErr ¬ 74, GOTO[DRZSftBad01],	c*;BadLRot1:	RErr ¬ 0AF, GOTO[BadLRot1]	,c*;Nib0FBad:	RErr ¬ 0AF, GOTO[Nib0FBad]	,c*;NOERROR1:	GOTO[NOERROR],	                           	c*;NOERROR:	GOTO[NOERROR],	                           	c*, at[0FFF];@


1.1.1.1
log
@first add
@
text
@@
