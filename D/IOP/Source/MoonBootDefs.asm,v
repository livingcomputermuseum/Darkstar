head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.06;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.06;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@; Copyright (C) 1980, 1981, 1982  by Xerox Corporation. All rights reserved. ;-----------  Dandelion Processor Program - I/O Processor  -----------;  DESCRIPTION:      Definitions for Boot code.;  Last modification by Roy RXO : January 22, 1982  4:57 PM;  File: BootDefs.asm;  Stored:  [Iris]<Workstation>BootEPromRAM.dm;  Written by Roy RXO .;  Modification History:;;	- Created (September 8, 1980  3:07 PM);	- Data area as definitions (November 11, 1980  12:55 PM);	- Floppy definitions (November 12, 1980  1:05 PM);	- Boot disk definitions (November 17, 1980  11:18 AM);	- New MP definitions (December 22, 1980  3:43 PM);	- Default boot (January 6, 1981  3:54 PM);	- Interrupt mask change (January 7, 1981  2:55 PM);	- Increased RetryNo to 10 (June 17, 1981  6:09 PM);	- Added new MP codes for Floppy IOP Initial (June 18, 1981  7:40 PM);	- Added EProm addresses for new organization (version 2.5) (September 18, 1981  11:59 AM);	- Added RST trap MP code (September 22, 1981  3:50 PM);	- Added Trident0 codes code (**temporary) (November 24, 1981  2:11 PM);	- Added new AltBoot, BootDevice codes (December 10, 1981  3:29 PM);	- Renamed AltBootDevice (unused)  to GenericBootDevice (December 11, 1981  3:56 PM);	- Added Version number, head clean AltBoot definitions (January 13, 1982  4:11 PM);	- Added RestoreCom variable (January 14, 1982  1:38 PM);  Version number:;  This number has a maximum value of 0FH (4 bits).;  Current assignments:  0 = Pre-version 3.0 EProms, 1 = Version 3.0 EProms;  Next version of EProm should use 2.EPromVersion	equ	1	;  Version 3.0 EPromsEPromVersionLoc	equ	3FH	;  Location of Version number in EProm;  Definitions for Fixed Prom addresses:BootGoProm	equ	40H			;  Boot entry point in PromSizeLink	equ	3		;  Link element is "jmp  Address"ErrorReportProm	equ	BootGoProm+(12*SizeLink)	;  MoveLinkTable entry point in PromMoveLinkTableProm	equ	BootGoProm+(13*SizeLink)	;  MoveLinkTable entry point in Prom;  RST Link Table addresses.SizeRSTLink	equ	3		;  Link element is "jmp  Address"StartRSTLinkTable	equ	1800H	;  Start of table of PreBoot and RST links;PreBootLinkLoc	equ	StartRSTLinkTable			;  Link for PreBoot startRST0LinkLoc	equ	StartRSTLinkTable+(1*SizeRSTLink)	;  Link for RST 0RST1LinkLoc	equ	StartRSTLinkTable+(2*SizeRSTLink)	;  Link for RST 1RST2LinkLoc	equ	StartRSTLinkTable+(3*SizeRSTLink)	;  Link for RST 2RST3LinkLoc	equ	StartRSTLinkTable+(4*SizeRSTLink)	;  Link for RST 3RST4LinkLoc	equ	StartRSTLinkTable+(5*SizeRSTLink)	;  Link for RST 4TRAPLinkLoc	equ	StartRSTLinkTable+(6*SizeRSTLink)	;  Link for TRAPRST5LinkLoc	equ	StartRSTLinkTable+(7*SizeRSTLink)	;  Link for RST 5RST55LinkLoc	equ	StartRSTLinkTable+(8*SizeRSTLink)	;  Link for RST 55RST6LinkLoc	equ	StartRSTLinkTable+(9*SizeRSTLink)	;  Link for RST 6RST7LinkLoc	equ	StartRSTLinkTable+(10*SizeRSTLink)	;  Link for RST 7;Spare0LinkLoc	equ	StartRSTLinkTable+(11*SizeRSTLink)	;  Spare link;Spare1LinkLoc	equ	StartRSTLinkTable+(12*SizeRSTLink)	;  Spare link;Spare2LinkLoc	equ	StartRSTLinkTable+(13*SizeRSTLink)	;  Spare link;Spare3LinkLoc	equ	StartRSTLinkTable+(14*SizeRSTLink)	;  Spare link;Spare4LinkLoc	equ	StartRSTLinkTable+(15*SizeRSTLink)	;  Spare link;  Transfer vectors in Domino for interrupts:GoToBurdockCPIntr	equ	2003H	;  RST 5.5 Transfer location in DominoGoToRS232CIntr	equ	2006H	;  RST 6.5 Transfer location in DominoGoToFloppyIntr	equ	2009H	;  RST 7.5 Transfer location in DominoGoToIOPBreakTrap	equ	200CH	;  RST 2 Transfer location in Domino (trap);  CPU constants.;EnableRST55	equ	1DH	; Enable RST 6.5, disable RST 5.5, 7.5, clear 7.5 FF (SIM)BootIntrState	equ	1FH	;  Disable RST 6.5, RST 5.5, 7.5, clear 7.5 FF (SIM);  Flags.NoBootMode	equ	0H	; Clear BootMode=0, CPStopped=0BootMode	equ	1H	; Set BootMode flag in KernelFlags (bit 7)CPStopped	equ	2H	; CP stopped: Bit 6;  CPDevices (in memory location 0):BootSA4000Mask	equ	1	;  Mask of SA4000 bit in CPDevices byteBootSA1000Mask	equ	2	;  Mask of SA1000 bit in CPDevices byteBootEthernetMask	equ	4	;  Mask of Ethernet bit in CPDevices byteBootTridentMask	equ	8	;  Mask of Trident bit in CPDevices byte;  Mask of disk bits in CPDevices byteDiskBootMask	equ	BootSA4000Mask+BootSA1000Mask+BootTridentMask; BootDevice values:BootSA4000	equ	1	;  Value of SA4000 in BootDeviceBootSA1000	equ	2	;  Value of SA1000 in BootDeviceBootEthernet	equ	3	;  Value of Ethernet in BootDeviceBootFloppy	equ	4	;  Value of Floppy in BootDeviceBootAltEthernet	equ	5	;  Value of Alternate Ethernet in BootDeviceBootTrident0	equ	6	;  Value of Trident0 in BootDeviceBootTrident1	equ	7	;  Value of Trident1 in BootDeviceBootTrident2	equ	8	;  Value of Trident2 in BootDeviceBootTrident3	equ	9	;  Value of Trident3 in BootDevice;  AltBoot Boot codes for BootType:AltDiagRigidBoot	equ	0	;  Diagnostic rigid disk booting (Shugart or Trident0)AltRigidBoot	equ	1	;  Rigid disk booting (Shugart or Trident0)AltFloppyBoot	equ	2	;  Floppy disk bootingAltEtherBoot	equ	3	;  Ethernet bootingAltDiagEtherBoot	equ	4	;  Diagnostic Ethernet bootingAltDiagFloppyBoot	equ	5	;  Diagnostic floppy disk bootingAltAltEtherBoot	equ	6	;  Alternate Ether disk bootingAltTrident1Boot	equ	BootTrident1	;  Diagnostic Trident1 bootingAltTrident2Boot	equ	BootTrident2	;  Diagnostic Trident2 bootingAltTrident3Boot	equ	BootTrident3	;  Diagnostic Trident3 bootingAltFloppyHeadClean	equ	10	;  Floppy Head cleaning; ****NOTE:  The assumption is made (to save code in AltBoot.asm) that:;  BootTrident1  =  AltTrident1Boot;  BootTrident2  =  AltTrident2Boot;  BootTrident3  =  AltTrident3BootDefaultBoot	equ	AltDiagRigidBoot	;  Default bootingMaxBootType	equ	AltFloppyHeadClean	;  Maximum AltBoot code implemented;  Start of boot files in memory:;StartIOPBootFileRAM	equ	2000H	;  IOP memory (RAM) (in StartIOPBootRAM.asm)StartCPBootFile	equ	100H	;  CP memoryStartDiagBootFile	equ	2000H	;  IOP memory;  Boot Source constants.BootSourceIOP	equ	0	;  Boot file in IOP memoryBootSourceCP	equ	1	;  Boot file in CP memoryBootSourceFloppy	equ	2	;  Boot file form floppyAltBootDelay1	equ	0FFFFH		;  Delay of .5 secAltBootDelay2	equ	8000H		;  Delay of .25 secBlinkDelay	equ	0FFFFH		;  Delay of .5 sec;;  Maintenance Panel error codes:;  There are two types of maintenance panel codes:  progress codes and error codes.;  Progress codes are placed in the Maintenance Panel at various stages of the boot sequence.;  Error codes are traps which blink the error number in the maintenance panel.;  Error codes are added to the current MPOffset to produce the actual displayed MP error code.;  Phases:;    Phase 0 starts at 100.  End Phase 0 starts at 135.;    Phase 1 starts at 150.  End Phase 1 starts at 185.;    Phase 2 (Rigid) starts at 200.  End Phase 2 starts at 240.;    Phase 2 (Floppy) starts at 250.  Continues with Phase 2 (Rigid) at 200.MPStartPhase0	equ	100	;  Start of Phase 0 boot file interpretation.MPEndPhase0	equ	135	;  End of Phase 0 boot file interpretation.MPEndPhaseNot0	equ	40	;  End of Phase  not 0 boot file interpretation (offset).MPStartPhase2Rigid	equ	200	;  Start of Phase 2 (Rigid)  (used by IOPInitial).MPStartPhase2Floppy	equ	249	;  Start of Phase 2 (Floppy)  (used by IOPInitial).MPStartInterpretGerm	equ	260	;  Start Germ/Othello read (Floppy)  (used by IOPInitial).MPEndPhase2Floppy	equ	285	;  End of Phase 2 (Floppy).;  Errors are relative numbers, and are added to Phase offset.;  Errors 1 - 9 correspond to CP errors or Floppy PVRP errors.ErrorZeroGermAddress	equ	1	;  Zero Germ Address in PVRPErrorZeroSoftMCAddress	equ	2	;  Zero Soft MC Address in PVRPErrorZeroHardMCAddress	equ	3	;  Zero Hard MC Address in PVRP;  Boot Device errors:;  End Phase 0:ErrorNoDiskFound	equ	11	;  Rigid disk booting specified, but no disk in Mem 0ErrorMultiDisksFound	equ	12	;  Rigid disk booting specified, but multi disk bits in Mem 0ErrorUnimplBootDevice	equ	13	;  Unimplemented AltBoot deviceErrorInvalidBootType	equ	14	;  Invalid BootTypeErrorUnimplBootSource	equ	15	;  Unimplemented Boot Source;  Boot File errors:ErrorUnknownBlock	equ	17	;  Unknown special boot file blockErrorBadIOPCount	equ	18	;  Something wrong with IOP block byte countErrorLoadUNotPhase0	equ	19	;  LoadU not in Phase 0;  Floppy errors:ErrorNoFloppy	equ	1ErrorTrackToBig	equ	2ErrorTrackNeg	equ	3ErrorCommandTrackError	equ	4ErrorType1HardError	equ	5ErrorRestoreFail	equ	6ErrorSeekFail	equ	7ErrorReadSectorFail	equ	8ErrorReadHardError	equ	9ErrorNoDmaEndCount1	equ	10ErrorNoDmaEndCount2	equ	11ErrorFormatFail	equ	14ErrorWriteHardError	equ	15ErrorWriteSectorFail	equ	16ErrorDataFail	equ	17;  Error code for RST traps.ErrorRSTTrapOffset	equ	500	;  Use 509 in the Domino trapsErrorRSTTrap	equ	9;; CPKernel constants.CPExitKernel	equ	00H	; Command to CPKernel to exit CPKernel.CPRefresh	equ	01H	; Command to CPKernel to refresh.;  CP microcode commands.CPWriteCmd	equ	0H	;  Write CP blockCPReadCmd	equ	1H	;  Read CP blockCPLoadUCmd	equ	3H	;  Load U register blockCPSetBootCmd	equ	4H	;  Set boot device commandCP64KMask	equ	3H	;  Mask for high part of CP addressBlockTypeMask	equ	0F0H	;  Mask of BlockType in block headernBlockTypeMask	equ	0FFH-BlockTypeMask	;  Complement of BlockType maskuBootDeviceMask	equ	0F0H	;  Mask of uBootDevice in uBlock 2nd worduBlockMask	equ	0FH	;  Mask of uBlock number in uBlock 2nd wordInhibitStartCPMask	equ	80H	;  Mask of InhibitStartCP bit in LastBlockFlags;  Control store image:;  Maximum CS address in image is stored in CSImageSize.;  Size of CSImage (in instructions):CSImageSizeVal	equ	128	;  Size of CSImage;  Default microinstruction in CSImage.;	GOTO [K1Entry],			c*;;   where K1Entry = 0F8F.;  .ft:;  W0   W1   W2; 0071 8488 8F8FrArBField	equ	00HaSaFaDField	equ	71HEPfSField	equ	84HfXField	equ	8HfYField	equ	8HfZField	equ	8HNextAddrHigh	equ	0FHNextAddrMid	equ	08HNextAddrLow	equ	0FHDefaultCS0	equ	rArBFieldDefaultCS1	equ	aSaFaDFieldDefaultCS2	equ	EPfSFieldDefaultCS3	equ	16*fYField+NextAddrHighDefaultCS4	equ	16*fXField+NextAddrMidDefaultCS5	equ	16*fZField+NextAddrLow;  PCB indexesCPAddr3	equ	0	;  CP address (low) index in PCBCPAddr1	equ	2	;  CP address (high) index in PCBCPCnt		equ	4	;  CP count (words) index in PCB;  Ethernet Definitions:;  Ethernet Host address information.;  The Ethernet host number in logical format is a 48-bit number:;	B5 B4 B3 B2 B1 B0,  where Bi is a byte.;  The address is transmitted:  B0 B1, B2 B3, B4 B5 (High, Middle, Low).;  B0 B1 B2 B3 (high, middle words) is fixed for Dandelions as 00 00, AA 00 (Hex).;  B4 B5 (low word) is the variable processor ID.;EtherHostHigh	equ	0000H	;  B0..B1;EtherHostMiddle	equ	0AA00H	;  B2..B3; Floppy disk definitions:;  Disk addresses:StartPVRPCylinder	equ	4	;  Starting disk address of Physical volume root pageStartPVRPSide	equ	0		;  (Side 0, Cylinder 4, sector 1)StartPVRPSector	equ	1StartInitialCylinder	equ	5	;  Starting disk address of Initial boot fileStartInitialSide	equ	0		;  (Side 0, Cylinder 5, sector 1)StartInitialSector	equ	1;  Indexes (in words) in the Physical Volume Root Page (See  PhysicalVolumeFormat.mesa, Boot.mesa):StartBootInfo	equ	8	;  Index of start of the array od DiskFileIDsStartIdDiskAddr	equ	7	;  Start of 2-word disk address inside a DiskFileIDSizeDiskFileID	equ	9	;  Size (in words) of a DiskFileID elementSizeDiskAddr	equ	2	;  Size (in words) of a DiskFileID element;  Index of hard microcode disk address in PVRP:StartHardMCIndex	equ	StartBootInfo+StartIdDiskAddr;  Index of soft microcode disk address in PVRP:StartSoftMCIndex	equ	StartBootInfo+SizeDiskFileID+StartIdDiskAddr;  Index of germ disk address in PVRP:StartGermIndex	equ	StartBootInfo+(2*SizeDiskFileID)+StartIdDiskAddrSectorNo		equ	5	;  Number of sectors read in a run (for EProm code)SectorLen	equ	512	;  Sector length (bytes)MaxSectorNo	equ	15	;  Maximum sector number (DDen, 512 byte sectors)SDen		equ	0	;  Value in Density for single densityDDen		equ	1	;  Value in Density for double densityRetryNo		equ	10	;  Number of retrys before failPreCompStart	equ	43		;  First track to have precomp in double densityDefaultFDCStateVal	equ	85H	;  Enable Waits, Enable controller, Enable Drive, disable DDFDCSide1Mask	equ	20H	; FDC Sel Side 1 in state registernFDCSide1Mask	equ	0FFH-FDCSide1Mask	; FDC Sel Side 1 in state register (Complement)FDCDDenMask	equ	8H	;  Double density bit in FDCStatenFDCDDenMask	equ	0FFH-FDCDDenMask	; Double density bit (Complement)FDCEnPreCompMask	equ	40H	; FDC Enable PreComp in state registernFDCEnPreCompMask	equ	0FFH-FDCEnPreCompMask	; FDC Enable PreComp in state register (Complement);  FDC Status register (external) definitions.FDCIntMask	equ	80H	; FDC Int Req in status register (external)FDCEndCountMask	equ	40H	; FDC end count in status register (external)FDCTwoSidedMask	equ	20H	; FDC two-sided bit in status register (external)FDCSA800Mask	equ	10H	; FDC SA800 bit in status register (external);  FDC 179X controller definitions.RestoreCmd	equ	0EH	; Restore command (h=1, V=1, r1r0=2)RestoreCmdNoV	equ	0AH	; Restore command (h=1, V=0, r1r0=2)SeekCmd	equ	1CH	; Seek command (h=1, V=1, r1r0=0)SeekCmdR2	equ	1EH	; Seek command (h=1, V=1, r1r0=2)SeekCmdNoV	equ	19H	; Seek command (h=1, V=0, r1r0=1)StepCmd	equ	3DH	; Step command (u=1, h=1, V=1, r1r0=1)StepInCmd	equ	5DH	; StepIn command (u=1, h=1, V=1, r1r0=1)StepInCmdNoV	equ	59H	; StepIn command (u=1, h=1, V=0, r1r0=1)StepOutCmd	equ	7DH	; StepOut command (u=1, h=1, V=1, r1r0=1)ReadSectorCmd	equ	088H	; Read Sector command (E=0) (1797)WriteSectorCmd	equ	0A8H	; Write Sector command (E=0) (1793)ForceInt0Cmd	equ	0D0H	; ForceInt command (I0 = I1 = I2 = I3 =0)Type2SMask	equ	2H	;  S-bit mask in ReadSector command (1797)nType2SMask	equ	0FFH-Type2SMask	;  Complement of S-bit maskSide1Mask	equ	1H	;  Side 1 bit in Side and DSide;  Floppy status bits.;  All typesFDCNotReady	equ	80H		;  Not readyFDCCRCError	equ	8H		;  CRC errorFDCWrProt	equ	40H		;  WriteProtectFDCBusyMask	equ	1H		; Busy Status bit; Type I:FDCSeekError	equ	10H		;  Seek errorFDCHeadLoad	equ	20H		;  HLD and HLTFDCTk0Mask	equ	4H		; Track 00 bit mask in status; Type II and III:FDCRNFMask	equ	10H		;  Record Not FoundFDCLostData	equ	4H		;  Lost DataFDCDRQMask	equ	2H		; Data Request Status bit; Error Masks for Type I commandsType1ErrorMask	equ	FDCNotReady+FDCSeekError+FDCCRCError+FDCBusyMaskType1HardMask	equ	FDCNotReady+FDCBusyMask; Error Mask for Type II read commandsReadErrorMask	equ	FDCNotReady+FDCRNFMask+FDCCRCError+FDCLostData+FDCBusyMaskReadHardMask	equ	FDCNotReady+FDCBusyMaskWriteErrorMask	equ	FDCNotReady+FDCWrProt+FDCRNFMask+FDCCRCError+FDCLostData+FDCBusyMaskWriteHardMask	equ	FDCNotReady+FDCWrProt+FDCBusyMaskDDenMask	equ	8H	;  Double density bit in FDCState;  Dma defs.DmaReadBit	equ	80H	;  Dma Read bit in count highDmaWriteBit	equ	40H	;  Dma write bit in count highEnFloppyChannel	equ	61H	;  Dma Mode byte: TCS, EW, EN0OutDmaFunc	equ	DmaFuncRead	;  Read memoryInDmaFunc	equ	DmaFuncWrite	;  Write memoryFloppyChannelMask	equ	1H	;  Floppy is channel 0;;  BOOT CODE DATA AREA;;  The Boot variables are stored in memory starting from value BootDataArea.;  The CSImage is just above data area.;  The Floppy buffer is just above CSImage area.;  Note:  The start address of the Floppy Buffer is changed when doing RAM booting.;  The Stack area is from BootStackStart (Top of stack), to BootStackEnd (Bottom of stack).;  The Link table is stored upwards in memory, i.e. in ascending order,;    the first item starting at location BootStackEnd-SizeLink (def. in BootLinkDefs.asm).;  RAM layout:;	FloppyBuf;	CSImage;	Boot variables;	Link table;	Boot stack area;BootDataArea	equ	46D0H		;  Start of data areaBootDataArea	equ	5ED0H		;  Start of data variable area;  Size of CSImage = CSImageSize (in instructions).; Image of low n words of Control Store (6n byte).CSImage		equ	BootDataArea-(6*CSImageSizeVal);  Floppy Buffer above CSImageFloppyBuf	equ	CSImage-(SectorNo*SectorLen)	;  Start of Floppy buffer (EProm);  Boot Stack.BootStackSize	equ	2EH		;  Size of Boot stack area in byesBootStackStart	equ	UserStkStart	;  Top of boot stackBootStackEnd	equ	BootStackStart-BootStackSize	;  Bottom byte in stack;  Link table copied into RAM here:StartLinkTable	equ	BootStackEnd-SizeLink	;  Start of table of links (See BootLinkDefs.asm);  Data variables:CSImageStart	equ	BootDataArea	;  Pointer to start of image (2 bytes)CSImagePtr	equ	CSImageStart+2	;  Pointer into image (2 bytes)CSImageCnt	equ	CSImagePtr+2	;  Microinstruction counter in image (2 bytes)CSImageSize	equ	CSImageCnt+2	;  Size of CSImage in instructions (2 bytes);  Range of CS addresses in image is [0..CSImageSizeVal)TPCBuffer	equ	CSImageSize+2	;  TPC values (16 bytes)TPCBufPtr	equ	TPCBuffer+16	;  Pointer into TPC buffer (2 bytes)TPCAddress	equ	TPCBufPtr+2	;  TPC address for WriteTPC (1 byte)CSAddress	equ	TPCAddress+1	;  CS Address for WriteCS (2 bytes)CSAddressHi	equ	CSAddress+1CSCount	equ	CSAddress+2		;  Control store byte count (1 byte)CSInstrCount	equ	CSCount+1	;  Control store instruction count (1 byte)CSBuffer	equ	CSInstrCount+1	;  Control store buffering (6 bytes)uBlockCnt	equ	CSBuffer+6	;  Number of uBlocks to do (1 byte)uBlockPtr	equ	uBlockCnt+1	;  Pointer to array of uBlock pointers (8 max) (2 bytes)uBlockPtrArray	equ	uBlockPtr+2	;  Pointer to array of uBlock pointers (8 max) (16 bytes)uBlockBuffer	equ	uBlockPtrArray+16	;  16 words of u register values (32 bytes)BootFlags	equ	uBlockBuffer+32	;  Boot Flags (1 byte):					;   bit 6: CPStopped					;   bit 7: BootModeLastBlockFlags	equ	BootFlags+1	;  LastBlock Options (2 bytes):					;   bit 0: Inhibit StartCPLastBlockFlagsHi	equ	LastBlockFlags+1BootType	equ	LastBlockFlags+2	;  Boot number determined by AltBoot (1 byte)DiagBoot	equ	BootType+1	;  Flag indicating diagnostic boot (1 byte) (set by AltBoot value)CPDevices	equ	DiagBoot+1	;  Low byte of Mem 0 indicating boot devices on CP (1 byte)BootDevice	equ	CPDevices+1	;  Boot device (1 byte)					;   -1: undefined					;    1: SA4000					;    2: SA1000					;    3: Ethernet					;    4: Floppy					;    5: AltEthernet					;    6: Trident0					;    7: Trident1					;    8: Trident2					;    9: Trident3GenericBootDevice	equ	BootDevice+1	;  BootDevice (All Tridents mapped to Trident0)BootSource	equ	GenericBootDevice+1	;  Source of Boot file (1 byte)					;    0: IOP memory					;    1: CP memory					;    2: Floppy streamingPhase	equ	BootSource+1		;  Boot phase [0, 1, 2] (1 byte)BootAddrIOP	equ	Phase+1		;  Boot file address pointer (IOP mem) (2 bytes)Header	equ	BootAddrIOP+2		;  Storage for Boot block header (2 bytes)HeaderHi	equ	Header+1StartIOPAddress	equ	Header+2	;  Start address for IOP at end of Boot Phase (2 bytes)IOPAddress	equ	StartIOPAddress+2	;  IOP memory address during loadIOP (2 bytes)IOPCountWord	equ	IOPAddress+2	;  IOP memory count (words) during loadIOP (2 bytes)IOPCountByte	equ	IOPCountWord+2	;  IOP memory count (bytes) during loadIOP (2 bytes)IgnoreCount	equ	IOPCountByte+2		;  Ignore count during Ignore block (2 bytes)IgnoreData	equ	IgnoreCount+2		;  Ignore data during Ignore block (2 bytes);  Control Blocks for CPport transfers.;  Boot file access in main memory:;  Note that first word is the BootFile pointer in main memory.BootPCB	equ	IgnoreData+2		;  (8 bytes)BootAddrCP	equ	BootPCB; Format:	Word 0:  CP buffer pointer (low):  Boot file address pointer (CP mem); Format:	Word 1:  CP buffer pointer (high) (always 0); Format:	Word 2:  CP buffer count (words); Format:	Word 3:  Pointer to IOP buffer (unused);  Access to single location in main memory:MemPCB	equ	BootPCB+8	;  (8 bytes); Format:	Word 0:  CP buffer pointer (low):; Format:	Word 1:  CP buffer pointer (high) (always 0); Format:	Word 2:  CP buffer count (words) (always 1); Format:	Word 3:  Pointer to IOP buffer (unused);  Floppy disk variables.FloppyBufPtr	equ	MemPCB+8	;  Floppy buffer pointer (2 bytes)FloppyBufCnt	equ	FloppyBufPtr+2	;  Floppy buffer count, in words (2 bytes)Cylinder	equ	FloppyBufCnt+2	;  Current cylinder (2 bytes)DCylinder	equ	Cylinder+2	;  Desired Cylinder (2 bytes)Sector	equ	DCylinder+2	;  Desired sector (1 byte)Side	equ	Sector+1	;  Current Side (1 byte)SectorCnt	equ	Side+1	;  Counter for retrying (1 byte)RetryCount	equ	SectorCnt+1	;  Counter for retrying (1 byte)DiskStatus	equ	RetryCount+1	;  Disk controller status (1 byte)FDCStateVal	equ	DiskStatus+1	;  Copy of FDCState register (1 byte);  Variables for Diagnostics:DiagBootN	equ	FDCStateVal+1	;  Next DiagBoot number (1 byte)LoopC		equ	DiagBootN+1	;  Flag whether to loop on current pointer (1 byte)KBFlag		equ	LoopC+1	;  Keyboard type select (1 byte)DiagBootI	equ	KBFlag+1	;  Initial DiagBoot number (1 byte);  Maintenance Panel offset value:MPOffset		equ	DiagBootI+1	;  Offset value for the Maintenance Panel (2 bytes);  Extra floppy variables:DSide	equ	MPOffset+2		;  Desired Side for floppy seek (1 byte)SeekCom	equ	DSide+1			;  Seek command (1 byte)SkCmdNoV	equ	1AH  ; Seek command (h=1, V=0, r1r0=2) ReadSectorCom	equ	SeekCom+1	;  Read Sector command (1 byte)RestoreCom	equ	ReadSectorCom+1	;  Restore command (1 byte);  Address of next variable to be added.NextVar		equ	RestoreCom+1	END	BootDefs@


1.1.1.1
log
@first add
@
text
@@
