head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.09;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.09;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@; Copyright (C) 1980, 1987  by Xerox Corporation. All rights reserved. ;  Test Programs for CP:  TPC, control store,CPport, and INSTRUCTION Tests.;;  Last modification by ;  Modification History:;;	changed to version 8.0 by HEM			11-Dec-87 18:42:33;	- Created (June 4, 1980  12:59 PM);	get "SysDefs.asm"	; system defs (tests defs below)        get "MOONBootDefs.asm"	; system defs (tests defs below)        get "MOONBootLinkDefs.asm"	; system defs (tests defs below)        get "MOONLinkDefs.asm"	; system links         get "MOONSysDefs.asm"	; system defs         ;-----------------------------------------------------------------         jmp KBInit         jmp Loopbacktest         jmp TPCTest         jmp DoCSTest1         jmp DoCSTest2         jmp DoCSTest3         jmp DoCSTest4         jmp PortIn         jmp PortInDma         jmp PortOutDma;  Temporary data area.CSSeed:	db	00H	;  Seed for CS Data random number, or constant dataOutCSData:	db	0,0,0,0,0,0	;  Write control store data (6 bytes)Mode:	db	0	;  Program mode for tests (default: , Constant data)BufferPtr:	dw	CSImage	;  Start of data bufferBufferCount:	dw	BufferSize	;  Size of buffer;---------------- START of Program -------------------------;  Initialize.TTYINIT:				;  Initiate USART	mvi  a,1        sta   KBFlag        CALL	USARTINIT	call    ExtWait        IN	PrinterStatus	;  ADM-3 is ready?	ANI	DSR	JZ	ExtLogDError	MVI	A,Enable		; Set UART Command	OUT	PrinterCommand	CALL	CRLF	LXI	H,SENT1		; Type out Titles.	CALL	Stream	CALL	CRLF	LXI	H,SENT2		; Type out Titles.	CALL	Stream	CALL	CRLFTTYExit:	mvi   a,0        sta   ObservedData        jmp	ExtLogPErrorUSARTINIT:				;  Initiate USART	lxi	h,TTYDataWait	;  Initialize delay for KBDiag signal	shld	WaitConst	MVI	B,0H		;  B ¬ MSB, C ¬ LSB	MVI	C,12		;  12D=Devisor for 9600Hz of Async mode(X16)    MVI	A,OSCcmd		;  Frequncy and Mode Set to i8253 (for USART)	OUT	TimerMode		;  Counter#0, LSB & MSB, Mode3, Binary	MOV	A,C	OUT	TimerCount0	MOV	A,B	OUT	TimerCount0	;  End of Initiatlize Baud-Rate generator    MVI	A,Reset0		; Reset UART	OUT	PrinterCommand		MVI	A,Reset1	OUT	PrinterCommand		MVI	A,Reset2	OUT	PrinterCommand		NOP			;  Needed for B-step chips	MVI	A,PTMode		;  Set Mode value (assumed asynchronous) 	OUT	PrinterCommand		retStream:	IN	IntReq		; Watch Condition of USART	ANI	PtrRxReqMask	; Dummy Read Charcter 	JNZ	Stream1		; To avoid irregal input	IN	PrinterStatus	ANI	TTYERROR	JNZ	ExtLogDError	IN	PrinterData	Stream1:	MOV	A,M	STA	KBBuffer	CPI	CRCode	JZ	Stream2	CALL	Send	INX	H	JMP	STREAMStream2:	CALL	CRLF	RETCRLF:	MVI	A,CRCode		; CR code send	STA	KBBuffer	CALL	Send	MVI	A,LFCode		; LF code send	STA	KBBuffer	CALL	Send	RETSend:	call ExtWait        IN	IntReq		; Watch Condition of USART	ANI	PtrTxReqMask	JNZ	ExtLogDError	IN	PrinterStatus	; Check Error	ANI	TTYERROR	JNZ	ExtLogDError	LDA	KBBuffer	OUT	PrinterData		; Data Send	RETSENT1:	DB	"THIS PROGRAM IS THE BOOT DIAGNOSTICS VERSION 8.0"	DB	CRCodeSENT2:	DB	"THIS MESSAGE CONFIRMS THAT THE SYSTEM ADMINISTRATOR DISPLAY IS OPERATIONAL."	DB	CRCodeLoopbacktest:				    LXI SP, UserStkStart    mvi  a,MPSetLoop2    call    ExtMPNumber    call    ExtTimeDelay    call    USARTINIT    MVI	A,Enable		; Set UART Command	OUT	PrinterCommand	mvi a,0    sta  	ExtNOTYPEINC    sta  	ExtNotusedLoopbacktest1:					call    Loopback    lhld 	ExtNotused	mov   a,l        xra    h        jnz	Derror    inr 	l	mov   a,l        sta 	ExtNotused    jmp	Loopbacktest1	Derror:				   lda	    ExtNotused	call    ExtMDisplay    lda	    ExtNOTYPEINC	call    ExtMDisplay    jmp	LoopbacktestLoopback:    call    ExtWait    IN	PrinterStatus	; Check Error	ANI	DSR	JZ	StatusError	IN	IntReq		; Watch Condition of USART	ANI	PtrTxReqMask	JNZ	NoTxReq	LDA	ExtNotused	OUT	PrinterData		; Data Send    call    ExtWait    IN	PrinterStatus	; Check Error	ANI	DSR	JZ	StatusError	IN	IntReq		; Watch Condition of USART	ANI	PtrRxReqMask	jnz	NoRxReq	;  TTY request is active low	IN	PrinterData		; Data Receive	sta  	ExtNOTYPEINC		;  Store away.    retStatusError:    mvi a,MPSetLoop3    jmp  	StErrorNoTxReq:    mvi a,MPSetLoop4    jmp  	StErrorNoRxReq:    mvi a,MPSetLoop5StError:    call    ExtMPNumber    call    ExtTimeDelay    jmp	Loopbacktest;  Initialize the keyboard.;  Issue the KBDiag command.  Data will be returned - use read data command.KBInit:       lxi	h,KBDiagWait	;  Initialize delay for KBDiag signal	shld	WaitConst	mvi	a,KBDiag	;  Set KB diag mode	out	MiscControl1	;  set bit in register	call	ExtWait		;  ExtWait 15 msec	mvi	a,0		;  Clear KB diag mode	sta    KBFlag    out	MiscControl1	;  set bit in register;  KBDiag pulse has been issued.;  Return sequence of events should be all characters held down followed by D2, D1.	mov	c,a		;  Clear KB event counter        lxi	h,KBDataWait	;  Initialize delay for KBData signal	shld	WaitConstKBDLoop:	call	GetIt	;  Get byte from keyboard	cpi 	KBD2		;  Is it a D2 character?	jz	    KBD1Loop	        cpi	    KBD1		;  Is it a D1 character?	jz	    KBD2Loop	;  Not yet D1 => loop        jmp   KBDLoop KBD1Loop:	call	GetIt	;  Get byte from keyboard        cpi	    KBD1		;  Is it a D1 character?	jnz	KBD1Loop	;  Not yet D1 => loop        jmp TTYExit         KBD2Loop:	call	GetIt	;  Get byte from keyboard        cpi 	KBD2		;  Is it a D2 character?	jnz	KBD2Loop	;  Not yet D1 => loop        jmp TTYExit         GetIt:	mov	a,c		;  	cpi    04H        jz     TTYInit         call	ExtWait	;  ExtWait for byte from keyboard	call	ExtReadKBByte	;  Get byte from keyboard (returned in A)	sta	KBBuffer	;  Store away in buffer.	inr	c		;  Increment counter	retPortIn:	mvi	d,0	;  Initialize expected data (first value = 0)	mvi	c,0	;  Initialize count.PortInTest1Loop:	lda TestN        cpi	   InPO        jz	   PortOut        call	ExtReadCPport	;  Get data from port	sta  ObservedData        xra	    d		;  compare with D	jz	PortInCount	;  jump if data was correct        mov	a,d        sta  ExpectedData        jmp	ExtLogDErrorPortInCount:       	inr	d	;  Increment expected data        inr 	c		;  Increment counter	mov	a,c	cpi	0		;  Low part zero?	jnz	PortInTest1LoopPortInTest1Done:          ;  Test done.  .	jmp  ExtDoInstTest2PortOut:	mov	a,d		;  Output data to port	call	ExtWriteCPport        mvi  a,6        sta  ObservedData        in	CPStatus     ;  Check for error condition (CPAttn).	ani	CPAttnMask	jz	ExtLogPError		;  (CPAttn inactive)	jmp  PortInCount;  PortInDma test using Dma Writes.;  The microcode outputs an increasing value to IOPOData,;  which is read into memory by the Dma controller.;  The data is then checked by the IOP.PortInDma:       ;  Program channel 1 of the Dma controller for Writes.	lhld	BufferPtr	mov	a,l		;  program low address of buffer	out	DmaCh1Addr	mov	a,h		;  program high address of buffer	out	DmaCh1Addr	lhld	BufferCount	dcx	h		;  decrement for Dma	mov	a,l		;  program low count	out	DmaCh1Count	mov	a,h		;  program high count (dma write)	ori	40H		;  OR in write bit.	out	DmaCh1Count	mvi	a,EnCPport	;  Enable channel: TCS, EW, EN1	out	DmaMode	;   Dma channel is now programmed and enabled.	call ExtStartCP    StartDmaIn:    ; Start Dma . At this point IOPExtWait, and SwTAddr are cleared.	mvi	a,CPEnable+CPDmaIn	out	CPControl	;  Set DmaIn (Clear IOPExtWait, clear SwTAddr)	mvi	a,CPEnable+CPDmaIn+CPDmaMode	out	CPControl	;  Set DmaMode (set DmaIn,  clear IOPExtWait, SwTAddr)	call	CheckCPDmaComplete   ;  Check for Dma completion.	in	DmaStatus	;  Dma has completed.  Check for internal termination too.	ani	DmaCh1Mask	jz	ExtLogDMAErrorExtDisableDmaR:   ;  Operation complete.  Disable the Dma.	call    ExtDisableDma     mvi	d,0		;  Initialize expected data (first value = 0)	lhld	BufferCount	;  Initialize count.	mov	c,l	mov	b,h		;  Move to B,C	lhld	BufferPtr	;  Buffer pointer to H,LPortInDmaCheckLoop:	mov	a,m	sta  ObservedData        xra	d		;  compare with D	jz	PortInDmaCount2	;  jump if data was correct        mov	a,d        sta  ExpectedData        jmp	ExtLogDErrorPortInDmaCount2:	inr	d		;  Increment expected data	inx	h		;  Increment buffer pointer	dcx	b		;  Decrement counter	mov	a,c	cpi	0		;  Low part zero?	jnz	PortInDmaCheckLoop	mov	a,b	cpi	0		;  High part zero?	jnz	PortInDmaCheckLoopPortInDmaTest2Done:     ;  Test done.  Set IOPExtWait to stop CP.	jmp  ExtDoInstTest2	;  PortOutDma test using Dma Reads.;  This microcode reads an increasing value from IOPIData.;  The Dma controller writes the data to the port.PortOutDma:        mvi	d,0		;  Initialize data (first value = 0)	lhld	BufferCount	;  Initialize count.	mov	c,l	mov	b,h		;  Move to B,C	lhld	BufferPtr	;  Buffer pointer to H,LPortOutDmaStoreLoop:	mov	m,d		;  Store data	inr	d		;  Increment expected data	inx	h		;  Increment buffer pointerPortOutDmaCount2:	dcx	b		;  Decrement counter	mov	a,c	cpi	0		;  Low part zero?	jnz	PortOutDmaStoreLoop	mov	a,b	cpi	0		;  High part zero?	jnz	PortOutDmaStoreLoopPortOutDmaTest2Cont:;  Data is stored.  Program channel 1 Dma controller for reads.	lhld	BufferPtr	mov	a,l		;  program low address of buffer	out	DmaCh1Addr	mov	a,h		;  program high address of buffer	out	DmaCh1Addr	lhld	BufferCount	dcx	h		;  decrement for Dma	mov	a,l		;  program low count	out	DmaCh1Count	mov	a,h		;  program high count (dma write)	ori	80H		;  OR in read bit.	out	DmaCh1Count	mvi	a,EnCPport	;  Enable channel: TCS, EW, EN1	out	DmaModeStartDmaOut:     ;  Dma is now programmed and enabled.	mvi	a,CPEnable+CPDmaMode	out	CPControl	;  Set DmaMode (clear IOPExtWait, SwTAddr, DmaIn)	call	CheckCPDmaComplete  ;  Check for Dma completion.	in	DmaStatus	;  Read internal Dma status.	ani	DmaCh1Mask  ;  Dma has completed. Check for internal termination.	jz	ExtLogDMAErrorExtDisableDmaW:   ;  Operation complete.  Disable the Dma.	call    ExtDisableDma PortOutDmaTest2Done:	jmp  ExtDoInstTest2; TPC test.;  This test writes all the TPCs with a pattern and then reads and checks them.;  All 12 bit patterns are tested.TPCTest:    mvi a,0    sta ModeTPCTest1:    mvi	a,MaxTPCAddr	;  initialize TPC address    sta   Task	    call  DcxMaskWTPCTest2:    lda   Mode	    cpi	5		    jnz	WTPCTest4    lda   Task	    mov d,a    mov e,aWTPCTest4:    call   WriteTPC	;  Write the dataWTPCTest3:    lda   Task	    sui   10H		    sta   Task	    jp	WTPCTest2RTPCTest:    mvi   a,MaxTPCAddr	;  initialize TPC address    sta   Task	RTPCTest1:    mov c,a    call    ExtReadTPC	;  Read the data (returned in BC)    lda   Mode	    cpi	5		    jnz	RTPCTest3    lda   Task	    mov d,a    mov e,aRTPCTest3:    call    CheckTPC	;  Check data (breakpoints if error)RTPCTest2:    lda   Task	    sui   10H		    sta   Task	    jp	RTPCTest1    lda   Mode	    cpi	5		    jnz	TPCTest1	    jmp	TTYExit	DcxMask:    lda   Mode	    mvi  d,0FFH    cpi	1		    jz	DcxMaskRet    mvi  d,0AAH    cpi	2		    jz	DcxMaskRet    mvi  d,55H    cpi	3		    jz	DcxMaskRet    mvi  d,0DcxMaskRet:    inr a    sta   Mode	    mov a,d    mov e,a    ret    ;  Write TPC.;  On entry:;    TPC address is in C (3 bits right-justified).;    TPC data is in DE (12 bits right-justified).;  Format of TPCHigh (write):  TPCAddr[0:2],,TPCData[0:4]';  Format of TPCLow (write):  don't care,,TPCData[5:11]'WriteTPC:	push	b		;  Save B,C temporarily	call	ExtLeftAlignTPCAddr	; Left align 3 bits of address in C	ori 0        mov	a,e		;  Move TPC[4] into B for TPCHigh format	ral			;  TPC[4] into carry	mov	a,d		;  get high part	ral			;  TPC[4] into B[7]	cma			;  complement for port	ani	1FH		;  Clear High 3 bits	ora	c		;  OR in address	out	TPCHigh	;  Set address, high data	mov	a,e		;  Get low part (C[0] is don't care)	cma			;  complement for port	out	TPCLow	;  send low data, Write TPC	pop	b	ret;  Subroutine to check TPC values read in.;  Returned value is in ObservedCSlow, output value in DE.CheckTPC:	mov a,d	ani  0FH	mov  c,a	lda	ObservedCSlow	;  Get low part of new data	cmp	e		;  check it with Correct data	jnz	CheckTPCErr	lda	ObservedCSHigh	;  Get high part of new data	cmp	c		;  check it with Correct data	rz	CheckTPCErr:	mov  d,c	xchg			;  Move to HL for store	shld	ExpectedCSLow	;  Store real data in TPC data area	jmp   ExtLogTPCErrorDoCSTest1:	mvi a,ConstantDataVal    sta Mode    jmp CSTestDoCSTest2:	mvi a,ConstantDataVal    sta Mode    mvi a,0FFH    jmp CSTestDoCSTest3:	mvi a,  AddressDataVal    sta Mode    jmp CSTestDoCSTest4:    mvi a, RandomDataVal    sta Mode    jmp CSTest;  Control Store Test.;  This test writes control store with varying data, and then reads and checks the data.;  The type of data written depends on flags in Mode.;     Constant, Random:  Each CS location has the same byte repeated 6 times.;     Address in location:  Each CS location has the its address repeated 3 times.;  TPC register 6 is used to write/read the control store.;  Conventions:  C  contains the TPC address (3 bits right-justified);	          DE  contains the TPC data (12 bits right-justified)CSTest:	sta CSSeedCSTestStart:	mvi	a,60H	;  Use TPC address 6	NextTPCAddr:	sta	 Task        lhld	BootIndexes+1	;  start with initial address	xchg	lda	 CSSeed		;  Initialize seed for random number (or constant data)	sta	 ExpectedData        lda	BootIndexes+5	;  get WriteOK	cpi 0		;  Check forlower CSAddress 	jnz     WriteDoneNextCSWrite:	call	GetNextCSData	;  Data stored in OutCSData array	call	WriteTPC	;  Write the TPC slot with the control store address	call	WriteCS	;  Write data in OutCSData	lda mode        cpi  AddressDataVal        jnz   NextCSWrite1        call	InvertAddr	;  Write the inversion addressNextCSWrite1:	lda	BootIndexes+3	;  get ending address	xra	e		;  Check forlower CSAddress 	jnz     IncCSAddr	call      CheckKeyboard        lda	BootIndexes+4	;  get ending address	xra	d		;  Check for CSAddress greater than 4095	jz	WriteDone;  Go back to command loopIncCSAddr:	inx	d		;  Increment CSAddress	jmp	NextCSWrite	;  Do next CS address	WriteDone:	lda	BootIndexes+6	;  Get Read OK	cpi 0		;  Check forlower CSAddress 	jnz     TTYExit		;  Finished writing control store.  Do read/checks.	lhld	BootIndexes+1	;  start with initial address	xchg	lda	 CSSeed		;  Initialize seed for random number (or constant data)	sta	ExpectedDataNextCSRead:	call	GetNextCSData	;  Data stored in OutCSData array	call	WriteTPC	;  Write the TPC slot with the control store address	call	ExtReadCS	;  Read data into InCSData	call	CheckCS	;  Check data (breakpoints if error)        lda	BootIndexes+3	;  get ending address	xra	e		;  Check forlower CSAddress 	jnz     IncCSAddr1	call      CheckKeyboard        lda	BootIndexes+4	;  get ending address	xra	d		;  Check for CSAddress greater than 4095	jz	TTYExit;  Go back to command loopIncCSAddr1:	inx	d		;  Increment CSAddress	jmp	NextCSRead	;  Do next CS address        	CheckKeyboard:    push d    push h    call ExtMonitorKeyIn	    pop   h    pop   d    retInvertAddr:    push d    mvi  a,0FFH    xra   d    ani	0FH		;  Mask high part    mov d,a    mvi  a,0FFH    xra   e    mov e,a    call	GetNextCSData	;  Data stored in OutCSData array    call	WriteTPC	;  Write the TPC slot with the control store address    call	WriteCS	;  Write data in OutCSData    pop   d    ret; Subroutine to write a control store location.WriteCS:	lda   	OutCSData+0		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSa		;  Write it	lda   	OutCSData+1		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSb	lda   	OutCSData+2		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSc	lda   	OutCSData+3		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSd	lda   	OutCSData+4		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSe	lda   	OutCSData+5		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSf	ret;  Subroutine to generate next CS data byte.;  Check bits in Mode to determine whether constant, random, or address data.;  If constant, next data is in Data.;  If random, then next data is random.;  If address, next data is CS address.;  Random number generator simulates an 8-bit feedback shift register with;    equation x8 (MSB) = x4 xor x3 xor x2 xor x0.GetNextCSData:	push d        lda	 Mode		;  Check which data generation algorithm	cpi	 RandomDataVal	jz	DoRandomCSData	; z => random data	cpi	 AddressDataVal	; 	jz	DoAddressCSData	; z => Address data;Constant data.	lda	  ExpectedData		;  Get constant data to be written        mov	d,a			mov	e,a		        jmp DoAddressCSDataDoRandomCSData:	lda   ExpectedData		;  Get last value	add   d              ;[add d and e +11 sta inverse in e]		add   e        adi  11H	sta   ExpectedData		;  Save new value        mov	d,a        cma        mov	e,aDoAddressCSData:	mov	a,d		;  High part.	sta	 OutCSData+0	sta	 OutCSData+2	sta	 OutCSData+4	mov	a,e		;  Low part.	sta	 OutCSData+1	sta	 OutCSData+3	sta	 OutCSData+5	pop d        ret			;  RETURN; Subroutine to check the data in InCSData with OutCSData.;  For CP Rev. B, IOP Rev E, we have to check the following:;	In0	= Out0 (Checks rA, rB);	In1	= Out1 (Checks aS, aF, aD);	In2	= Out2 (Checks EP, CIn, EnSU, mem, fS);	In3	= Out3 (Checks fY, INIA[0:3]);	In4	= Out4 (Checks fX, INIA[4:7]);	In5	= Out5 (Checks fZ, INIA[8:11])CheckCS:	push	b		; Save B, C	push	d		; Save D, E	mvi    e,0   ;COUNT        lxi	h,OutCSData	lxi	b,InCSData+0CheckCS1:        ldax	b	cmp	m	jz	OkCSData        sta ObservedData        mov	a,m	sta ExpectedData	mov	a,e	rlc        rlc        rlc        rlc        ani  070H	mov	e,a	lda StopOnError	ani  8FH	ora   e	sta StopOnError	pop	d		; Restore D, E	xchg			;  Move to HL for store	shld	ExpectedCSLow		shld	ObservedCSlow	        jmp	ExtLogDErrorOkCSData:	inx	h	inx	b	inr     e	mov	a,e	cpi     6        jnz	CheckCS1        pop	d		; Restore D, E	pop	b		; Restore B, C	ret;  Subroutine to wait for Dma complete.CheckCPDmaComplete:   	call ExtTimeDelayCheckCPDmaDone:           in	CPStatus	;  Check for Dma completion in CPStatus Reg.	ani	CPDmaComplMask	jz	ExtLogDMAError	; z => not complete yet        ret     end@


1.1.1.1
log
@first add
@
text
@@
