head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@; Copyright (C) 1980  by Xerox Corporation. All rights reserved. ;  Modification History:;	- Created (June 4, 1980  12:59 PM)	get "SysDefs.asm"	; system defs (tests defs below)        get "MOONLinkDefs.asm"	; Link defs ;  IMPORTS :	IMP	LSEPSetUp,RS232SetUp,LearSSetUp,HOSTSetUp,FSetUp	        JMP	RTCSetUp        JMP	LSEPSetUp        JMP	RS232SetUp        JMP	LearSSetUp        JMP	HOSTSetUp        JMP	FSetUp       ;  Miscellaneous constants.SetTimeWait	equ	0FFFFH	;  Wait value of ~ .4 msec for MPDelayVU0	equ	0000H		;  delay valueDelayVU1	equ	0001H		;  delay valueLocalTime:	db	0,0,0,0		;  32 bits of local timeTime:	db	0,0,0,0		;  32 bits of time read from TOD clockTimeErr:	db	0		;  Time did not compareTest:	db	0		;  StopOnErr:	db	0		;  RTCSetUp:       LXI SP, UserStkStart       mvi a,0       sta TimeErr       call ExtTEIIndexAdd   ; Returns with TestN * 16 + EIBuffer in h and l       mvi e,3       call Modify       ;Returns with TestN * 16 + EIBuffer+x in d and e       lxi	h,LocalTime	       call	RTCMoveIt	       call ExtTEIIndexAdd   ; Returns with TestN * 16 + EIBuffer in h and l       mov	a,m		;  Get low byte       sta Test       inx	h		;  Point to next byte       mov	a,m		;  Get low byte       sta StopOnErr       lda Test       cpi   2       jz   SetIncReadTime        cpi   1       jz   SetReadTime        jmp   ReadTime        retModify:       mvi d,0       dad d                    xchg       retRTCMoveIt:        xchg	mvi	b,4		RTCMoveIt1:	mov	a,m		;  Get low byte	inx	h		;  Point to next byte	xchg	mov	m,a		;  Store	inx	h		;  Point to next byte	dcr	b	rz			;  z => no more bytes	xchg	jmp	RTCMoveIt1Logit:       lda Test       cpi 3       jnz Logit1       lda TimeErr       ani 0FBH       sta TimeErrLogit1:       call ExtTEIIndexAdd   ; Returns with TestN * 16 + EIBuffer in h and l       mvi e,7       call Modify       ;Returns with TestN * 16 + EIBuffer+x in d and e       lxi	h,LocalTime	       xchg       call	RTCMoveIt	       call	RTCMoveIt	       xchg       mvi	b,1       call	RTCMoveIt1	       call ExtMonitorKeyIn         lda   StopOnErr       cpi 0       jnz   RTCSetUp       jmp	ExtMonitorTestDoneReadTime:	out	TODClr		;  Clear TOD interrupt.        call	WaitTODIntr	;  Wait for TOD interrupt	lxi	h,LocalTime		call	ReadTOD	;  Read time into LocalTime[0..3], power-fail to PF        call	WaitTODIntr	;  Wait for TOD interrupt	lxi	h,Time		call	ReadTOD	;  Read time into Time[0..3], power-fail to PF        call	IncrTime		call	CheckTODLocal	;  Compare the two clocks        jmp	LogitSetReadTime:	out	TODClr		;  Clear TOD interrupt.        call	WaitTODIntr	;  Wait for TOD interrupt	call	SetTOD	;  Set the TOD clock (time in LocaTime[0..3])	lxi	h,Time		call	ReadTOD	;  Read time into Time[0..3], power-fail to PF        call	CheckTODLocal	;  Compare the two clocks        jmp	LogitSetIncReadTime:	out	TODClr		;  Clear TOD interrupt.        call	WaitTODIntr	;  Wait for TOD interrupt	call	SetTOD	;  Set the TOD clock (time in SetTime[0..3])	lxi	h,LocalTime		call	ReadTOD	;  Read time into LocalTime[0..3], power-fail to PF        call	WaitTODIntr	;  Wait for TOD interrupt	lxi	h,Time		call	ReadTOD	;  Read time into Time[0..3], power-fail to PF        call	IncrTime		call	CheckTODLocal	;  Compare the two clocks        jmp	Logit;  Subroutine:  WaitTODIntr.;  Wait for a TOD interrupt.;  Clears TOD interrupt before returning.TODIntMaskI	equ	10H	;  Mask for Rev. G and higher IOPWaitTODIntr:    lxi    h,DelayVU0    xchg    lxi    h,DelayVU1Delay:    in	MiscInput1	;  ***Rev G and higher IOP    ani	TODIntMaskI	;  TOD interrupt?    jz	WaitTODIntr1    out	TODClr		;  Clear TOD interrupt.    retWaitTODIntr1:    mvi a,0    dcx  d    cmp e    jnz Delay    cmp d    jnz Delay    cmp l    jnz Delay1    cmp h    jnz Delay1    mvi a,1    lda TimeErr    ori 1    sta TimeErr    jmp LogItDelay1:    dcx  h    jmp Delay ;  Subroutine:  IncrTime.;  Increment the 4-byte time quantity.;  On entry:  H,L points to the least-significant byte.IncrTime:;  Increment number in maintenance panel.	lxi	h,LocalTime+3	;  Point to local clock	mvi	b,3		;  3 high bytes	xra	a		;  Clear carry	mov	a,m		;  Get low byte	adi	1		;  Increment low byte	mov	m,a		;  Store	dcx	h		;  Point to next byteIncrTimeLoop:	mov	a,m		;  Get next byte	aci	0		;  Add carry	mov	m,a		;  Store	dcr	b	rz			;  z => no more bytes	dcx	h		;  Point to next byte	jmp	IncrTimeLoop;  Subroutine:  CheckTODLocal.;  Comparet the time in Time vs. LocalTime.;  Register usage:  H,L - pointer to Time;  	D,E - pointer to LocalTimeCheckTODLocal:	lxi	h,Time	lxi	d,LocalTime	mvi	b,4		;  4 bytesCheckTODLocalLoop:	ldax	d		;  Get LocalTime byte	cmp	m		;  Compare to Time	jnz	TimeByteMismatch	inx	h		;  Point to next bytes	inx	d	dcr	b		;  Last byte?	jnz	CheckTODLocalLoop	retTimeByteMismatch:	lda   TimeErr        ori    2        sta   TimeErr        ret;  Subroutine to read the TOD clock and the power-fail indicator.;  Clock is a 32 bit quantity.;  In addition there is a bit to indicate whether the power had been disconnected;    from the TOD clock..;  Read the 32 bit time into Time (LSB) - Time+3 (MSB), power-fail to PF.;  On entry:   H,L - pointer to data buffer (most sig. byte) for time to be read into.ReadTOD:	mvi	a,ReadTimeMode	out	MiscControl1	;  Set TOD clock to Read Mode	mvi	c,4		;  4 bytes of dataReadTODLoop:	call	ReadTODByte	;  Read data byte, returned in A	mov	m,a		;  Store in Time buffer	inx	h		;  Move pointer	dcr	c		;  last byte?	jnz	ReadTODLoop;  Time has been read into buffer.  Read power fail bit from MiscInput1.	in	MiscInput1	ani	PowerFailedMask	;  Mask out other bits	jz      ReadTODLoop1        lda     TimeErr        ori     4        sta	TimeErr		;  Store in PF;  Clear ReadTime Mode.ReadTODLoop1:	mvi	a,0	out	MiscControl1	;  Set TOD clock to not Read Mode	ret;  Subroutine to read a byte of the TOD clock.;  Assumes the TOD clock is in Read Mode.;  Bits from clock come in true, and most significant bit first.;  Register usage:  B - time data;   		    C - bit counterReadTODByte:	push	b		;  Save B,C	push	d		;  Save D,E	mvi	b,0		;  Clear B	mvi	c,8		;  8 bits in byteReadTODByteLoop:	mov	a,b		;  Shift left partial byte	rlc	mov	b,a		;  Store back in B	in	MiscInput1	;  Read bit	ani	TODDataMask	rlc			;  Align to bit 7 position	rlc	ora	b		;  OR into data byte	mov	b,a		;  Partial back to B; Shift TOD clock shift register	mvi	d,TODRead	;  Mask for TODRead clock	call	DoMiscClock	dcr	c		;  Done all 8 bits?	jnz	ReadTODByteLoop;  TOD data byte in B.  Store in memory.	mov	a,b		;  Return in A	pop	d		;  Restore D,E	pop	b		;  Restore B,C	ret;  Subroutine to set time of day clock.;  This subroutine sets the TOD clock to value in SetTime[0..3].;  Subroutine first clears the TOD clock and then sets each byte of the clock.;  The clock is 32 bits wide, and each byte can be set independently.;   Chunk A:  Bits 24-31 (8 bits) (SetTime);   Chunk B:  Bits 16-23 (8 bits) (SetTime+1);   Chunk C:  Bits 8-15 (8 bits) (SetTime+2);   Chunk D:  Bits 0-7 (8 bits) (SetTime+3)SetTOD:	;  First clear the TOD clock.	mvi	a,SetTimeMode	out	MiscControl1	;  TOD clock to Set Mode	call	Wait	mvi	a,SetTimeMode+ClearTimeMode	out	MiscControl1	;  TOD clock to Set+Clear Mode	mvi	a,SetTimeMode	out	MiscControl1	;  TOD clock to Set Mode;  Set each byte of the counter:	lxi	h,LocalTime+3	;  Point to location Time	mvi	d,TODSetA	;  Initialize clock to byte ASetTODLoop:	mov	b,m		;  Get data value for counter	inr	b		;  Correct so that 0 can be set	call	SetTODByte	;  Set counter byte	dcx	h		;  Point to next Time byte	mov	a,d	rar			;  Form next clock mask	mov	d,a		;  Return to D	cpi	0		;  Check if the last byte was done (mask shifted off)	jnz	SetTODLoop	;  If not, loop for next byte;  Clock is now set.  Release SetTime mode.	mvi	a,0	out	MiscControl1	;  TOD clock to not Set Mode	ret;  Subroutine to set one counter in the TOD clock.;  Assumes that the TOD clock is in SetMode.;  Assumes that the particular counter has been cleared.;  The subroutine counts up the counter to the desired value.;  On entry:;	D has mask of particular SetClk to use;	B has value for counter +1 (so zero can be set).SetTODByte:	jmp	SetTODByteCont	; Jump to counter checkSetTODByteLoop:	call	DoMiscClock	;  D has mask for TOD Set clockSetTODByteCont:	dcr	b		;  Decrement counter	jnz	SetTODByteLoop	ret	DoMiscClock:	mvi	a,0FFH		;  Set all high	xra	d		;  Clear clock bit(s)	out	MiscClocks1		xra	d		;  Toggle bit again	out	MiscClocks1		ret	;  Subroutine to Wait.;  Uses H,L to count down time.;  Delay is:  82 +  27*WaitConst  cycles  ;  	  =  26.24 +  8.64*WaitConst  usec  Wait:	push	h		;  Save H,L	push	psw		;  Save A	lxi	h,SetTimeWait	;  ConstantWaitLoop:	dcx	h	mov	a,l		;  Check low	cpi	0	jnz	WaitLoop	mov	a,h		;  Check high	cpi	0	jnz	WaitLoop	pop	psw		;  Restore A	pop	h		;  Restore H,L	ret	end@


1.1.1.1
log
@first add
@
text
@@
