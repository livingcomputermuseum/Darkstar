head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.22;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.22;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ MODULE = FDCTest.asm found on [Iris]<WMicro>DLion>************************************************************************************************** * * "Pre-boot" Diagnostics for Dandelion Diagnostic Test Package -  Input/Output Processor, 8085 * * Origional edit by J. JxP      on March 4, 1981  11:29 AM * Last edited by J. JxP      on March 9, 1982  6:36 PM * * Dennis DEG     ,  2-Sep-84 15:23:22, Add copyright notice. * * This code tests the FDC (Floppy Disk Controller) and tests portions of the drive unit. * ***************************************************************************************************}{ 	Copyright (C) 1981, 1982 by Xerox Corporation.  All rights reserved.}; Subroutine [FDCTest].		GET	"SysDefs.asm"			GET	"BootDefs.asm"			GET	"BootLinkDefs.asm"	; Imports and Exports		EXP	FDCTest	; To PreBootSource.asm		EXP	TestIndexPulses	; To PreBootSource.asm; Definitions.DiskDrive:	EQU	84H	; Enable controller, Enable WaitsEnableFDC:	EQU	84H	; Enable Waits, Enable controllerEnableFDCD:	EQU	85H	; Enable Waits, Enable controller, Enable DriveEndTrack:	EQU	76	; Number of last track to be doneFDCDiskChange:		EQU	80H	; Disk change status bit.FDCErrorMask:	EQU	79H	; Error Mask for Seek testFDCHLDErrorMask:		EQU	059H	; Error Mask for HLD testFDCIndex:	EQU	2H	; Enable controller, Enable WaitsFDCSeekCmd:	EQU	10H	; Seek command FDCWrtProt:	EQU	40H	; Enable controller, Enable WaitsForceIntCmd:	EQU	0D0H	; ForceInt command HLDCmd:	EQU	10H	; Seek current track, h=0HLDMaskC:	EQU	8H	; Head Load bit mask in commandHLDMask:	EQU	20H	; Head Loaded bit mask in statusJustBlink:	EQU	0FFH	; If C = -1, then blink what's already in panel.loopCount:	EQU	1FFFH	; Loop count for index pulse tries.SA800Disk:	EQU	10H	; Switch setting for SA800 Disk; RAM address Data area. (Starts at 2000)DiskStatusSave:	EQU	FloppyBuf	;DiskStatusReg:	EQU	DiskStatusSave+1	;; Register usage:;		H,L - As noted below.;		D,E - As noted below.;		B,C -  As noted below.;; Initialize.FDCTest:		lda	BootType	; We always get called,				; but see if we should execute this code.		cpi	AltFloppyBoot	;		jz	StartFDCTest	;		cpi	AltDiagFloppyBoot	;		jz	StartFDCTest	;		RET		; If neither type, exit this code!StartFDCTest:		mvi	a,0	; Disable Dma		out	DmaMode; The FDC is disabled/enabled, and then we check that the Restore has been completed after the Reset.; Subroutine to Reset FDC and wait until completion of Restore command.ResetFDC:		mvi	a,DisableFDC	; clear state register, reset FDC, enable Waits		out	FDCState	;		mvi	a,9	; 		call	WaitV	; Wait for more than 50 usec (MR pulse)		mvi	a,EnableFDC	; clear state register, enable FDC, Waits		out	FDCState	;		call	Wait	; Busy status not available for 12 usec		call	ReadFDCStatus	; Read command status; This tests the FDC controller chip without the need for the drive.; Set the Track register to a constant value, and seek all the other tracks.; Seek Test.		call	IncrMPExt	;	#####  0061  #####SeekTest:			; FDC seek test failed.		mvi	c,38	; C has starting Track number		mvi	d,76	; D has desired loop number		mvi	e,FDCSeekCmd	; E has desired command (seek, step,...)SetParam:		mov	a,c	; Set start Track		out	FDCTrack	;		mov	a,d	; Set desired Track		out	FDCData	;		mov	a,e	; Set desired command		out	FDCCommand	; Issue command		call	Wait	;		call	GetFDCStatusB	;; Check for error completion. (Seek error, CRC error, Write Prot., Head loaded)		ani	FDCErrorMask	;SeekError:		jnz	BlinkTheError	;ReadTrack:		in	FDCData	; Read Data register		xra	d	; Seek correct?WrongTrack:		jnz	BlinkTheError	;		call	IncrMPExt	;	#####  0062  #####		mvi	a,EnableFDC	; FDC remained busy after reset.		out	FDCState	; Clear state register, enable FDC, Waits		call	Wait	; Busy status not available for 12 usec		call	GetFDCStatusB	;ClearandReadStatus:		; Clear Floppy Controller and read status.		mvi	b,EnableFDC	;  84H to enable FDC.		call	FDCReset	;		call	ReadFDCStatus	; Read status, A = FDCStatus, B = FDCStatus Reg.				; CAUTION: This is not an INCREMENT.		lxi	h,41H	;	#####  0065  #####		call	PutMPExt	; Disk Change Status fails high.		mov	a,b	;		ani	FDCDiskChange	;		jnz	BlinkTheError				;	#####  0066  #####		call	IncrMPExt	; DMA End Count fails high.		mov	a,b	;		ani	FDCEndCountMask	;		jnz	BlinkTheError				;	#####  0067  #####		call	IncrMPExt	; Two Sided fails high with Floppy Unit not selected..		mov	a,b	;		ani	FDCSide1Mask	;		jnz	BlinkTheError		lda	DiskStatusSave	;		mov	b,a	;				;	#####  0068  #####		call	IncrMPExt	; Ready fails high with Floppy Unit not selected.		mov	a,b	;		ani	FDCNotReady	;		jz	BlinkTheError				;	#####  0069  #####		call	IncrMPExt	; Write Protect fails high with Floppy Unit not selected.		mov	a,b	;		ani	FDCWrtProt	;		jnz	BlinkTheError				;	#####  0070  #####		call	IncrMPExt	; Head Loaded fails high after a Reset.		mov	a,b	;		ani	FDCHeadLoad	;		jnz	BlinkTheError				;	#####  0071  #####		call	IncrMPExt	; Seek Error fails high after a Reset.		mov	a,b	;		ani	FDCSeekError	;		jnz	BlinkTheError				;	#####  0072  #####		call	IncrMPExt	; CRC Error fails high after a Reset.		mov	a,b	;		ani	FDCCRCError	;		jnz	BlinkTheError				;	#####  0073  #####		call	IncrMPExt	; Track 00 fails high with Floppy Unit not selected.		mov	a,b	;		ani	FDCTk0Mask	;		jnz	BlinkTheError				;	#####  0074  #####		call	IncrMPExt	; Index fails high with Floppy Unit not selected.		mov	a,b	;		ani	FDCIndex	;		jnz	BlinkTheError				;	#####  0075  #####		call	IncrMPExt	; Busy fails high after a Reset.		mov	a,b	;		ani	FDCBusyMask	;		jnz	BlinkTheError		call	TestIndexPulses	;EndOfTest:			; Restore, Seek, and Read testing will be done in				; "booting" portion of EPROMS.		RET		; END OF TEST, SUCCESSFUL COMPLETION.; Restore testing will be done in "booting" portion of EPROMS.TestIndexPulses:		xra	a	;		out	DMAMode	; Initialize DMA.		mvi	a,EnableFDCD	; 85H to enable FDC.		mov	b,a	; Save away		call	FDCReset	;; Index pulse test				; CAUTION: This is not an INCREMENT.		lxi	h,51H	;	#####  0081  #####		call	PutMPExt	; Index Pulse fails low.		lxi	d,loopCount	;LowIndex:		call	lessenCounter	;		call	ReadFDCStatus	;		ani	FDCIndex	;		jz	LowIndex	;LowIndexOK:				;	#####  0082  #####		call	IncrMPExt	; Index Pulse fails high.		lxi	d,loopCount	;HighIndex:		call	lessenCounter	;		call 	ReadFDCStatus	;		ani	FDCIndex	;		jnz	HighIndex	;		RET		; Exit TestIndexPulses.lessenCounter:		dcx	d	;		mov	a,d	; 		ora	e	; 		rnz		; That's right you will fall thru if loop count = 0!BlinkTheError:		mvi	c,JustBlink	; UN-SUCCESSFUL COMPLETION!		jmp	ErrorReportExt	; Blink what was last issued to the MP.FDCReset:		mvi	a,DisableFDC	; 80H to Reset FDC.		out	FDCState	;		mvi	a,9	; Wait for more than 50 usec (MR pulse)		call	WaitV	;		mov	a,b	; 84H or 85H to Enable FDC		out	FDCState	;		mvi	a,ForceIntCmd	; Stop the Reset Command.		out	FDCCommand	;		mvi	a,40	;		call	WaitV	; Busy status not available for 12 usec		RET; Command has completed.  Get status.ReadFDCStatus:		call	Wait	; Busy status set 12 usec later		in	FDCStatusReg	; Get external status register. (0E8H)		sta	DiskStatusReg	;		mov	b,a	; Save in B		in	FDCStatus	; Check for restore command completion (084H)		sta	DiskStatusSave	;		RET		; return status in A, external status in BGetFDCStatusB:		in	FDCStatus	;		mov	b,a	; Save away		ani	FDCBusyMask	;		jnz	GetFDCStatusB	;		mov	a,b	;		RET; Wait subroutine; Call at Wait (no A register setup) for delay of ~15.6 us. Call at Wait9 (no A register setup) for delay of ~9.5 us.; Call at WaitV for variable wait:   If (A)        = k, then Delay = 32+ 14k cycles;			         =  10.67 + 4.67k usec at 3MHz CPU;			      k =9 => > 50 us.Wait:		mvi	a,2WaitV:		dcr	a		jnz	WaitVWait9:		RET		END@


1.1.1.1
log
@first add
@
text
@@
