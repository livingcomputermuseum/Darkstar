head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.26;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.26;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{ MODULE = RamProm.asm   [Iris]<WMicro>DLion>RamProm.asm   Last edited by J. JxP      on February 24, 1981  4:18 PM  Dennis DEG      13-Jan-84 18:57:08, stripped Bravo garbage.  Dennis DEG     :  2-Sep-84 15:33:20, add copyright notice.}{ 	Copyright (C) 1981 by Xerox Corporation.  All rights reserved.}		GET	"SysDefs.asm"		GET	"BootDefs.asm"		GET	"BootLinkDefs.asm"AddFour:	EQU	4	; an offset into chip number table.AddEight:	EQU	8	; an offset into chip number table.AddTwelve:	EQU	12	; an offset into chip number table.AddrOffset0:	EQU	2000H	; Starting memory address depending upon which step no.AddrOffset1:	EQU	2001H	; Starting memory address depending upon which step no.AddrOffset2:	EQU	2002H	; Starting memory address depending upon which step no.Bit23Mask:	EQU	0CH	; maskEnableFDC:	EQU	84H	;FirstMemAdr:	EQU	AddrOffset0	; First Memory Address.LowerByte:	EQU	0FH	; mask Length:	EQU	4000H	; storage length Offset:	EQU	3H	; value to increment by.DEBUGSP:	EQU	5A20H	;DEBUGPlaceForMPSP:	EQU	2088H	; To run the MP tests, you must have good ram chips U70 and U101.PlaceForSP:	EQU	8088H	; Paying attention?? These are the FDC Sector and Data registers.UpperByte:	EQU	0F0H	; mask UpperBound:	EQU	60H	; Last address test. Code0000	equ	0000	;Code0001	equ	0001	;Code0002	equ	0002	;Code0003	equ	0003	;Code0004	equ	0004	;Code0005	equ	0005	;Code0006	equ	0006	;Code0007	equ	0007	;Code0008	equ	0008	;Code0009	equ	0009	;Code0010	equ	0010	;Code0020	equ	0020	;Code0030	equ	0030	;Code0040	equ	0040	;Code0050	equ	0050	;Code0060	equ	0060	;Code0070	equ	0070	;Code0080	equ	0080	;Code0090	equ	0090	;Code0100	equ	0100	;Code0200	equ	0200	;Code0300	equ	0300	;Code0400	equ	0400	;Code0500	equ	0500	;Code0600	equ	0600	;Code0700	equ	0700	;Code0800	equ	0800	;Code0900	equ	0900	;Code1000	equ	1000	;Code2000	equ	2000	;Code3000	equ	3000	;Code4000	equ	4000	;Code5000	equ	5000	;Code6000	equ	6000	;Code7000	equ	7000	;Code8000	equ	8000	;Code9000	equ	9000	;Code8888	equ	22B8H	;;ErrorCode600	equ	258H	; 600ErrorCode601	equ	259H	; 601ErrorCode602	equ	25AH	; 602ErrorCode603	equ	25BH	; 603ErrorCode604	equ	25CH	; 604  No bad bits found?? Should not get here.ErrorCode605	equ	25DH	; 605  Memory Address not in range 2000-5FFF?? Should not get here.ErrorCode200	equ	0C8H	; 200ErrorCode205	equ	0CDH	; 205ErrorCode210	equ	0D2H	; 210ErrorCode215	equ	0D7H	; 215ErrorCode220	equ	0DCH	; 220ErrorCode225	equ	0E1H	; 225ErrorCode230	equ	0E6H	; 230ErrorCode235	equ	0EBH	; 235ErrorCode240	equ	0F0H	; 240ErrorCode245	equ	0F5H	; 245ErrorCode250	equ	0FAH	; 250ErrorCode255	equ	0FFH	; 255ErrorCode260	equ	104H	; 260ErrorCode265	equ	109H	; 265ErrorCode270	equ	10EH	; 270ErrorCode275	equ	113H	; 275ErrorCode280	equ	118H	; 280ErrorCode285	equ	11DH	; 285ErrorCode290	equ	122H	; 290ErrorCode295	equ	127H	; 295ErrorCode300	equ	12CH	; 300ErrorCode305	equ	131H	; 305ErrorCode310	equ	136H	; 310ErrorCode315	equ	13BH	; 315ErrorCode320	equ	140H	; 320ErrorCode325	equ	145H	; 325ErrorCode330	equ	14AH	; 330ErrorCode335	equ	14FH	; 335ErrorCode340	equ	154H	; 340ErrorCode345	equ	159H	; 345ErrorCode350	equ	15EH	; 350ErrorCode355	equ	163H	; 355ErrorCode360	equ	168H	; 360ErrorCode365	equ	16DH	; 365ErrorCode370	equ	172H	; 370ErrorCode375	equ	177H	; 375ErrorCode380	equ	17CH	; 380ErrorCode385	equ	181H	; 385ErrorCode390	equ	186H	; 390ErrorCode395	equ	18BH	; 395;;  Boot / Restart location:		org	0000H		;RST 0 - Hardware Reset ONLY				;*** All Interrupts off and maskedRST0:		jmp	Start		; Jump to the Boot code.		org	0010H		;RST 2 - Assembled breakpoint (trap)RST2:		jmp	RST2Error		org	002CH		;RST 5.5 - Burdock or CP Interrupt (trap)RST55:		jmp	RST55Error		org	0034H		;RST 6.5 - RS232C InterruptRST65:		jmp	RST65Error		org	003CH		;RST 7.5 - Floppy InterruptRST75:		jmp	RST75ErrorRST2Error:		lxi	h,ErrorCode600	;	#####  600  #####		call	PutMP	;		HLTRST55Error:		lxi	h,ErrorCode601	;	#####  601  #####		call	PutMP	;		HLTRST65Error:		lxi	h,ErrorCode602	;	#####  602  #####		call	PutMP	;		HLTRST75Error:		lxi	h,ErrorCode603	;	#####  603  #####		call	PutMP	;		HLT;Start:		ei		; Enable Interrupts for mouse halts.;		lxi	sp,DEBUGSP	;  FOR DEBUG.;		nop		;  FOR DEBUG		in	MiscInput1	; See if....		ani	AltBootMask	; user wants to....		jnz	RamPromTest	; Start Memory testing if ALT BOOT button is down.		mvi	a,EnableFDC	;		out	FDCState	;		lxi	sp,PlaceForMPSP	; Establish MPSP.		lxi	h,ErrorCode200	;	#####  200  #####		call	PutMP	;MPTest:		in	MiscInput1	; See if....		ani	AltBootMask	; user wants to....		jz	MPTest	; Start.		lxi	h,ErrorCode205	;	#####  205  #####		call	PutMP	;		mvi	b,0	; Data to be written the following tests.TestTrackLoop:		mov	a,b	;		out	FDCTrack	; Store data in register		xra	a	; Set A to 0.		in	FDCTrack	; Read register		xra	b	;NoTrackComp:		jnz	TestTrackLoop	; Loop if incorrect		dcr	b	; Next data value		jnz	TestTrackLoop	; Zero yet?		lxi	h,ErrorCode210	;	#####  210  #####		call	PutMP	;TestSectorLoop:		mov	a,b	;		out	FDCSector	; Store data in register		xra	a	; Set A to 0.		in	FDCSector	; Read register		xra	b	;NoSectorComp:		jnz	TestSectorLoop	; Loop if incorrect		dcr	b	; Next data value		jnz	TestSectorLoop	; Zero yet?		lxi	h,ErrorCode215	;	#####  215  #####		call	PutMP	;TestDataLoop:		mov	a,b	;		out	FDCData	; Store data in register		xra	a	; Set A to 0.		in	FDCData	; Read register		xra	b	;NoDataComp:		jnz	TestDataLoop	; Loop if incorrect		dcr	b	; Next data value		jnz	TestDataLoop	; Zero yet?			lxi	h,ErrorCode220	;	#####  220  #####		call	PutMP	;ThreeRegAddrTest:		mvi	a,7	;		out	FDCTrack	; Store data in register		mvi	a,5	;		out	FDCSector	; Store data in register		mvi	a,3	;		out	FDCData	; Store data in register		xra	a	; Set A to 0.		in	FDCSector	; Read register		sui	5	;		jnz	ThreeRegAddrTest	; Zero yet?		in	FDCData	; Read register		sui	3	;		jnz	ThreeRegAddrTest	; Zero yet?		in	FDCTrack	; Read register		sui	7	;		jnz	ThreeRegAddrTest	; Zero yet?;		lxi	h,ErrorCode225	;	#####  225  #####		call	PutMP	;ContinueA:			;		in	MiscInput1	; See if....		ani	AltBootMask	; user wants to....		jz	ContinueA	; Start.		lxi	h,Code0001	; 0001		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0002	; 0002		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0003	; 0003		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0004	; 0004		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0005	; 0005		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0006	; 0006		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0007	; 0007		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0008	; 0008		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0009	; 0009		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0010	; 0010		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0020	; 0020		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0030	; 0030		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0040	; 0040		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0050	; 0050		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0060	; 0060		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0070	; 0070		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0080	; 0080		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0090	; 0090		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0100	; 0100		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0200	; 0200		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0300	; 0300		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0400	; 0400		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0500	; 0500		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0600	; 0600		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0700	; 0700		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0800	; 0800		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code0900	; 0900		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code1000	; 1000		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code2000	; 2000		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code3000	; 3000		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code4000	; 4000		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code5000	; 5000		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code6000	; 6000		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code7000	; 7000		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code8000	; 8000		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code9000	; 9000		call	PutMP	;		call	TakeABreak	; wait xx sec		lxi	h,Code8888	; 8888		call	PutMP	;		call	TakeABreak	; wait xx secDebugEntry:			;;		ei		;  FOR DEBUG.;		lxi	sp,DEBUGSP	;  FOR DEBUG.ContinueB:			;		in	MiscInput1	; See if....		ani	AltBootMask	; user wants to....		jz	ContinueB	; Start.RamPromTest:			;		xra	a	; Clear A.		out	DMATestReg	; Initialize error count register.ErrorReEntry:			;		mvi	a,EnableFDC	;		out	FDCState	;		lxi	sp,PlaceForSP	; Establish SP.ContinueC:			;		call	ClearMPanel	; Output 0000ContinueD:			;		call	IncrMP	; Bump MP one.;		lxi	sp,DEBUGSP	;  FOR DEBUG.;		nop		;  FOR DEBUG.		mvi	a,EnableFDC	;		out	FDCState	;		lxi	sp,PlaceForSP	; Re-Establish SP.		in	MiscInput1	; See if....		ani	AltBootMask	; user wants to....		jz	ContinueE	; look at error....		jmp	DisplayErrCnt	; counts in MP.ContinueE:			;		mvi	b,5H	; number of times to write all of RAM.		mvi	c,0H	; Starting contents of byte in C to put in RAM memory.CheckIfDone:			;		dcr	b	; lessen loop count.		mov	a,b	; get and check ...		jm	MainTest	; Are we done?		mov	a,c	; get byte in C for complementing.		cma		; complement it.		mov	c,a	; save byte in C.		lxi	h,Length	; get length in bytes, then ..		xchg		; put H & L into registers D & E.		lxi	h,FirstMemAdr	; get starting address then ..		xra	a	; Clear A for zero check with byte count below.StoreLoop:			;		mov	m,c	; store byte in C in RAM memory.		inx	h	; bump the memory address pointer.		dcx	d	; lessen number of bytes to do.		cmp	e	; Check low part of byte count		jnz	StoreLoop	;		cmp	d	; Check high part of byte count		jnz	StoreLoop	;		jmp	CheckIfDone	; store byte in C in memory.;	B	STEP NUMBER.;	C	PATTERN;	D & E	UNUSED;	H & L	MEMORY ADDRESS.;	A	AS NEEDED.MainTest:		nop		;		mvi	e,0	; Initialize test number register to zero.NextStep:		inr	e	; Increment to next test number.		mov	a,e	;		cpi	1	; Step 1?		jz	Step1	;		cpi	2	; Step 2?		jz	Step2	;		cpi	3	; Step 3?		jz	Step3	;		cpi	4	; Step 4?		jz	Step4	;		cpi	5	; Step 5?		jz	Step5	;		cpi	6	; Step 6?		jz	Step6	;		cpi	7	; Step 7?		jz	Step7	;		cpi	8	; Step 8?		jz	Step8	;		cpi	9	; Step 9?		jz	Step9	;		cpi	0AH	; Step 10?		jz	Step10	;		cpi	0BH	; Step 11?		jz	Step11	;		cpi	0CH	; Step 12?		jz	Step12	;		mvi	a,EnableFDC	;		out	FDCState	;		lxi	sp,PlaceForSP	; Re-Establish SP.		jmp 	ContinueD	; Do it all over again.Step1:			;		lxi	h,AddrOffset1	; Get address to start with.		mvi	d,0	; Store all 0's in memory.		jmp	WriteStep	;Step2:			;		lxi	h,AddrOffset2	; Get address to start with.		mvi	d,0	; Store all 0's in memory.		jmp	WriteStep	;Step3:			;		lxi	h,AddrOffset0	; Get address to start with.		mvi	d,0FFH	; Store all 1's in memory.		jmp	WriteStep	;Step4:			;		lxi	h,AddrOffset1	; Get address to start with.		mvi	d,0	; Read all 0's in memory.		jmp	ReadStep	;Step5:			;		lxi	h,AddrOffset1	; Get address to start with.		mvi	d,0FFH	; Store all 1's in memory.		jmp	WriteStep	;Step6:			;		lxi	h,AddrOffset2	; Get address to start with.		mvi	d,0	; Read all 0's in memory.		jmp	ReadStep	;Step7:			;		lxi	h,AddrOffset0	; Get address to start with.		mvi	d,0FFH	; Read all 1's in memory.		jmp	ReadStep	;Step8:			;		lxi	h,AddrOffset1	; Get address to start with.		mvi	d,0FFH	; Read all 1's in memory.		jmp	ReadStep	;Step9:			;		lxi	h,AddrOffset0	; Get address to start with.		mvi	d,0	; Store all 0's in memory.		jmp	WriteStep	;Step10:			;		lxi	h,AddrOffset0	; Get address to start with.		mvi	d,0	; Read all 0's in memory.		jmp	ReadStep	;Step11:			;		lxi	h,AddrOffset2	; Get address to start with.		mvi	d,0FFH	; Store all 1's in memory.		jmp	WriteStep	;Step12:			;		lxi	h,AddrOffset2	; Get address to start with.		mvi	d,0FFH	; Read all 1's in memory. (Fall thru saves jmp!) ;	C	carries in  pattern to compare with memory.;	H & L	carries in starting memory address.ReadStep:		lxi	sp,Offset	; get offset to add to next memory address.ReadLoop:		mov	a,m	; Read pattern from memory.		xra	d	; Compare with pattern in C.		jnz	Error	; Error?		dad	sp	; Increment pointer to memory position tested.		mov	a,h	;		xri	UpperBound	; Check high part of byte address.		jnz	ReadLoop	; If H is not =/> 60, do it again.;		lxi	sp,DEBUGSP	;  FOR DEBUG.		lxi	sp,PlaceForSP	; Re-Establish SP.		jmp	NextStep	; Done.;	C	carries in  pattern to write in memory.;	H & L	carries in starting memory address.WriteStep:		lxi	sp,Offset	; get offset to add to next memory address.WriteLoop:		mov	m,d	; Store pattern in memory.		dad	sp	; Increment pointer to memory position tested.		mov	a,h	; Increment byte counter.		xri	UpperBound	; Check high part of byte address.		jnz	WriteLoop	; If H is not =/> 60, do it again.		lxi	sp,PlaceForSP	; Re-Establish SP.;		lxi	sp,DEBUGSP	;  FOR DEBUG.		jmp	NextStep	; Done.PutMP:		mvi	a,BlankMPanel	; Blank MP.		out	MiscControl1	;			mvi	d,ClrMPanel	; Mask for ClrMPanel clock		mvi	a,0FFH	; Set all high		xra	d	; Clear clock bit(s)		out	MiscClocks1	;		xra	d	; Toggle bit again		out	MiscClocks1	;		inx	h	; Bias so that a value of zero can be used		jmp	PutMPCheck	;PutMPLoop:		mvi	d,IncMPanel	; Mask for IncMPanel clock		mvi	a,0FFH	; Set all high		xra	d	; Clear clock bit(s)		out	MiscClocks1	;		xra	d	; Toggle bit again		out	MiscClocks1	;PutMPCheck:		xra	a	; Clear A		dcx	h	; Decrement the count		cmp	l	; Check low part for zero		jnz	PutMPLoop	; Not zero => not done yet		cmp	h	; Low part is zero, check high part for zero		jnz	PutMPLoop	; Not zero => not done yet				; Done.		xra	a	; Clear BlankMPanel		out	MiscControl1		ret		; Return;  Subroutine [ClearMPanel].;  Clear the maintenance panel and disable blanking.;ClearMPanel:		mvi	d,ClrMPanel	; Mask for ClrMPanel clock		mvi	a,0FFH	; Set all high		xra	d	; Clear clock bit(s)		out	MiscClocks1	;		xra	d	; Toggle bit again		out	MiscClocks1	;		ret		; Return;  Subroutine [IncrMP].;  Increment the maintenance panel.;IncrMP:		mvi	d,IncMPanel	; Mask for IncMPanel clock		mvi	a,0FFH	; Set all high		xra	d	; Clear clock bit(s)		out	MiscClocks1	;		xra	d	; Toggle bit again		out	MiscClocks1	;		ret		; ReturnError:;		lxi	sp,DEBUGSP	;  FOR DEBUG.		out	FDCTrack	; Now save which bits are bad.		mov	b,h	; Save the....		mov	c,l	; memory address.		in	DmaTestReg	; Get the....		mov	h,a	; error....		inr	h	; bump it one....		mov	a,h	; then....		out	DmaTestReg	; put it back.		jmp	ErrorReEntry	;DisplayErrCnt:		in	DmaTestReg	; Get the....		mov	l,a	; saved....		xra	a	; error count....		mov	h,a	; and....		mvi	a,EnableFDC	;		out	FDCState	;		lxi	sp,PlaceForSP	; Re-Establish SP.		call	PutMP	; display it.DisplayErrCntL:		in	MiscInput1	; If he holds down....		ani	AltBootMask	; the  ALT boot button....		jz	ShowChipNo	; he will be able to see it.		jmp	DisplayErrCntL	;ShowChipNo:		in	DmaTestReg	; Get the error count....		ora	a	; and test if equal to zero.		jz	ErrorReEntry	; If no errors, don't display the chip no.!;		lxi	sp,DEBUGSP	; FOR DEBUG.		in	FDCTrack	; Get the bad bits pattern....		ani	UpperByte	; 		jnz	HighByteDecode	;		in	FDCTrack	; Get the bad bits pattern....		ani	LowerByte	; 		jnz	LowByteDecode	;		jmp	Bad1	; Should NOT get here!HighByteDecode:		lxi	h,HighByteDataTable	;		jmp	Getoffsetintogroup	;LowByteDecode:		lxi	h,LowByteDataTable	;Getoffsetintogroup:		mov	a,b	; 		ani	UpperByte	; 		cpi	20H	;		jz	Group2000	;		cpi	30H	;		jz	Group3000	;		cpi	40H	;		jz	Group4000	;		cpi	50H	;		jz	Group5000	;		jmp	Bad2	; Should NOT get here!Group3000:		lxi	sp,AddFour	; 		jmp	AddItIn	;Group4000:		lxi	sp,AddEight	; 		jmp	AddItIn	;Group5000:		lxi	sp,AddTwelve	; AddItIn:		dad	sp	; Group2000:;		lxi	sp,DEBUGSP	;  FOR DEBUG.		mov	a,b	; Get upper byte of memory address.		ani	Bit23Mask	; Get only....		rrc		; bits....		rrc		; 2 and 3.		mov	c,a	; B & C used to add with.		xra	a	; Clear upper byte for....		mov	b,a	; adding the....		dad	b	; offset to H & L. 		mov	a,m	; Get chip number out of table.		mov	l,a	; Build up H & L to....		xra	a	; display error....		mov	h,a	; code.		jmp	PostIt	; Done!Bad2:			;		lxi	h,ErrorCode605	; 		jmp	PostIt	;Bad1:			;		lxi	h,ErrorCode604	; PostIt:			;		mvi	a,EnableFDC	;		out	FDCState	;		lxi	sp,PlaceForSP	; Re-Establish SP.		call	PutMP	; Display the software error number.BadForever:			;		nop		;		jmp	BadForever	;TakeABreak:		mvi	d,2	; set up loop count.TakeABreakA:		mvi	a,00	; Put 00 in accumulator		lxi	B,9999H	; set b & c to count = to 3 secCountdown1:		dcx	b	; b & c - 1		cmp	b	; compare b to see if it is 00		jz	Countdown2	; if = to 00 go to Low Byte Check		jmp	Countdown1	; Go To CountdownCountdown2:		dcx	b	; b & c - 1		cmp	c	; compare b to see if it is 00		jz	Breakover	; if = to 00 go to Breakover		jmp	Countdown2	; Go To Countdown2Breakover:		dcr	d	; lessen loop count		rm		; Return		jmp	TakeABreakA	; Go To Countdown;HighByteDataTable:		db	46H	; U70		db	45H	; U69		db	44H	; U68		db	43H	; U67		db	42H	; U66		db	41H	; U65		db	40H	; U64		db	3FH	; U63		db	53H	; U83		db	52H	; U82		db	51H	; U81		db	50H	; U80		db	4FH	; U79		db	4EH	; U78		db	4DH	; U77		db	4CH	; U76LowByteDataTable:		db	65H	; U101		db	64H	; U100		db	63H	; U99		db	62H	; U98		db	61H	; U97		db	60H	; U96		db	5FH	; U95		db	5EH	; U94		db	76H	; U118		db	75H	; U117		db	74H	; U116		db	73H	; U115		db	72H	; U114		db	71H	; U113		db	70H	; U112		db	6FH	; U111		END		; The end.@


1.1.1.1
log
@first add
@
text
@@
