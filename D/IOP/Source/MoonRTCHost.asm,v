head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.11;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@; Copyright (C) 1980  by Xerox Corporation. All rights reserved. ;  Modification History:;	- Created (June 4, 1980  12:59 PM)	get "SysDefs.asm"	; system defs (tests defs below)        get "MOONBootDefs.asm"	; system defs (tests defs below)        get "MOONBootLinkDefs.asm"	; system defs (tests defs below)        get "MOONLinkDefs.asm"	; system links         get "MOONSysDefs.asm"	; system defs 		jmp  RTCSetUp        jmp  HOSTSetUp        jmp  MOUSESetUp	jmp DoCSTest5        jmp DoCSTest6OutCSData:	db	0,0,0,0,0,0	;  Write control store data (6 bytes)Mode:LocalTime:	db	0,0,0,0		;  32 bits of local timeTime:	db	0,0,0,0		;  32 bits of time read from TOD clockHost5:	ds	1		;  Least significant byte of addressHost4:	ds	1		;  host address byteHost3:	ds	1		;  host address byteHost2:	ds	1		;  host address byteHost1:	ds	1		;  host address byteHost0:	ds	1		;  Most significant byte of addressCheckSumC:	ds	1		;  Storage for computed checksumCheckSumP:	ds	1		;  Storage for prom checksumnCheckSumP:	ds	1		;  Storage for complemented prom checksumPassCount:	ds	1		RTCSetUp:       mvi a,0       sta ObservedDataReadTime:	out	TODClr		;  Clear TOD interrupt.        call	WaitTODIntr	;  Wait for TOD interrupt	lxi	h,LocalTime		call	ReadTOD	;  Read time into LocalTime[0..3], power-fail to PF        call	WaitTODIntr	;  Wait for TOD interrupt	lxi	h,Time		call	ReadTOD	;  Read time into Time[0..3], power-fail to PF        lxi	h,LocalTime+3		call	IncrTime   		call	CheckTODLocal	;  Compare the two clocksReadDone:        jmp	ExtLogPError;  Subroutine:  WaitTODIntr.;  Wait for a TOD interrupt.;  Clears TOD interrupt before returning.TODIntMaskI	equ	10H	;  Mask for Rev. G and higher IOPWaitTODIntr:    lxi    h,DelayVU0    xchg    lxi    h,DelayVU1Delay:    in	MiscInput1	;  ***Rev G and higher IOP    ani	TODIntMaskI	;  TOD interrupt?    jz	WaitTODIntr1    out	TODClr		;  Clear TOD interrupt.    retWaitTODIntr1:    mvi a,0    dcx  d    cmp e    jnz Delay    cmp d    jnz Delay    cmp l    jnz Delay1    cmp h    jnz Delay1    mvi a,7    sta ObservedData    jmp ReadDoneDelay1:    dcx  h    jmp Delay ;  Subroutine:  IncrTime.;  Increment the 4-byte time quantity.;  On entry:  H,L points to the least-significant byte.IncrTime:;  Increment number in maintenance panel.	mvi	b,3		;  3 high bytes	xra	a		;  Clear carry	mov	a,m		;  Get low byte	adi	1		;  Increment low byte	mov	m,a		;  Store	dcx	h		;  Point to next byteIncrTimeLoop:	mov	a,m		;  Get next byte	aci	0		;  Add carry	mov	m,a		;  Store	dcr	b	rz			;  z => no more bytes	dcx	h		;  Point to next byte	jmp	IncrTimeLoop;  Subroutine:  CheckTODLocal.;  Comparet the time in Time vs. LocalTime.;  Register usage:  H,L - pointer to Time;  	D,E - pointer to LocalTimeCheckTODLocal:	lxi	h,Time	lxi	d,LocalTime	mvi	b,4		;  4 bytesCheckTODLocalLoop:	ldax	d		;  Get LocalTime byte	cmp	m		;  Compare to Time	jnz	TimeByteMismatch	inx	h		;  Point to next bytes	inx	d	dcr	b		;  Last byte?	jnz	CheckTODLocalLoop	retTimeByteMismatch:	mvi   a,7        sta   ObservedData        ret;  Subroutine to read the TOD clock and the power-fail indicator.;  Clock is a 32 bit quantity.;  In addition there is a bit to indicate whether the power had been disconnected;    from the TOD clock..;  Read the 32 bit time into Time (LSB) - Time+3 (MSB), power-fail to PF.;  On entry:   H,L - pointer to data buffer (most sig. byte) for time to be read into.ReadTOD:	mvi	a,ReadTimeMode	out	MiscControl1	;  Set TOD clock to Read Mode	mvi	c,4		;  4 bytes of dataReadTODLoop:	call	ReadTODByte	;  Read data byte, returned in A	mov	m,a		;  Store in Time buffer	inx	h		;  Move pointer	dcr	c		;  last byte?	jnz	ReadTODLoop;  Clear ReadTime Mode.ReadTODLoop1:	mvi	a,0	out	MiscControl1	;  Set TOD clock to not Read Mode	ret;  Subroutine to read a byte of the TOD clock.;  Assumes the TOD clock is in Read Mode.;  Bits from clock come in true, and most significant bit first.;  Register usage:  B - time data;   		    C - bit counterReadTODByte:	push	b		;  Save B,C	push	d		;  Save D,E	mvi	b,0		;  Clear B	mvi	c,8		;  8 bits in byteReadTODByteLoop:	mov	a,b		;  Shift left partial byte	rlc	mov	b,a		;  Store back in B	in	MiscInput1	;  Read bit	ani	TODDataMask	rlc			;  Align to bit 7 position	rlc	ora	b		;  OR into data byte	mov	b,a		;  Partial back to B; Shift TOD clock shift register	mvi	d,TODRead	;  Mask for TODRead clock	call	DoMiscClock	dcr	c		;  Done all 8 bits?	jnz	ReadTODByteLoop;  TOD data byte in B.  Store in memory.	mov	a,b		;  Return in A	pop	d		;  Restore D,E	pop	b		;  Restore B,C	retDoMiscClock:	mvi	a,0FFH		;  Set all high	xra	d		;  Clear clock bit(s)	out	MiscClocks1		xra	d		;  Toggle bit again	out	MiscClocks1		retHOSTSetUp:        mvi a,0        sta ObservedData        mvi a,50        sta PassCount        jmp StartRead              ;  Initialize the checksum algorithm.StartRead:	lxi	h,Host0		;  Point to most significant byte of Host address buffer	lxi	d,8000H+HostAddr	;  Point to the HAddr prom	call	GetHAddrByte	;  Get byte H0	mov	m,a		;  Store in buffer	dcx	h		;  Bump pointer	mov	b,a		;  Save in B	call	GetHAddrByte	;  Get the second byte	mov	m,a		;  Store in buffer	xra	b		;  Checksum ¬ Rot [H0 xor H1]	rlc		sta	ChecksumC	dcx	h		;  Bump pointer	mvi	c,4		;  Count for 4 subsequent bytes of addressReadHAddrLoop:	call	GetHAddrByte	;  Get the next byte	mov	m,a		;  Store in buffer;	lda	ChecksumC	xra	m		;  A ¬ (ChecksumC) xor (next byte)	rlc			;  Rotate checksum	sta	ChecksumC	;  Store partial checksum	dcx	h		;  Point to next byte in buffer	dcr	c		;  Decrement the count	jnz	ReadHAddrLoop		;  nz  => stil more address bytes	call	GetHAddrByte	;  Get the next byte (the prom checksum)	sta	CheckSumP	;  Save	lxi	h,CheckSumC	;  Point to computed checksum	xra	m		;  Compute CheckSumC xor ChecksumP	jz	CheckComplement		;  z => The two checksums agreeBadChecksum:	mvi  a,8     ; Computed checksum disagrees with prom checksum	sta  ObservedData        jmp	ReadDoneCheckComplement:	call	GetHAddrByte	;  Get the next byte (the prom complement checksum)	sta	nCheckSumP	;  Save	cma			;  Complement	xra	m		;  CheckSumC xor Complement(nChecksumP)	jz	ReadAddressDone		;  z => The two checksums agreeBadChecksumCompl:	mvi  a,8 ;Computed checksum disagrees with prom complemented checksum	sta  ObservedData        jmp	ReadDoneReadAddressDone:	lda PassCount        dcr a        sta PassCount        cpi 0        jz  ReadDone        jmp	StartReadMOUSESetUp:       mvi a,0       sta ObservedData       lda  KBFlag       cpi   0       jnz  ExtLogPError        in	MiscInput1	;  ***Rev G and higher IOP       ani	MouseSwMask	       jz      ExtLogPError       mvi a,9              sta ObservedData       jmp	ExtLogPErrorGetHAddrByte:	push	b		;  Save B,C	ldax	d		;  Get low nibble of byte	ani	0FH		;  Mask out garbage in high part of byte	mov	b,a		;  Save in B	inx	d		;  Point to next nibble	ldax	d		;  Get high nibble of byte	ani	0FH		;  Mask out garbage in high part of byte	inx	d		;  Point to next nibble	rlc			;  Move to high part of byte	rlc	rlc	rlc	ora	b		;  Form byte in A	pop	b	ret;  Write TPC.;  On entry:;    TPC address is in C (3 bits right-justified).;    TPC data is in DE (12 bits right-justified).;  Format of TPCHigh (write):  TPCAddr[0:2],,TPCData[0:4]';  Format of TPCLow (write):  don't care,,TPCData[5:11]'WriteTPC:	push	b		;  Save B,C temporarily	call	ExtLeftAlignTPCAddr	; Left align 3 bits of address in C	ori 0        mov	a,e		;  Move TPC[4] into B for TPCHigh format	ral			;  TPC[4] into carry	mov	a,d		;  get high part	ral			;  TPC[4] into B[7]	cma			;  complement for port	ani	1FH		;  Clear High 3 bits	ora	c		;  OR in address	out	TPCHigh	;  Set address, high data	mov	a,e		;  Get low part (C[0] is don't care)	cma			;  complement for port	out	TPCLow	;  send low data, Write TPC	pop	b	retDoCSTest5:    mvi a,0    sta	 OutCSData+0    sta	 OutCSData+1    mvi a,4    sta	 OutCSData+2    mvi a,80H    sta	 OutCSData+3    sta	 OutCSData+4    sta	 OutCSData+5    jmp CSTestDoCSTest6:    mvi a,0FFH    sta	 OutCSData+0    sta	 OutCSData+1    sta	 OutCSData+2    sta	 OutCSData+3    sta	 OutCSData+4    sta	 OutCSData+5    jmp CSTest;  Control Store Test.;  This test writes control store with varying data, and then reads and checks the data.;  The type of data written depends on flags in Mode.;     Constant, Random:  Each CS location has the same byte repeated 6 times.;     Address in location:  Each CS location has the its address repeated 3 times.;  TPC register 6 is used to write/read the control store.;  Conventions:  C  contains the TPC address (3 bits right-justified);	          DE  contains the TPC data (12 bits right-justified)CSTest:	mvi	a,60H	;  Use TPC address 6	NextTPCAddr:	sta	 Task        lxi	d,0	;  start with minimum addressNextCSWrite:	call	GetNextCSData	;  Data stored in OutCSData array	call	WriteTPC ;  Write the TPC slot with the control store address	call	WriteCS	;  Write data in OutCSData	inx	d		;  Increment CSAddress	mov	a,d		;  Check for CSAddress greater than 4095	ani	1			cnz      CheckKeyboard        mov	a,d		;  Check for CSAddress greater than 4095        ani	0F0H		;  Check high part	jz	NextCSWrite	;  Do next CS address;  Finished writing control store.  Do read/checks.	lxi	d,0	;  start with minimum addressNextCSRead:        call	GetNextCSData	;  Data stored in OutCSData array	call	WriteTPC	;  Write the TPC slot with the control store address	call	ExtReadCS	;  Read data into InCSData	call	CheckCS	;  Check data (breakpoints if error)IncCSAddr:	inx	d		;  Increment CSAddress	mov	a,d		;  Check for CSAddress greater than 4095	ani	1			cnz      CheckKeyboard        mov	a,d		;  Check for CSAddress greater than 4095        ani	0F0H		;  Check high part	jz	NextCSRead	;  Do next CS address        mvi	a,70H			sta	 Task        jmp   ExtDoInstTest        CheckKeyboard:    push d    push h    call ExtMonitorKeyIn	    pop   h    pop   d    ret; Subroutine to write a control store location.WriteCS:	lda   	OutCSData+0		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSa		;  Write it	lda   	OutCSData+1		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSb	lda   	OutCSData+2		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSc	lda   	OutCSData+3		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSd	lda   	OutCSData+4		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSe	lda   	OutCSData+5		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSf	ret;  Subroutine to generate next CS data byte.;  Check bits in Mode to determine whether constant, random, or address data.;  If constant, next data is in Data.;  If random, then next data is random.;  If address, next data is CS address.;  Random number generator simulates an 8-bit feedback shift register with;    equation x8 (MSB) = x4 xor x3 xor x2 xor x0.GetNextCSData:	push d        inx d        mov    a,d	ani    0FH        mov    d,a	lda	 OutCSData+3	ani    0F0H        ora    d        sta	 OutCSData+3	mov    a,e	ani    0F0H        rrc        rrc        rrc        rrc        ani    0FH        mov    d,a	lda	 OutCSData+4	ani    0F0H        ora    d        sta	 OutCSData+4        mov    a,e	ani    0FH        mov    d,a	lda	 OutCSData+5	ani    0F0H        ora    d        sta	 OutCSData+5        lda    OutCSData+0		mov    e,a	lda    OutCSData+1		xra    e        mov    e,a        lda    OutCSData+5		xra    e        mov    e,a        lda    OutCSData+3		xra    e        mov    e,a        lda    OutCSData+4		xra    e        mov    e,a        lda    OutCSData+2		ani    7FH        sta    OutCSData+2        xra    e        sta  ExpectedData        mvi    e,8Parity:         lda  ExpectedData        rlc        sta  ExpectedData        jc    SetParityParity1:         dcr e        jnz   Parity        pop d        ret			;  RETURNSetParity:        lda    OutCSData+2	        xri 80H        sta    OutCSData+2        jmp   Parity1; Subroutine to check the data in InCSData with OutCSData.;  For CP Rev. B, IOP Rev E, we have to check the following:;	In0	= Out0 (Checks rA, rB);	In1	= Out1 (Checks aS, aF, aD);	In2	= Out2 (Checks EP, CIn, EnSU, mem, fS);	In3	= Out3 (Checks fY, INIA[0:3]);	In4	= Out4 (Checks fX, INIA[4:7]);	In5	= Out5 (Checks fZ, INIA[8:11])CheckCS:	push	b		; Save B, C	push	d		; Save D, E	mvi    e,0   ;COUNT        lxi	h,OutCSData	lxi	b,InCSData+0CheckCS1:        ldax	b	cmp	m	jz	OkCSData        sta ObservedData        mov	a,m	sta ExpectedData	mov	a,e	pop	d		; Restore D, E	xchg			;  Move to HL for store	rlc        rlc        rlc        rlc        ani  0F0H        ora     h        mov	h,a	shld	ExpectedCSLow		shld	ObservedCSlow	        jmp	ExtLogDErrorOkCSData:	inx	h	inx	b	inr     e	mov	a,e	cpi     6        jnz	CheckCS1        pop	d		; Restore D, E	pop	b		; Restore B, C	ret	end@


1.1.1.1
log
@first add
@
text
@@
