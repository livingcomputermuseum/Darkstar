head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.06;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.06;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@; Copyright (C) 1980  by Xerox Corporation. All rights reserved. ;  Last modification by ;  Modification History:;	- Created (June 4, 1980  12:59 PM)	get "SysDefs.asm"	; system defs (tests defs below)        get "MOONBootDefs.asm"	; system defs (tests defs below)        get "MOONBootLinkDefs.asm"	; system defs (tests defs below)        get "MOONLinkDefs.asm"	; system links         get "MOONSysDefs.asm"	; system defs         ;-----------------------------------------------------------------         jmp Start         jmp MonitorSt         jmp StartCP         jmp StopCP         jmp DoInstructionTest2         jmp StartDelay         jmp MonitorSetP         jmp MonitorTestDone         jmp LogTPCError         jmp LogDError         jmp LogDMAError         jmp LogPError         jmp AltBoot         jmp ShowError         jmp   GetNextTest         jmp   DoInstructionTest         jmp Delay;-----------------------------------------------------------------         jmp MPNumber         jmp TimeDelay         jmp MDisplay         jmp ReadKBByte         jmp ReadCPport         jmp WriteCPport         jmp DisableDma         jmp ReadTPC         jmp ReadCS         jmp Wait         jmp MonitorKeyIn         jmp MPNumber2         jmp BlankIt         jmp LeftAlignTPCAddr         jmp MonitorSTOP         jmp MPNumberCall;-----------------------------------------------------------------	jmp EITestLoop        jmp TEIIndexAdd        jmp EIReport        jmp EIAccu        jmp EIDFault        jmp EIShowTest        jmp EIConfiguer        jmp EIAccuH	jmp Phase1Entry	ALow	equ	0FFFH		 ;  Control store addressJump   db 0 JFile   db 0 JTest   db 0 ;---------------- START of Program -------------------------;  Initialize.Start1:	di        call    DisableDma         mvi	a,DisableFDC	; Disable floppy controller, Enable Waits	out	FDCState	call	StopCP ;Ensure that IOPWait = SwTAddr = 1 (should be after boot).	mvi	a,0FFH		;  Set all clock bits high	out	MiscClocks1	        retStartB:    LXI SP, UserStkStart    call MoveIt    call BootInitExt    mvi a,0    sta BootType    sta BootDevice    sta LoopCStart:    LXI SP, UserStkStart    call Start1    mvi	a,3H		;  Set CPstoped and BootMode    sta   BootFlags	    lda DiagBoot    sta  DiagBootS    cpi	   MonitorP    jz	   MonitorReStart    lda Jump    cpi	  0    jz Start2    mvi a,0    sta Jump    lda JTest    sta TestNI    sta TestNE    mvi a,1    sta TestLoop    jmp	  MonitorStStart2:    lda    CFBoot    sui	   UtilP    jp	   MonitorSetPMonitorSt:   LXI SP, UserStkStart   call Start1   lda TestNI   sta TestN   jmp CommandLoopMonitorReStart:   lda LoopIn   cpi 0   jnz   MonitorSt   lda BootDevice   cpi	   MLoad   jz	   MonitorBurdockMonitorIO:   jmp SetDiagBootFMonitorBurdock:   BREAK   jmp  MonitorSt   MonitorTestDone:	   lda CFBoot   cpi MemP   jz   ExtAFault   call TEIIndexAdd   ; Returns with TestN * 8/16/32 + EIBuffer in h and l   mvi e,0FH   lda CFBoot   sui UtilP   jp   GotErrorAdd   mvi e,07HGotErrorAdd:	   mvi d,0   dad d             ; Should have TestN * 16 + EIBuffer +15 = Fault reg   mov a,m   sta  ExtFAULTShowError:	   lda TestN   call  MPNumber   call MonitorKeyIn   lda CFBoot   sui UtilP   jp   NotKeyBoard   lda StopOnError   ani  1   jnz StartAgain   lda TestN   cpi  1   jnz NotKeyBoard   call CheckForLoopBack NotKeyBoard:	   lda SkipF   cpi  0   jnz MonitorSkip   lda IFlag   cpi 0   jnz IndexM   lda ExtFAULT   cpi 0   jz   CkTestLoop   lda ExtFAULT   call MDisplay   call MonitorKeyIn   call  BlankIt   call MonitorKeyInCkLoopIn:	   lda IgNor   cpi  0   jz MonitorTestDoneCkTestLoop:   lda TestLoop   cpi  0   jnz StartAgainGetNextTest:   lda TestNE   mov e,a   lda TestN   cmp e   jnz IncTestNAllTestDone:   jmp	   MonitorReStartIncTestN:   lda TestN   inr a   sta TestNStartAgain:   LXI SP, UserStkStart   lda CFBoot   sui UtilP   jp   EITestLoop   jmp CommandLoopMonitorSkip:   mvi	a,0   sta SkipF   jmp GetNextTestCheckForLoopBack:   call AltBoot   lda  SkipF   cpi  0   rz     mvi  a,MPSetLoop2   sta   SkipF   call  MPNumber   call  TimeDelay   call AltBoot   lda  SkipF   cpi  1   rz     jmp ExtLoopbacktest     SetDiagBootF:   lda DiagBootS   cpi MonitorP   jnz NotInitialBoot   mvi  a,BootP3   sta DiagBootN   sta DFaultF   lda BootType   cpi	   FLoad   jnz   NotInitialBoot   mvi  a,DiskP   sta AFlag   sta DiagBootNNotInitialBoot:   lda DiagBootN   mov e,a   lda DiagBootS   cmp e   jz BootDoneIncFile:   adi   1   jmp  GetIndex   BootDone:   lda LoopC   cpi 0   jnz   LoopOnFile   lda DFaultF   cpi 0   jnz  SetMesaP   jmp   MonitorSetP   LoopOnFile:   mvi a,0   sta LoopIn   sta TestLoop   sta IgNor   lda  DiagBootI   jmp  GetIndex   GetIndex:   sta  DiagBootSGetNewFile:   call BootInitExt   lda DiagBootSSetBFilePointer:   sta  DiagBoot   jmp  DoBootPhaseExtMonitorSetP:   mvi  a,MPSetLoop0   call  MPNumber   lda DFaultF   cpi  0   jnz EIDFault	   call MonitorKeyIn   lda KBbuffer   cpi  KA   jz   SetMesaP    cpi  KB   jz   SetBootP    cpi  KU   jz   SetUtilP    cpi  KP   jz   SetPrintP    cpi  KW   jz   SetMagP        cpi  KM   jz   SetMemP    cpi  KD   jz   SetDiskP   cpi  KE   jz   EnterFiles   cpi  KS   jz EIConfiguer    cpi KC   jnz  CkJump   lda Conf   sta  AccuReg   call  EIAccuH   lda  AccuReg   sta Conf   lda MemSize   sta  AccuReg   call  EIAccuH   lda  AccuReg   sta MemSize   lda MemSize1   sta  AccuReg   call  EIAccuH   lda  AccuReg   sta MemSize1   jmp NoMatchCkJump:       cpi KJ   jnz  NoMatch   lda JFile   sta  AccuReg   call  EIAccu   lda AccuReg   sta  JFile   lda JTest   sta  AccuReg   call  EIAccu   lda AccuReg   sta  JTest   mvi a,1    sta  Jump   jmp SetJFileNoMatch:       cpi KI   jz  MonitorSt   call TimeDelay   jmp MonitorSetPEnterFiles:       call  BlankIt   lda DiagBootI   sta  AccuReg   call EIAccu   lda AccuReg   sta  DiagBootI   call  BlankIt   lda DiagBootN   sta  AccuReg   call EIAccu   lda AccuReg   sta  DiagBootN   jmp  LoopOnFileSetBootP:    mvi a,BootP    sta DiagBootI    mvi a,BootP3SetLastFile:    sta DiagBootN    jmp  LoopOnFileSetMesaP:    mvi a,0    jmp SetEIFile      SetJFile:    lda JFile    cpi 3    jnz CkEIFile    mvi c,BootP    lda JTest    sui 13    jm SetJBFile    inr c    sui 4    jm SetJBFile    inr c    sui 3    jm SetJBFile    inr cSetJBFile:    lda DiagBootS    cmp c    jz Start    mov a,c    jmp SetEIFileCkEIFile:    mvi c,UtilP    cpi 4    jz SetJBFile    mvi c,MemP    cpi 6    jz SetJBFile    mvi c,DiskP    cpi 7    jz SetJBFile    mvi c,PrintP    cpi 8    jz SetJBFile    mvi c,MagP    cpi 19    jz SetJBFile    jmp NoMatchSetMemP:    mvi a,MemP    jmp SetEIFileSetUtilP:    mvi a,UtilP    jmp SetEIFileSetPrintP:    mvi a,PrintP    jmp SetEIFileSetMagP:    mvi a,MagP    jmp SetEIFile    SetDiskP:    mvi a,DiskPSetEIFile:    sta DiagBootI    jmp  SetLastFile Phase1Entry:   call  StopCP   mvi  a,1   sta  Phase   mvi a,0   sta DiagBoot    sta  BootSource   call  SetMCSBuffer   shld  BootAddrIOP   lxi h,Phase1EntryRet   shld  StartIOPAddress   jmp  DoBootPhaseExtPhase1EntryRet:   di   lda DiagBootS    sta DiagBoot    lda TestN   call    MPNumber   ret SetMCSBuffer:    lxi h,ExtUtility    lda    CFBoot    cpi	   UtilP    rz   	       lxi h,ExtMem    cpi	   MemP    rz   	       lxi h,ExtDisk    cpi	   DiskP    rz   	       lxi h,ExtPrint    cpi	   PrintP    rz          lxi h,ExtMag    cpi	   MagP    rz       lda    TestN    lxi h,ExtInBrA    cpi	   InBrA    rz	       lxi h,ExtInBrC    cpi	   InBrC    rz	       lxi h,ExtInPI    cpi	   InPI    rz	       cpi	   InPIDma    rz	       lxi h,ExtInPO    cpi	   InPO    rz	       cpi	   InPODma    rz	       lxi h,ExtInSun1    cpi	   InSun1    rz	       lxi h,ExtInSun2    cpi	   InSun2    rz	       lxi h,ExtInSun3    cpi	   InSun3    rz	       lxi h,ExtInSun4    cpi	   InSun4    rz	       lxi h,ExtInSun5    cpi	   InSun5    rz	       lxi h,ExtInMem    cpi	   InMem    rz	       lxi h,ExtInCur    cpi	   InCur    rz	       lxi h,ExtInCyc    cpi	   InCyc    rz	       lxi h,ExtInTC    cpi	   InTC    rz	       lxi h,ExtInEith    cpi	   InEith    rz	       lxi h,ExtInCS    cpi	   InCS0    rz    cpi	 InCS1    rz	       lxi h,ExtInCSBank     ret       ;  Main command loop.CommandLoop:    call MonitorKeyIn    mvi a, MaxTPCAddr    sta  Task    lda    CFBoot    sui	   UtilP    jp	   EICmd    call    TEIIndexAdd    mov	a,m		;  Get low byte    ani 80H    jnz   GetNextTest    lda TestN    call    MPNumber    lda    TestN    cpi	   KBT    jz	   ExtTTYInit    cpi	   CSCDTO    jz	   ExtDoCSTest2    cpi	   CSCDTZ    jz	   ExtDoCSTest1    cpi	   TPCDT    jz	   ExtTPCTest    cpi	   CSADT    jz	   ExtDoCSTest3    cpi	   CSRDT    jz	   ExtDoCSTest4    cpi	   InRTC    jz	   EiExtR    cpi	   InHost    jz	   EiExtH    cpi	   InCS0    jz	   ExtDoCSTest5    cpi	   InCS1    jz	   ExtDoCSTest6    cpi	   InMouse    jz	   EiExtM    cpi	   InCSBank    jz	   ExtCSBank    sui 29    jp    ExtCSTestDoInstructionTest:    call Phase1Entry    lda TestN    cpi	   InPIDma    jz	   ExtPortInDma    call StartCP    lda TestN    cpi	   InPI    jz	   ExtPortIn    cpi	   InPO    jz	   ExtPortIn    cpi	   InPODma    jz	   ExtPortOutDma    cpi	   InCS0    jz	   DoInstructionTest3    cpi	   InCS1    jz	   DoInstructionTest3    sui	  LastKTaskN    jm  DoInstructionTest3    mvi  a,0    sta   Task    call ConfPortOut  ; Pass one byte of configuation to the cpDoInstructionTest3:    call ProgramDelayDoInstructionTest2:    call StopCP         ; Stop CP.    call ReadTPC  ; Check that CP task 0 or 7, inst address is at noerror branch.    lda TestN    cpi  InCur    jz   InstDone     lxi h,ALow      shld ExpectedCSLow    lda ObservedCSlow    xra  l    jnz LogTPCError    lda ObservedCSHigh    xra h    jnz LogTPCErrorInstDone:     mvi  a,0    jmp CleanUpEICmd:    call Phase1Entry    call StartCP  ; Start CP and wait for inst to compleat.    jmp    EITestLoopLogTPCError:       mvi      a,2       jmp      CleanUpLogDError:       mvi      a,1       jmp      CleanUpLogDMAError:       mvi      a,3       jmp      CleanUpLogPError:       lda TestN       cpi  InSun4       rz           lda      ObservedDataCleanUp:       sta      Fault       LXI SP, UserStkStart       call	Start1MLogit:       call TEIIndexAdd   ; Returns with TestN * 16 + EIBuffer in h and l       mov	a,m		;  Get  byte       ani      8FH       mov	b,a		;       lda      StopOnError       ani      70H       ora      b       sta      StopOnError       xchg       lxi	h,StopOnError	       mvi	b,8		MMoveIt:	mov	a,m		;  Get low byte	inx	h		;  Point to next byte	xchg	mov	m,a		;  Store	inx	h		;  Point to next byte	dcr	b	jz	MonitorTestDone	xchg	jmp	MMoveIt    AltBoot:     in MiscInput1     ani 80H     jz  AltRet     mvi a,1     sta   SkipFAltRet: ret   ; Will set Error to zero if alt is pressedStartCP:     in CPIn    mvi a,CPWait    out CPControl    mvi a, CPEnable    out CPControl    call StartDelay    retStopCP:     in CPIn    mvi a,CPWait    out CPControl    mvi a, CPWaitSwT    out CPControl    retConfPortOut:	lda TestN        cpi  InMem        jnz  ConfPortOut1	lda    Conf	rrc	ani 80H	mov e,a	lda    MemSize1	ora  e        jmp  ConfPortOut2ConfPortOut1:        lda    ConfConfPortOut2:        call	WriteCPport        mvi  a,6        sta  ObservedData        in	CPStatus     ;  Check for error condition (CPAttn).	ani	CPAttnMask	jz	LogPError		;  (CPAttn inactive)        lda TestN        cpi  InSun4        rnz            call ProgramDelay	call	ReadCPport	;  Get data from port        sta    Conf        mvi  a,0        sta    MemSize        call	ReadCPport	;  Get data from port        sta    MemSize1        ret   ProgramDelay:    lxi    h,DelayVU7    xchg    lxi    h,DelayVU0    lda TestN    cpi   InMem    jnz   SetDelay1    lxi    h,DelayVU3    lda MemSize1    cpi 0MemDelay:    jz SetDelay1    inr l    inr l    inr l    inr l     dcr a    jmp MemDelaySetDelay1:    cpi   InCur    jnz   Delay    lxi    h,DelayVU2Delay:    mvi a,0    dcx  d    cmp e    jnz Delay    cmp d    jnz Delay    cmp l    jnz Delay1    cmp h    jnz Delay1    retDelay1:    dcx  h    push   d    push   h    call MonitorKeyIn    pop   h    pop   d    jmp Delay         StartDelay:    mvi a,0FHStartDelay1:    dcr a    jnz StartDelay1    ret ;  On entry: ;    TPC address is in Task (3 bits right-justified). ;  On exit: ;    TPC data is in DE (12 bits right-justified). ;  Format of bytes with TPCdata: ;	CS6: TC[0:3],,TPCdata[0:3]'  ;	CS7: TPCdata[4:11]'  ;  Have to set TPCAddress before read.ReadTPC:	push d        call	LeftAlignTPCAddr	; Left align 3 bits of address in C        out	TPCHigh	in	CS6		;  Separate TPCdata[0:3]	cma			;  complement	ani  0FH        mov	d,a		;  High part to D	in	CS7		;  separate  TPCData[4:11]	cma			;  complement	mov	e,a		;  low part to E	xchg			;  Move to HL for store	shld	ObservedCSlow	;  Store returned data in TPC data area	pop  d        ret		;  Left align TPC address in C.LeftAlignTPCAddr:	ori 0        lda Task	;  Set up C with TPC address	rlc	mov	c,a	ret			;  Write TPC.;  On entry:;    TPC address is in C (3 bits right-justified).;    TPC data is in DE (12 bits right-justified).;  Format of TPCHigh (write):  TPCAddr[0:2],,TPCData[0:4]';  Format of TPCLow (write):  don't care,,TPCData[5:11]';  Subroutine to read 6 bytes which contain CS data (to be extracted).;  Assumes that TPC has been set up correctly.;  The "instruction" is read into InCSData,ReadCS:	in	MiscClocks1	;  ***PreCharge The iopdata buss For testing        in	CS0	sta	InCSData+0	in	CS1	sta	InCSData+1	in	CS2	sta	InCSData+2	in	CS3	sta	InCSData+3	in	CS4	sta	InCSData+4	in	CS5	sta	InCSData+5	ret				;  Read CP port.ReadCPport:	mvi  a,4        sta  ObservedData        call StartDelay        in	CPStatus	;  Read the port interrupt bits	ani	CPInIntMask	;  CPIn requesting an interrupt? 	jz	LogPError		;  Zero means no interrupt	in	CPIn		;  get data	ret		;  Write CPport.WriteCPport:	out	CPOut		;  Output dataWaitCPOutAck:	mvi  a,5        sta  ObservedData        call StartDelay        in	CPStatus	;  Read the port interrupt bits	ani	CPOutIntMask	;  CPOut requesting an interrupt 	jz	LogPError		;  Zero means no interrupt	ret	DisableDma:    mvi	a,0		;  Disable Dma controller	out	DmaMode	out	CPDmaClr	;  Clear CPDmaComplete	ret	ReadTTY:	call	WaitTTYReq	;  Wait for byte from keyboard	jnz	ReadTTYRet	;  TTY request is active low	call	ReadTTYByte	;  Get byte from keyboard (returned in A)	cpi 0        jnz ReadTTY1        mvi a,78HReadTTY1:        sta  	KBBuffer		;  Store away.        call	Send1         ReadTTYRet:	ret	Send1:	call    Wait        IN	IntReq		; Watch Condition of USART	ANI	PtrTxReqMask	IN	PrinterStatus	; Check Error	LDA	KBBuffer	OUT	PrinterData		; Data Send	RET		WaitTTYReq:	IN	IntReq		; Watch Condition of USART	ANI	PtrRxReqMask	ret	ReadTTYByte:	IN	PrinterStatus	; Check Error	ANI	TTYERROR	JNZ	ErrorProc	IN	PrinterData		; Data Receive	RET	ErrorProc:	MVI	A,Enable+ErrRst	; Error Reset UART	OUT	PrinterCommand	MVI	A,Enable	OUT	PrinterCommand	RET						ReadKB:	mvi  a,0        sta   KBBuffer        lda  KBFlag        cpi   0        jnz  ReadTTY        call	WaitKBReq	;  Wait for byte from keyboard	jnz	ReadKBRet	;  KB request is active low	call	ReadKBByte	;  Get byte from keyboard (returned in A)	sta  	KBBuffer		;  Store away.ReadKBRet:	ret		;  Subroutine to CHECK for a request from the keyboard.WaitKBReq:	in	IntReq		;  Read interupt port	ani	KBReqMask	;  KB request?	ret		;  Subroutine to read one byte from the keyboard.	;  Assumes that the data is ready in the keyboard (i.e. KBReq is active).  ReadKBByte:	xra	a		;  Set all bits low	xri	pReadKBData	;  Keyboard data latch clock bit high (RevG)	out	MiscControl1		call	Wait		;  Wait 50 usec	xri	pReadKBData	;  Keyboard data latch clock bit low (RevG)	out	MiscControl1	;  Keyboard data is latched		in	KBData	;  Read in data from latch	cma			;  Comes in complemented	ret			;  Subroutine to Wait.	;  Uses H,L to count down time.	;  Delay is:  82 +  27*WaitConst  cycles  	;  	  =  26.24 +  8.64*WaitConst  usec  Wait:	push	h		;  Save H,L	push	psw		;  Save A	lhld	WaitConst	;  ConstantWaitLoop:	dcx	h	mov	a,l		;  Check low	cpi	0	jnz	WaitLoop	mov	a,h		;  Check high	cpi	0	jnz	WaitLoop	pop	psw		;  Restore A	pop	h		;  Restore H,L	ret  MonitorKeyIn:   call AltBoot   call ReadKB   lda  KBFlag   cpi  0   jz   MonitorKeyIn0   call MonitorExcMonitorKeyIn0:   lda  KBBuffer   cpi KSTOP   jnz  MonitorKeyIn1MonitorSTOP:   LXI SP, UserStkStart   call  StopCP   lda  AInPF   cpi 0   jz  MonitorSTOP1   call  ExtARestoreMonitorSTOP1:   lda DiagBootS   sta DiagBootN   mvi a,0   sta  AInPF   sta  IFlag   sta  AFlag   sta DFaultF   sta Hex   jmp  MonitorSetPMonitorKeyIn1:   cpi KR   jz  EIReport   cpi KT   jz  EIShowTestComKey:   cpi KL   jnz  ComKey1   lda  TestLoop   xri  1   sta  TestLoopComKey1:   cpi KSTN   jnz  ComKey2   sta  SkipFComKey2:   cpi KN   jnz  ComKey3   lda  LoopIn   xri  1   sta  LoopInComKey3:   cpi KO   jnz  ComKey4   lda  IgNor   xri  1   sta  IgNorComKey4:   cpi KY   jnz  ComKey5   lda  LoopC   xri  1   sta  LoopCComKey5:   cpi KK   jnz  ComKey6   lda  CFBoot   cpi  MemP   rnz     jmp  ExtAShowErrorsComKey6:   cpi KQ   jnz  ComKey7      sta  AFlag   lda  CFBoot   cpi  MemP   Cz  ExtAClrLogComKey7:   cpi KZ   rnz   call  BlankIt   LXI  H,0   LXI  D,128   lda MemSize1   cpi  0FEH   JZ   ComKey7B    INR  AComKey7A:   DAD  d   dcr  a   jnz  ComKey7AComKey7B:   call  MPNumberCall   call TimeDelay   ret      MDisplay:    push psw    call BlankIt    pop psw    call  MPNumber2    ret   BlankIt:    call TimeDelay    mvi	a,BlankMPanel	;  Blank MP    out	MiscControl1    call TimeDelay    ret   MonitorExc:   lda  KBBuffer   mvi  c,KSTOP   cpi  TX   jz  MonitorExcRet   mvi  c,KSTN   cpi  TCONTINUE   jz  MonitorExcRet   mvi  c,KA   cpi  TA   jz  MonitorExcRet   mvi  c,KB   cpi  TB   jz  MonitorExcRet   mvi  c,KC   cpi  TC   jz  MonitorExcRet   mvi  c,KD   cpi  TD   jz  MonitorExcRet   mvi  c,KE   cpi  TE   jz  MonitorExcRet   mvi  c,KF   cpi  TF   jz  MonitorExcRet   mvi  c,KI   cpi  TI   jz  MonitorExcRet   mvi  c,KJ   cpi  TJ   jz  MonitorExcRet   mvi  c,KK   cpi  TK   jz  MonitorExcRet   mvi  c,KL   cpi  TL   jz  MonitorExcRet   mvi  c,KM   cpi  TM   jz  MonitorExcRet   mvi  c,KN   cpi  TN   jz  MonitorExcRet   mvi  c,KO   cpi  TO   jz  MonitorExcRet   mvi  c,KP   cpi  TP   jz  MonitorExcRet   mvi  c,KQ   cpi  TQ   jz  MonitorExcRet   mvi  c,KR   cpi  TR   jz  MonitorExcRet   mvi  c,KS   cpi  TS   jz  MonitorExcRet   mvi  c,KT   cpi  TT   jz  MonitorExcRet   mvi  c,KU   cpi  TU   jz  MonitorExcRet   mvi  c,KV   cpi  TV   jz  MonitorExcRet   mvi  c,KW   cpi  TW   jz  MonitorExcRet   mvi  c,KY   cpi  TY   jz  MonitorExcRet   mvi  c,KZ   cpi  TZ   jz  MonitorExcRet   mvi  c,KSP   cpi  TSP   jz  MonitorExcRet   mvi  c,KCR   cpi  TCR   jz  MonitorExcRet   mvi  c,K0   cpi  T0   jz  MonitorExcRet   mvi  c,K1   cpi  T1   jz  MonitorExcRet   mvi  c,K2   cpi  T2   jz  MonitorExcRet   mvi  c,K3   cpi  T3   jz  MonitorExcRet   mvi  c,K4   cpi  T4   jz  MonitorExcRet   mvi  c,K5   cpi  T5   jz  MonitorExcRet   mvi  c,K6   cpi  T6   jz  MonitorExcRet   mvi  c,K7   cpi  T7   jz  MonitorExcRet   mvi  c,K8   cpi  T8   jz  MonitorExcRet   mvi  c,K9   cpi  T9   jz  MonitorExcRet   mvi  c,0MonitorExcRet:   mov  a,c   sta  KBBuffer   ret           ;  Register usage:     ;    On entry:	a  contains the number to be put in the panel.MPNumber:    mvi    d,0        mov    e,a        lhld  CFNumBias            dad d        ; put in bias of X00 + what a =MPNumberCall:    call	PutMPExt    ret      MPNumber2:    mov c,a    ani  0F0H    mvi l,0    mvi h,0    mvi d,0    mvi e,100    rrc    rrc    rrc    rrcMPNumber3:    cpi 0    jz  MPNumber4    dad d    dcr a    jmp MPNumber3MPNumber4:     mov a,c     ani  0FH     mov e,a     dad d     jmp    MPNumberCall 	    TimeDelay:    push   h    push   psw    lxi    h,DelayVU0TDelay:    mvi a,0    dcx  h    cmp l    jnz TDelay    cmp h    jnz TDelay    pop   psw    pop   h    ret;---------------- START of Program -------------------------   ;  Main command loop.EITestLoop:        call    TEIIndexAdd        mov	a,m		;  Get low byte        ani 80H        jnz   GetNextTest        lda TestN        call  MPNumber        lda CFBoot        cpi PrintP        jnz  EITestLoop2        lda TestN        sui	20	jm   ExtPrintSetUp        jmp  ExtVoiceSetUpEITestLoop2:        lda CFBoot        cpi UtilP        jnz  EITestLoop1        lda TestN        sui	8	jm	ExtRTCSetUp        sui	5	jm	ExtLSEPSetUp        sui	11	jm	ExtRS232SetUp        sui	6	jm	ExtLearSSetUp        sui	1	jm	ExtHOSTSetUp        sui	1	jm	EITestLoop1        sui	4        jp      ExtFSetUp        call EIOutPort                 jmp	ExtLSEPSetUpEITestLoop1:    call EIOutPort             call EIInPort      jmp MonitorTestDone	IndexM:    call TEIIndexAdd   ; Returns with TestN * 16 + EIIndexes in h and l    mvi e,13    mvi d,0    dad d             ; Should have TestN * 16 + EIIndexes +13 = UOBSERVED    mov a,m    RRC    ani 7FH    mov d,a    mov a,m    RRC    ani 80H    mov e,a    inx  h    mov a,m    RRC    ani 7FH    ora e    mov e,a    xchg     call MPNumberCall     call  TimeDelay    call TimeDelay    jmp CkLoopIn    	EIInPort:    call TEIIndexAdd   ; Returns with TestN * 32 + EIIndexes in h and l    mvi e,16    mvi d,0    lda CFBoot    cpi MemP    jnz   EIInPort1    dad d             ; Should have TestN * 32 + EIIndexes +16 = StopOnErrEIInPort1:           push d    push h    call MonitorKeyIn      pop  h    pop  d    in	CPStatus	;  Read the port interrupt bits    ani	CPInIntMask	;  CPIn requesting an interrupt?     jnz	EIInPort2		;  Zero means no interrupt    jmp	EIInPort1	EIInPort2:           in	CPIn		    mov m,a    mvi a,0    inx  h    dcr e    cmp e    jnz EIInPort1    ret	    EIOutPort:    call TEIIndexAdd   ; Returns with TestN * 32 + EIIndexes in h and l    lda CFTIndexF    mov e,aEIOutPort1:    push d    push h    call MonitorKeyIn      pop  h    pop  d    in	CPStatus	;  Read the port interrupt bits    ani	CPOutIntMask	;  CPOut requesting an interrupt, i.e data read?     jnz	EIOutPort2		;  Zero means no interrupt    jmp	EIOutPort1	EIOutPort2:    mov a,m    out	CPOut		;  Output data    mvi a,0    inx  h    dcr e    cmp e    jnz EIOutPort1    ret        EIDFault:       lda CFBoot   cpi MemP   jz  EISet3    cpi DiskP   jnz  EISet0 EIDFDisk:       lda  Conf   ani 0C0H   jz EISet1   cpi  80H   jz EISet2   cpi  40H   jz EISet3   jmp EISet7EISet0:       mvi a,0   jmp EIConfiguer1EISet1:       mvi a,1   jmp EIConfiguer1EISet2:       mvi a,2   jmp EIConfiguer1EISet3:       mvi a,3   jmp EIConfiguer1   EISet7:       mvi a,7   jmp EIConfiguer1      EIReport:       call  BlankIt   lda RInx   sta  AccuReg   call EIAccuH   lda CFReportF   mov e,a   lda AccuReg   ana e   sta  RInx   lda KBBuffer   cpi KSP   rz     call TEIIndexAdd   ; Returns with TestN * 32 + EIIndexes in h and l   lda RInx            mov e,a   mvi d,0   dad d             ; Should have TestN * 32 + EIIndexes +EIRinx   mov a,m   sta  AccuReg   call EIAccuH   call TEIIndexAdd   ; Returns with TestN * 32 + EIIndexes in h and l   lda RInx            mov e,a   mvi d,0   dad d             ; Should have TestN * 32 + EIIndexes +EIRinx   lda AccuReg   mov m,a   lda KBBuffer   cpi KSP   rz   lda CFReportF   mov e,a   lda RInx   inr a   ana e   sta RInx   jmp EIReport      TEIIndexAdd:    lxi  h,0    mvi d,0    lda CFTIndexF    mov e,a    lda TestNTEIIndexAdd1:    cpi 0    jz  TEIIndexAdd2    dad d    dcr a    jmp TEIIndexAdd1TEIIndexAdd2:     xchg     LXI h, EIIndexes     lda  CFBoot     sui  UtilP     jp  TEIIndexAdd3     LXI h, BootIndexesTEIIndexAdd3:     dad d     ret    EIShowTest:       lda TestNI   sta  AccuReg   call EIAccu   lda AccuReg   sta  TestNI   sta  TestN   call  BlankIt   lda TestNE   sta  AccuReg   call EIAccu   lda AccuReg   sta  TestNE   ret EIConfiguer:       lda ConfiguerF   sta  AccuReg   call EIAccu   cpi 2   lda CFBoot   mvi e,12   cpi BootP   jz Adjust   mvi c,12   mvi e,4   cpi BootP1   jz AdjustM   mvi c,16   mvi e,3   cpi BootP2   jz AdjustM   mvi c,19   mvi e,14   cpi BootP3   jz AdjustM   mvi e,31   jmp AdjustEIConfiguer1:       sta  ConfiguerF   mov e,a   mvi d,0   lxi h,CFConF   dad d   dad d   xchg   ldax d   sta TestNI   sta TestN   inx d   ldax d   sta TestNE   lda CFBoot   cpi MemP   jz  ExtSetSize    cpi DiskP   jnz MonitorSt   lda TestNI   cpi 1   jnz MonitorSt   sta IFlag   sta LoopIn   sta IgNor   call TEIIndexAdd   ; Returns with TestN * 16 + EIIndexes in h and l   inx  h   mvi a,1   mov m,a   jmp MonitorSt   AdjustM:       lda AccuReg   sub c   jm Adjust1   sta AccuRegAdjust:       lda AccuReg   mov c,a   mov a,e   sub c   jp Adjust2Adjust1:       mvi a,0    jmp EIConfiguer1Adjust2:       lda  AccuReg   jmp EIConfiguer1  EIAccuH:       mvi a,1   sta Hex   call EIAccu   mvi a,0   sta Hex   ret    EIAccu:       lda Hex   cpi 0   jnz  HexOut    call DecOut   jmp EIAccu1HexOut:       lda AccuReg   call  MPNumber2EIAccu1:       call  MonitorKeyIn   lda KBBuffer   cpi KCR   rz   cpi KSP   rz   call  EIConvert   lda KBBuffer   cpi 80H   jz  EIAccu1   sta AccuReg   lda Hex   cpi 0   jnz  HexOut1    call DecOut   jmp EIAccu2HexOut1:       lda AccuReg   call  MPNumber2EIAccu2:       call  MonitorKeyIn   lda KBBuffer   cpi KCR   rz   cpi KSP   rz   call  EIConvert   lda KBBuffer   cpi 80H   jz  EIAccu2   mov c,a   lda AccuReg   rlc   rlc   rlc   rlc   ora c   sta AccuReg   lda hex   cpi 0   jnz EIAccuEIAccDec:   lda AccuReg   mov c,a   ani 0F0HEIAccDec1:   mov e,a   cpi 0   jz EIAccu   mov a,c   sui 6   mov c,a   sta AccuReg   mov a,e   sui 10H   jmp EIAccDec1   DecOut:       lda AccuReg   mov l,a   mvi h,0   call  MPNumberCall   ret        EIConvert:   mvi  c,10   cpi  KA   jz  EIConvertRet   mvi  c,11   cpi  KB   jz  EIConvertRet   mvi  c,12   cpi  KC   jz  EIConvertRet   mvi  c,13   cpi  KD   jz  EIConvertRet   mvi  c,14   cpi  KE   jz  EIConvertRet   mvi  c,15   cpi  KF   jz  EIConvertRet   mvi  c,0   cpi  K0   jz  EIConvertRet   mvi  c,1   cpi  K1   jz  EIConvertRet   mvi  c,2   cpi  K2   jz  EIConvertRet   mvi  c,3   cpi  K3   jz  EIConvertRet   mvi  c,4   cpi  K4   jz  EIConvertRet   mvi  c,5   cpi  K5   jz  EIConvertRet   mvi  c,6   cpi  K6   jz  EIConvertRet   mvi  c,7   cpi  K7   jz  EIConvertRet   mvi  c,8   cpi  K8   jz  EIConvertRet   mvi  c,9   cpi  K9   jz  EIConvertRet   mvi  c,80HEIConvertRet:   mov  a,c   sta  KBBuffer   ret	          end@


1.1.1.1
log
@first add
@
text
@@
