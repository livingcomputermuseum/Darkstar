head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.25;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.25;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@{; MODULE = PreBootSource.asm found on [IRIS/WIND]<WDiag>PreBoot>3.0>************************************************************************************************** * * "Pre-boot" Diagnostics for Dandelion Diagnostic Package -  Input/Output Processor, 8085 * * Origional edit by J. JxP      on November 6, 1980  6:12 PM * Last edited by J. JxP      on March 9, 1982  7:59 PM * * Dennis DEG     :  2-Sep-84 15:31:47, add copyright notice. * ***************************************************************************************************}{ 	Copyright (C) 1980, 1982 by Xerox Corporation.  All rights reserved.}{ * If you want to soft test this code by loading it into RAM via Burdock, then: * 1) Comment out this line of code: * 		Jmp	RamTest			; Test 8085 Ram * 2) UnComment out this line of code: * 		Jmp	MoveLinkTableRAM	;  FOR DEBUG.	 * 3) Comment out this line of code: * 		Jmp	MoveLinkTableProm	; This routine will do a RET, fear not! * 4) Use PreBootEPromRAM.cfg to bind and PreBoot.burdock test with!}; Mainroutine [PreBootSource].		GET	"SysDefs.asm"	; From [IRIS]<Workstation>		GET	"BootDefs.asm"	; From [IRIS]<Workstation>		GET	"BootLinkDefs.asm"	; From [IRIS]<Workstation>AddrOffset0:	EQU	2000H	; Starting memory addr. depending upon which step #AddrOffset1:	EQU	2001H	; Starting memory addr. depending upon which step #AddrOffset2:	EQU	2002H	; Starting memory addr. depending upon which step #Alt10Offset:	EQU	43H	; = 67 decimal.Boot10:	EQU	0AH	;EnableFDC:	EQU	84H	;FirstCylinder:	EQU	0000H	; Storage length FirstMemAdr:	EQU	AddrOffset0	; First Memory Address.LastCylinder:	EQU	4CH	; Length:	EQU	4000H	; Storage length maxDelay:	EQU	0FFFFH	; Max count to pass the delay routine.NormalPreBootOffset:	EQU	0000H	; Value for MPOffset.Offset:	EQU	3H	; Value to increment by.PlaceForSP:	EQU	8088H	; Paying attention?? 				; These are the FDC Sector and Data registers.PsuedoBootEntry:		EQU	2000H	;MoveLinkTableRAM:		EQU	PsuedoBootEntry + (13*SizeLink)	; Has to be here for assembler!UpperBound:	EQU	60H	; Last address test. ; Imports and Exports		EXP	PreBootGo	; To ????????.asm (or To DebugOnly.asm)		EXP	CommonHalt	; To whatever module needs it!		IMP	ReadAltBoot	; From AltBoot.asm		IMP	I8085SelfTest	; From 8085SelfTest.asm		IMP	FDCTest	; From FDCTest.asm		IMP	TestIndexPulses	; From FDCTest.asm;		IMP	TPCTest	; From TPCTest.asm;		IMP	ControlStoreTest	; From ControlStoreTest.asm; Register usage:;		H,L - As noted below.;		D,E - As noted below.;		B,C -  As noted below.;;**************************************************************************************************; *; *  PreBoot main program.; *;**************************************************************************************************PreBootGo:			; PreBoot entry point MUST BE the first code				; addresss.  Until 8888 in displayed in MP the 8085				; world is not functioning.		call 	I8085SelfTest	; WARNING: Between "PreBootGo" and this line insert				; NO call(s)!		call 	GeneralRegTest	; Go check the hardware registers for use later.		pop	b	; Get the return address that called PreBoot.; Pay attention: You must use "jmp" to RamTest as you will smash the Stack Pointer when all of RAM is tested.		jmp	RamTest	; Test 8085 RamReturnFromRamTest:		lxi	sp,UserStkStart	; Re-initialize stack pointer to user stack area.		push	b	; Restore return address that called PreBoot.		call 	SavedLinkTableAddr	; Re-set up table of addresses in RAM.		call 	BootInitExt	; Re-set up Initialization code.		lxi	h, 22B8H	; Set MP to 8888 decimal.		call	PutMPExt	; Display it.		lxi	h, maxDelay	; Set max for about .5 sec.		call 	DelayExt	; Wait some time.		lxi	h, maxDelay	; Set max for about .5 sec.		call 	DelayExt	; Wait some time.		call	ReadAltBoot	; Go see if Alternate boot button is held down.		ora	a	; Get what the user selected if any.		jnz 	DoBoot10	; Go clean the floppy heads and don't return.		lxi	h,3CH	; Set MP to 0060 decimal.		call	PutMPExt	;		call	FDCtest	; Test Floppy Disk Controller.				; (Checks for floppy boot in routine)EndOfTests:		mvi	a,1H	; Initialize for "Boot" diagnostic.		sta	DiagBootI	;		mvi	a,3H	; Initialize for "Boot" diagnostic.		sta	DiagBootN	;		xra	a	; Clear A		sta	LoopC	; Initailize for "Boot" diagnostic.Exit:		lxi	h,0063H	; Put 0099 in MP, 		call	PutMPExt	; indicating tests successfully completed.		RET		; End of PreBoot testing.SavedLinkTableAddr:		;		jmp	MoveLinkTableProm	; This routine will do a RET, fear not!;		jmp	MoveLinkTableRAM	; FOR DEBUG. ;;**************************************************************************************************; *; *  Subroutine:  GeneralRegTest.; *  This test checks the contents of the IOP board hardware register AKA DMA Test Register. ; *  It increments the value in A into the register and compares it with the loop count value in B.; *  This test also checks the contents of the Floppy Disk Controller (FDC) Track, Sector and Data registers. ; *;**************************************************************************************************; Register usage:;		H,L - unused;		D,E - unused;		C   -  unused;		B   -  loop count value.GeneralRegTest:		xra	a	; Set A to initial test value.		mvi	b,0H	; Initialize loop value.GeneralRegLoop:		out	DmaTestReg	; Store it in register.		xra	a	; Clear A.		in	DmaTestReg	; input register.		cmp	b	; Compare it with B.  		jnz	GeneralRegTest	; Not zero => Error!		inr	a	; Increment the test value.		inr	b	; Increment the loop count.		jnz	GeneralRegLoop	; Not zero => not done yet.		mvi	a,EnableFDC	; Enable the FDC and leave it so.		out	FDCState	;ThreeRegAddrTest:		mvi	a,7	;		out	FDCTrack	; Store data in register		mvi	a,5	;		out	FDCSector	; Store data in register		mvi	a,3	;		out	FDCData	; Store data in register		xra	a	; Set A to 0.		in	FDCSector	; Read register		sui	5	;		jnz	ThreeRegAddrTest	; Zero yet?		in	FDCData	; Read register		sui	3	;		jnz	ThreeRegAddrTest	; Zero yet?		in	FDCTrack	; Read register		sui	7	;		jnz	ThreeRegAddrTest	; Zero yet?		RET		; ;;**************************************************************************************************; *; * Subroutine:  RamTest.;* CAUTION: Remember that this routine must be jumped to , DO NOT use a call as the User Stack Pointer in Ram will be smashed!;* If run from Prom, this code tests the whole IOP RAM, including the half page where the stack and;*   processor state are kept. Note that, the RAM is not used (other than being tested).;* 	If run from IOP Ram, this code tests the portion of IOP RAM;* 	that is not occupied by either the program itself or the kernel/stack area.;*;**************************************************************************************************; Register usage:;		H,L - memory address being tested;		D,E - byte count (length of (remaining) testable Ram);		C   -  data value for write/read tests;		B   -  test numberRamTest:		mvi	e,0	; Initialize test selection register to zero.NextStep:		inr	e	; Increment to next test number.		mov	a,e	;Step1:			;		cpi	1	;		jnz	Step2	;		lxi	h,AddrOffset1	; Get address to start with.		jmp	WriteStep0	;Step2:			;		cpi	2	;		jnz	Step3	;		lxi	h,AddrOffset2	; Get address to start with.		jmp	WriteStep0	;Step3:			;		cpi	3	;		jnz	Step4	;		lxi	h,AddrOffset0	; Get address to start with.		jmp	WriteStepF	;Step4:			;		cpi	4	;		jnz	Step5	;		lxi	h,AddrOffset1	; Get address to start with.		jmp	ReadStep0	;Step5:			;		cpi	5	;		jnz	Step6	;		lxi	h,AddrOffset1	; Get address to start with.		jmp	WriteStepF	;Step6:			;		cpi	6	;		jnz	Step7	;		lxi	h,AddrOffset2	; Get address to start with.		jmp	ReadStep0	;Step7:			;		cpi	7	;		jnz	Step8	;		lxi	h,AddrOffset0	; Get address to start with.		jmp	ReadStepF	;Step8:			;		cpi	8	;		jnz	Step9	;		lxi	h,AddrOffset1	; Get address to start with.		jmp	ReadStepF	;Step9:			;		cpi	9	;		jnz	Step10	;		lxi	h,AddrOffset0	; Get address to start with.		jmp	WriteStep0	;Step10:			;		cpi	10	;		jnz	Step11	;		lxi	h,AddrOffset0	; Get address to start with.		jmp	ReadStep0	;Step11:			;		cpi	11	;		jnz	Step12	;		lxi	h,AddrOffset2	; Get address to start with.		jmp	WriteStepF	;Step12:			;		cpi	12	;		jnz	ReturnFromRamTest	; DO NOT CHANGE FROM A JMP TEST!		lxi	h,AddrOffset2	; Get address to start with.ReadStepF:		mvi	d,0FFH	; Read 1's.		jmp	ReadStep	;ReadStep0:		mvi	d,0	; Read 0's.ReadStep:		lxi	sp,Offset	; Get offset to add to next memory address.ReadLoop:		mov	a,m	; Read pattern from memory.		xra	d	; Compare with pattern in D.		jnz	CommonHalt	;  was "Error"		dad	sp	; Increment pointer to next memory position.		mov	a,h	;		xri	UpperBound	; Check high part of byte address.		jnz	ReadLoop	; If H is not =/> 60, do it again.		jmp	NextStep	; Done.WriteStep0:		mvi	d,0	; Store 0's.		jmp	WriteStep	;WriteStepF:		mvi	d,0FFH	; Store 1's.WriteStep:		lxi	sp,Offset	; Get offset to add to next memory address.WriteLoop:		mov	m,d	; Store pattern in memory.		dad	sp	; Increment pointer to next memory position.		mov	a,h	; Increment byte counter.		xri	UpperBound	; Check high part of byte address.		jnz	WriteLoop	; If H is not =/> 60, do it again.		jmp	NextStep	; Done.CommonHalt:		HLT		;;;**************************************************************************************************; *;  Subroutine:  DoBoot10.;  This routine will cleanthe foppy heads disregrding the status.;  It will move the heads over th head cleaning diskette 15 times.  The code will then halt. The user MUST re-Boot.; *;**************************************************************************************************DoBoot10:		lxi	h, 4CH	; Set MP to 0076 decimal.		call	PutMPExt	; Display it.	WaitForUser:		in	MiscInput1	; See if user has....		ani	AltBootMask	; depressed ALT boot ....		jz	WaitForUser	; button to start.			lxi	h, NormalPreBootOffset	; Set Offset (really base!) to 0000 decimal if you loop.		shld	MPOffset	; You don't have to reset because we HLT!			call	TestIndexPulses	; Check index pulses to see if a floppy is loaded.		lxi	h, 4DH	; Set MP to 0077 decimal.		call	PutMPExt	; Display it.		lxi	h, Alt10Offset	; Set Offset (really base!) to 0067 decimal.		shld	MPOffset	; You don't have to reset because we HLT!		mvi	a,RestoreCmdNoV	; Get RestoreCommand....		sta	RestoreCom	;				call	FloppyInitExt	; do it. Possible Error codes are:				; MP 83 blinking.....No Floppy.				; MP 90 blinking.....Restore failed.		mvi	a,15	; Loop count.DoBoot10Loop:		out	DmaTestReg	; Store it in holding register.		mvi	a,LastCylinder	; Get Last Cylinder....		call	DoSeekLoop	; seek it.		mvi	a,FirstCylinder	; Get First Cylinder....		call	DoSeekLoop	; seek it.		in	DmaTestReg	; input Loop count.		dcr	a	; Decrment the loop		jnz	DoBoot10Loop	; Zero yet?		jmp	DoBoot10	; Does he want to do it again?DoSeekLoop:		sta	DCylinder	;		mvi	a,SeekCmdNoV	; Get Seek Command....		sta	SeekCom	;		call	DoSeekCmdExt	; do it. Possible Error codes are:				; MP 87 blinking.....Cylinder Number Too Big.				; MP 91 blinking.....Seek Failed.				; MP 92 blinking.....SeekHardError.		RET		;		END		; END PreBootSource.asm.@


1.1.1.1
log
@first add
@
text
@@
