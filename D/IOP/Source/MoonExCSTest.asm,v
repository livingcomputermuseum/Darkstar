head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.09;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.09;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@; Copyright (C) 1980  by Xerox Corporation. All rights reserved. ;  Test Programs for CP:  TPC, control store,CPport, and INSTRUCTION Tests.;  Last modification by ;  Modification History:;	- Created (June 4, 1980  12:59 PM)	get "SysDefs.asm"	; system defs (tests defs below)        get "MOONBootDefs.asm"	; system defs (tests defs below)        get "MOONBootLinkDefs.asm"	; system defs (tests defs below)        get "MOONLinkDefs.asm"	; system links         get "MOONSysDefs.asm"	; system defs         ;-----------------------------------------------------------------              jmp CSTestS    ;  Temporary data area.CSSeed:	db	00H	;  Seed for CS Data random number, or constant dataOutCSData:	db	0,0,0,0,0,0	;  Write control store data (6 bytes)Mode:	db	0	;  Program mode for tests (default: , Constant data)CBank:	db	0Save:	db	0;---------------- START of Program -------------------------;  Initialize.CSTestS:         lda Conf	 ani 6	 jz Done1	 rrc	 ani 3	 sta CBank        TestBank:       	call	Loader	call    TestStart	lda     CBank	cpi     0	jz      Done 	dcr	a	        sta    CBank	jmp     TestBank	TestStart:       	lda    TestN        cpi	   EXTPCDT        jz	   TPCTest        cpi	   EXCSCDTO        jz	   DoCSTest2        cpi	   EXCSCDTZ        jz	   DoCSTest1        cpi	   EXCSADT        jz	   DoCSTest3        cpi	   EXCSRDT        jz	   DoCSTest4Done:          mvi   a,0        sta     CBank	call	Loader	Done1:	mvi   a,0        sta   ObservedData        jmp	ExtLogPError	PortOut:	lda  ObservedData	sta  Save        lda     CBank	call	ExtWriteCPport	mvi  a,6        sta  ObservedData        in	CPStatus     ;  Check for error condition (CPAttn).	ani	CPAttnMask	jz	ExtLogPError	lda  Save	sta  ObservedData	retLoader:       call	ExtPhase1Entry       call	ExtStartCP       call	PortOut       call	ExtStartDelay       call	ExtStopCP       call	ExtTimeDelay       ret; TPC test.;  This test writes all the TPCs with a pattern and then reads and checks them.;  All 12 bit patterns are tested.TPCTest:    mvi a,0    sta ModeTPCTest1:    mvi	a,MaxTPCAddr	;  initialize TPC address    sta   Task	    call  DcxMaskWTPCTest2:    lda   Mode	    cpi	5		    jnz	WTPCTest4    lda   Task	    mov d,a    mov e,aWTPCTest4:    call   WriteTPC	;  Write the dataWTPCTest3:    lda   Task	    sui   10H		    sta   Task	    jp	WTPCTest2RTPCTest:    mvi   a,MaxTPCAddr	;  initialize TPC address    sta   Task	RTPCTest1:    mov c,a    call    ReadTPC	;  Read the data (returned in BC)    lda   Mode	    cpi	5		    jnz	RTPCTest3    lda   Task	    mov d,a    mov e,aRTPCTest3:    call    CheckTPC	;  Check data (breakpoints if error)RTPCTest2:    lda   Task	    sui   10H		    sta   Task	    jp	RTPCTest1    lda   Mode	    cpi	5		    jnz	TPCTest1	    RET    ReadTPC:	push d        call	ExtLeftAlignTPCAddr	; Left align 3 bits of address in C        out	TPCHigh	in	CS6		;  Separate TPCdata[0:3]	cma			;  complement	mov	d,a		;  High part to D	in	CS7		;  separate  TPCData[4:11]	cma			;  complement	mov	e,a		;  low part to E	xchg			;  Move to HL for store	shld	ObservedCSlow	;  Store returned data in TPC data area	pop  d        ret	DcxMask:    lda   Mode	    mvi  d,0FFH    cpi	1		    jz	DcxMaskRet    mvi  d,0AAH    cpi	2		    jz	DcxMaskRet    mvi  d,55H    cpi	3		    jz	DcxMaskRet    mvi  d,0DcxMaskRet:    inr a    sta   Mode	    mov a,d    mov e,a    ret    ;  Write TPC.;  On entry:;    TPC address is in C (3 bits right-justified).;    TPC data is in DE (12 bits right-justified).;  Format of TPCHigh (write):  TPCAddr[0:2],,TPCData[0:4]';  Format of TPCLow (write):  don't care,,TPCData[5:11]'WriteTPC:	push	b		;  Save B,C temporarily	call	ExtLeftAlignTPCAddr	; Left align 3 bits of address in C	ori 0        mov	a,e		;  Move TPC[4] into B for TPCHigh format	ral			;  TPC[4] into carry	mov	a,d		;  get high part	ral			;  TPC[4] into B[7]	cma			;  complement for port	ani	1FH		;  Clear High 3 bits	ora	c		;  OR in address	out	TPCHigh	;  Set address, high data	mov	a,e		;  Get low part (C[0] is don't care)	cma			;  complement for port	out	TPCLow	;  send low data, Write TPC	pop	b	ret;  Subroutine to check TPC values read in.;  Returned value is in ObservedCSlow, output value in DE.CheckTPC:	mov a,d	ani  0FH	mov  c,a	lda CBank	rlc	rlc	rlc	rlc	cma	ani 0F0H	ora  c	mov  c,a	lda	ObservedCSlow	;  Get low part of new data	cmp	e		;  check it with Correct data	jnz	CheckTPCErr	lda	ObservedCSHigh	;  Get high part of new data	cmp	c		;  check it with Correct data	rz	CheckTPCErr:	mov  d,c	xchg			;  Move to HL for store	shld	ExpectedCSLow	;  Store real data in TPC data area	mvi   a,0        sta    CBank	call	Loader	jmp   ExtLogTPCErrorDoCSTest1:	mvi a,ConstantDataVal    sta Mode    jmp CSTestDoCSTest2:	mvi a,ConstantDataVal    sta Mode    mvi a,0FFH    jmp CSTestDoCSTest3:	mvi a,  AddressDataVal    sta Mode    jmp CSTestDoCSTest4:    mvi a, RandomDataVal    sta Mode    jmp CSTest;  Control Store Test.;  This test writes control store with varying data, and then reads and checks the data.;  The type of data written depends on flags in Mode.;     Constant, Random:  Each CS location has the same byte repeated 6 times.;     Address in location:  Each CS location has the its address repeated 3 times.;  TPC register 6 is used to write/read the control store.;  Conventions:  C  contains the TPC address (3 bits right-justified);	          DE  contains the TPC data (12 bits right-justified)CSTest:	sta CSSeedCSTestStart:	mvi	a,60H	;  Use TPC address 6	NextTPCAddr:	sta	 Task        lhld	BootIndexes+1	;  start with initial address	xchg	lda	 CSSeed		;  Initialize seed for random number (or constant data)	sta	 ExpectedData        lda	BootIndexes+5	;  get WriteOK	cpi 0		;  Check forlower CSAddress 	jnz     WriteDoneNextCSWrite:	call	GetNextCSData	;  Data stored in OutCSData array	call	WriteTPC	;  Write the TPC slot with the control store address	call	WriteCS	;  Write data in OutCSData	lda mode        cpi  AddressDataVal        jnz   NextCSWrite1        call	InvertAddr	;  Write the inversion addressNextCSWrite1:	lda	BootIndexes+3	;  get ending address	xra	e		;  Check forlower CSAddress 	jnz     IncCSAddr	call      CheckKeyboard        lda	BootIndexes+4	;  get ending address	xra	d		;  Check for CSAddress greater than 4095	jz	WriteDone;  Go back to command loopIncCSAddr:	inx	d		;  Increment CSAddress	jmp	NextCSWrite	;  Do next CS address	WriteDone:	lda	BootIndexes+6	;  Get Read OK	cpi 0		;  Check forlower CSAddress 	rnz     		;  Finished writing control store.  Do read/checks.	lhld	BootIndexes+1	;  start with initial address	xchg	lda	 CSSeed		;  Initialize seed for random number (or constant data)	sta	ExpectedDataNextCSRead:	call	GetNextCSData	;  Data stored in OutCSData array	call	WriteTPC	;  Write the TPC slot with the control store address	call	ExtReadCS	;  Read data into InCSData	call	CheckCS	;  Check data (breakpoints if error)        lda	BootIndexes+3	;  get ending address	xra	e		;  Check forlower CSAddress 	jnz     IncCSAddr1	call      CheckKeyboard        lda	BootIndexes+4	;  get ending address	xra	d		;  Check for CSAddress greater than 4095	rz	;  Go back to command loopIncCSAddr1:	inx	d		;  Increment CSAddress	jmp	NextCSRead	;  Do next CS address        	CheckKeyboard:    push d    push h    call ExtMonitorKeyIn	    pop   h    pop   d    retInvertAddr:    push d    mvi  a,0FFH    xra   d    ani	0FH		;  Mask high part    mov d,a    mvi  a,0FFH    xra   e    mov e,a    call	GetNextCSData	;  Data stored in OutCSData array    call	WriteTPC	;  Write the TPC slot with the control store address    call	WriteCS	;  Write data in OutCSData    pop   d    ret; Subroutine to write a control store location.WriteCS:	lda   	OutCSData+0		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSa		;  Write it	lda   	OutCSData+1		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSb	lda   	OutCSData+2		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSc	lda   	OutCSData+3		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSd	lda   	OutCSData+4		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSe	lda   	OutCSData+5		;  Get byte	cma			;  [4]  Complement for CP LS240	out	CSf	ret;  Subroutine to generate next CS data byte.;  Check bits in Mode to determine whether constant, random, or address data.;  If constant, next data is in Data.;  If random, then next data is random.;  If address, next data is CS address.;  Random number generator simulates an 8-bit feedback shift register with;    equation x8 (MSB) = x4 xor x3 xor x2 xor x0.GetNextCSData:	push d        lda	 Mode		;  Check which data generation algorithm	cpi	 RandomDataVal	jz	DoRandomCSData	; z => random data	cpi	 AddressDataVal	; 	jz	DoAddressCSData	; z => Address data;Constant data.	lda	  ExpectedData		;  Get constant data to be written        mov	d,a			mov	e,a		        jmp DoAddressCSDataDoRandomCSData:	lda   ExpectedData		;  Get last value	add   d              ;[add d and e +11 sta inverse in e]		add   e        adi  11H	sta   ExpectedData		;  Save new value        mov	d,a        cma        mov	e,aDoAddressCSData:	mov	a,d		;  High part.	sta	 OutCSData+0	sta	 OutCSData+2	sta	 OutCSData+4	mov	a,e		;  Low part.	sta	 OutCSData+1	sta	 OutCSData+3	sta	 OutCSData+5	pop d        ret			;  RETURN; Subroutine to check the data in InCSData with OutCSData.;  For CP Rev. B, IOP Rev E, we have to check the following:;	In0	= Out0 (Checks rA, rB);	In1	= Out1 (Checks aS, aF, aD);	In2	= Out2 (Checks EP, CIn, EnSU, mem, fS);	In3	= Out3 (Checks fY, INIA[0:3]);	In4	= Out4 (Checks fX, INIA[4:7]);	In5	= Out5 (Checks fZ, INIA[8:11])CheckCS:	push	b		; Save B, C	push	d		; Save D, E	mvi    e,0   ;COUNT        lxi	h,OutCSData	lxi	b,InCSData+0CheckCS1:        ldax	b	cmp	m	jz	OkCSData        sta ObservedData        mov	a,m	sta ExpectedData	mov	a,e	rlc        rlc        rlc        rlc        ani  070H	mov	e,a	lda StopOnError	ani  8FH	ora   e	sta StopOnError	pop	d		; Restore D, E	xchg			;  Move to HL for store	lda CBank	rlc	rlc	rlc	rlc	ani 0F0H	ora h	mov h,a	shld	ExpectedCSLow		shld	ObservedCSlow	        mvi   a,0        sta     CBank	call	Loader	jmp	ExtLogDErrorOkCSData:	inx	h	inx	b	inr     e	mov	a,e	cpi     6        jnz	CheckCS1        pop	d		; Restore D, E	pop	b		; Restore B, C	ret       end@


1.1.1.1
log
@first add
@
text
@@
