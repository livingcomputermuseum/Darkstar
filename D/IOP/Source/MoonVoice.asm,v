head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 Xerox:1.1.1;
locks    ; strict;
comment  @;; @;


1.1
date     2001.08.12.22.22.12;  author freier;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2001.08.12.22.22.12;  author freier;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@; Copyright (C) 1980  by Xerox Corporation. All rights reserved. ;  Last modification by ;  Modification History:;	- Created (June 4, 1980  12:59 PM)	get "SysDefs.asm"	; system defs (tests defs below)        get "MOONBootDefs.asm"	; system defs (tests defs below)        get "MOONLinkDefs.asm"	; system links         get "MOONSysDefs.asm"	; system defs ;-----------------------------------------------------------------         jmp VoiceSetUp;---------------------------------------------;;    --------- Definitions ---------;VCont:	equ	0C0H	; Voice Control Register I/O AddressVStatusReg:	equ	0C0H	; Voice Status Register I/O AddressEnRst6:	equ	1DH	; Enable RST 6.5 onlyClrSpIntrReq:	equ	0C3H	; Clear Speech Interrupt RequestResetVoice:	equ	0C2H	; Reset Voice ControllerIntrReg:	equ	0E9H	; I/O Address of Interrupt Req Reg in IOPIntrMask:	equ	4	; Restart 6.5 bit in Interrupt Req RegInFifoORMask:	equ	8H	; Bit in Voice Status RegOutFifoIRMask:	equ	4H	; Bit in Voice Status Reg; { DMA }WriteChCtl:	equ	40H	; Dma Write Channel bitReadChCtl:	equ	80H	; Dma Read Channel bitEnCh2:	equ	4H	; Dma Mode: En Ch2EnCh3:	equ	8H	; Dma Mode: En Ch3TCStop:	equ	40H	; Dma Mode: Terminal-Count StopSpOutFifo:	equ	0C1H	; I/O address for Speech-Out FifoSpInFifo:	equ	0C1H	; I/O address for Speech-In FifoDisableDma:	equ	0DmaCh2EndCountMask:	equ	4DmaCh3EndCountMask:	equ	8; { Voice Uart }VUartData	equ	0CEH	; I/O address	VUartCtl	equ	0CFH	; I/O addressVUartStat	equ	0CFH	; I/O addressUartOff		equ	0TxEnable	equ	1HRxEnable	equ	4HIntReset	equ	40HDefaultCmd	equ	TxEnable+RxEnableVRxRdyMask	equ	80HVTxRdyMask	equ	40H; { Voice Control Reg }EnSpeechIn:	equ	80H	; Enable Speech-InEnSpeechOut:	equ	40H	; Enable Speech-OutEnFrameSync:	equ	20H	; Start Frame Sync and TimeSlot1 runningSelLoopBack:	equ	10H	; Select internal loopback thru mpaBaudRate300:	equ	0HBaudRate600:	equ	4HBaudRate1200:	equ	8HBaudRate2400:	equ	0CHRS232CIntr:	equ	0HSpeechDmaIntr:	equ	2HSpeechFifoIntr:	equ	3HSpByteCount:	db	0	; No. of bytes to be sent to/read from Fifo's (common use)SpOutData:	dw	FloppyBufSpInData:	dw	FloppyBuf+SectorLenSpOutCount:	db	0SpInCount:	db	0DmaModeWord:	db	0DmaStatWord:	db	0EndCountStatus:	db	0	Test:	db	0PassCount:	db	0	StopOnErr:	db	0	Initial:	db	0		Type:	db	0	Count:	db	0	VConWord:	db	0			VStatus:	db	0	UartStatus:	db	0Expected:	db	0	Observed:	db	0	VoiceFault:	db	0	; ;  	MAIN PROGRAM;  	---------  Initialize IOP  ---------VoiceSetUp:       LXI SP, UserStkStart       call ExtTEIIndexAdd   ; Returns with TestN * 16 + EIBuffer in h and l       mov	a,m		;         sta Test       inx  h       mov	a,m		;         sta PassCount       inx  h       mov	a,m		;         sta     StopOnErr       inx  h       mov	a,m		;         sta Initial       inx  h       mov	a,m		;         sta     Type       inx  h       mov	a,m		;         sta Count       inx  h       mov	a,m		;         sta    VConWord       mvi  a,0       sta  VStatus       sta  UartStatus       sta  Expected       sta  Observed       sta  VoiceFaultTestDecode:; Set up Mode inst for UART :  Asyn mode, 1 stop bit, no parity, 8 bit length, 16x        mvi	a,4EH       out	VUartCtl       lda Test       cpi 0       jz Test0       cpi 1       jz Test1       cpi 2       jz Test2       cpi 3       jz Test3LogIt:       LXI SP, UserStkStart       call ExtTEIIndexAdd   ; Returns with TestN * 16 + EIBuffer in h and l       mvi e,11       mvi d,0       dad d                    lda VStatus       mov	m,a		;         inx  h       lda UartStatus       mov	m,a		;         inx  h       lda Expected       mov	m,a		;         inx  h       lda Observed       mov	m,a		;         inx  h       lda VoiceFault       mov	m,a		;         cpi    0       jz     LogIt1       call ExtMonitorKeyIn         lda   StopOnErr       cpi 0       jnz   VoiceSetUpLogIt1:       call ExtMonitorKeyIn         lda   PassCount       dcr  a       sta   PassCount       jnz   TestDecode       mvi   a,0       out	VCont       jmp   ExtMonitorTestDone            		;  Connect loop-back connector to Voice Cable before start testing;    Test Sections:;  0. Write to Voice Control Reg and read from Voice Status Reg;  1. Test Voice UART;  2. Write and read FIFO's by polling Fifo interrupt;  3. Write and read FIFO's by polling DMA End-Count interrupt; ; Test0; Write to Voice Control Reg and read from Voice Status Reg;   The following signals are wrap back : SpeechInActive, SpeechOutActive, Speech/RS232C', Cpu/Dma'Test0:	lda	VConWord			out	VCont	in	VStatusReg	sta	VStatus        ani	33H		; Mask out bits that are not wrapped back	sta     Observed	mov    e,a	lda    Initial	sta    Expected	cmp	e	jz     LogIt	mvi    a,1	sta     VoiceFault	jmp     LogIt	 Test1:; Do an internal reset (by Command Inst) of UART to cause UART waiting for Mode inst	mvi	a,IntReset	out	VUartCtl; Set up Mode inst :  Asyn mode, 1 stop bit, no parity, 8 bit length, 16x	mvi	a,4EH	out	VUartCtl; Set up Command inst :  En Transmit, En Receive	mvi	a,DefaultCmd	; DefaultCmd = 5H	out	VUartCtl	lda	VConWord		; Set up internal or external loop back	out	VCont	lda	Count	sta	SpByteCount	; Clear counter        Lda	Initial		sta	ExpectedDoTransfer:	call	SendOneByte	call	CheckObserved	lda	SpByteCount	dcr	a		; increment counter		sta	SpByteCount        jz	LogIt	call    IncExpected	jmp	DoTransfer	IncExpected:	lda	Type	cpi     0	rz        Lda	Expected		inr     a	sta	Expected        ret	; Subroutine : SendOneByteSendOneByte:	nop; Transmit ExpectedVTxNotRdy:	mvi  d,2	mvi  e,VTxRdyMask        call    VWait	lda	Expected	out	VUartData; To receive dataVRxNotRdy:	mvi  d,3	mvi  e,VRxRdyMask        call    VWait	in	VUartData	sta	Observed; Check for transmission error	in	VUartStat	sta	UartStatus	ani	78H	; Look for Break detected, FE, OE, PE	rz	        sta      Observed	mvi      a,0	sta      Expected	mvi      a,4	jmp     StError	VWait:	push h        lxi	h,2000	;  ConstantVWaitLoop:	IN	VStatusReg      ; Watch Condition of UART        sta	VStatus        ana	e        JZ	VWaitExit	        dcx	h	mov	a,l		;  Check low	cpi	0	jnz	VWaitLoop	mov	a,h		;  Check high	cpi	0	jnz	VWaitLoop 	Lda     VStatus	sta      Observed        mov     a,e        sta      Expected        mov     a,d	jmp     StErrorVWaitExit:	pop h	ret	StError:    sta VoiceFault    jmp	LogIt      ; Subroutine : CheckObserved;   Compare one byte only,  Observed  vs  ExpectedCheckObserved:	lda	Observed	lxi	h,Expected	; Set up pointer to memory	cmp	m	rz			; If equal, return  (return on zero)	mvi      a,5	sta      VoiceFault	jmp      LogIt	; ; Test 2; Write and read FIFO's by polling Fifo interrupt ( InFifoOR  or  OutFifoIR )  for each byte; Set up VConWord ( = E3 or F3 ), ; Data read back from Speech-In-Fifo is stored in  SpInDataTest2:	lda     Initial	sta     Expected        call	PrepareSpOutData	call	ClearSpInData	call	WrRdFifoByPollingFifoIntr	call	CheckFifoData	jmp	logIt; Subrountine :  WrRdFifoByPollingFifoIntrWrRdFifoByPollingFifoIntr:	lhld    SpOutData	; Set up addr pointer for SpOutData in d & e	xchg	lhld    SpInData	; Set up addr pointer for SpInData in  h & l	lda     Count		; 	sta	SpOutCount	;	sta	SpInCount		;; Reset Voice Controller, then load VCon to enable Speech	mvi      a,0	out	ResetVoice	lda	VConWord		; en SpIn & SpOut, int loop, sel cpu interrupt (E3 or F3)	out	VContCheckIntr:	In	IntrReg	ani	IntrMask	jnz	CheckIntr	in	VStatusReg	sta	VStatusCheckInFifoOR:;	lda	VStatus	ani	InFifoORMask	jnz	CheckOutFifoIR	; If InFifo not OR, check OutFifo IR	lda	SpInCount		; Test for enough read	cpi	0	jz	CheckOutFifoIR	in	SpInFifo	mov	m,a		; Store SpIn at SpInData, pointer in  h & l	inx	h		; inc SpInData pointer	lda	SpInCount	dcr	a	sta	SpInCountCheckOutFifoIR:	lda	VStatus	ani	OutFifoIRMask	jnz	CheckBothCounts	lda	SpOutCount		; Test for enough write	cpi	0	jz	CheckBothCounts 	xchg		; Exchange  d,e <-->  h,l	mov	a,m	; Move data from SpOutData to a, pointer in  h & l	out	SpOutFifo	xchg	inx	d		; inc SpOutData pointer	lda	SpOutCount	dcr	a	sta	SpOutCount	jmp	CheckIntrCheckBothCounts:	lda	SpInCount		; Check to see if have done enough write	cpi	0		;   and read	jnz	CheckIntr	lda	SpOutCount	cpi	0	jnz	CheckIntrWrRdFifoByPollingFifoIntrDone:	mvi	a,0	out	VCont		; Disable Speech	ret		; ; Test 3; Write and read Fifo's with DMA;  Use polling to look for DmaEndCount interrupt; Set up VConWord ( = E2 or F2 ); Data read back from Speech-In-Fifo is stored in  SpInDataTest3:	lda     Initial	sta     Expected        call	PrepareSpOutData	call	ClearSpInData	call	WrRdFifoWithDmaEndCtPolled	call	CheckFifoData	jmp	LogIt; Subroutine :  WrRdFifoWithDmaEndCtPolledWrRdFifoWithDmaEndCtPolled:	mvi	a,0	sta	EndCountStatus	; Reset EndCountStatus	mvi	a,DisableDma	out	DmaMode		; Reset F/L flip flop in Dma Controller	in	DmaStatus	; Reset Dma Status Reg in Dma Controller	mvi	a,TCStop+EnCh2+EnCh3	sta	DmaModeWord	; Mode word for enable Ch2 and Ch3; Set up Dma starting address and byte-count	lhld    SpInData	; Set up pointer for SpInData in  h & l	call	SetUpDmaIn	lhld    SpOutData	; Set up pointer for SpOutData in  h & l	call	SetUpDmaOut; Reset Voice Controller, then load VCon to enable Speech,;  then enable DMA	out	ResetVoice	lda	VConWord		; en SpIn & SpOut, int loop or not, sel DMA interrupt (E2 or F2)	out	VContStartDma:	lda	DmaModeWord	out	DmaModePollEndCount:	In	IntrReg	ani	IntrMask	jnz	PollEndCount	mvi	a,DisableDma	out	DmaMode	out	ClrSpIntrReq	in	DmaStatus	sta	DmaStatWord	ani	DmaCh2EndCountMask	; Look for Ch2 End Count	jz	CheckCh3	lda	EndCountStatus	ori	DmaCh2EndCountMask	sta	EndCountStatusCheckCh3:	lda	DmaStatWord	ani	DmaCh3EndCountMask	; Look for Ch3 End Count	jz	CheckBothChEnd	lda	EndCountStatus	ori	DmaCh3EndCountMask	sta	EndCountStatusCheckBothChEnd:	lda	EndCountStatus	cpi	DmaCh2EndCountMask+DmaCh3EndCountMask	jz	BothChEndedReEnDma:	lda	DmaModeWord	lxi	h,EndCountStatus	xra	m		; ReEnable Ch which is not done	sta	DmaModeWord	jmp	StartDmaBothChEnded:	mvi	a,0	out	VCont		; Disable Speech	ret; Subroutine :  SetUpDmaInSetUpDmaIn:	mov	a,l		; low address byte	out	DmaCh2Addr	mov	a,h		; high address byte	out	DmaCh2Addr	lda	Count	dcr	a		; low count= Count - 1	out	DmaCh2Count	mvi	a,0		; high count	ori	WriteChCtl		; OR with Dma Ch Write mode	out	DmaCh2Count	ret; Subroutine :  SetUpDmaOutSetUpDmaOut:	mov	a,l		; low address byte	out	DmaCh3Addr	mov	a,h		; high address byte	out	DmaCh3Addr	lda	Count	dcr	a		;low count= Count - 1        out	DmaCh3Count	mvi	a,0		; high count	ori	ReadChCtl		; OR with Dma Ch Read mode	out	DmaCh3Count	ret; Subroutine :  CheckFifoData;   Check data received in  SpInData  vs  data sent in  SpOutData;   No. of bytes is specified in reg BCheckFifoData:	lhld    SpOutData	; Set up addr pointer for SpOutData in d & e	xchg			; Exchange  d,e <-->  h,l        lhld    SpInData	; Set up addr pointer for SpInData in  h & l	lda     Count	sta	SpByteCount	;  also use SpByteCount as counterCheckAgain:	xchg			; Exchange  d,e <-->  h,l	mov	a,m	; Move data from SpOutData to a, pointer in  h & l	sta     Expected	xchg			; Let  h,l  point to SpInData	cmp	m	jz	DataOK	mov	a,m		; Fifo data not compare	sta     Observed	mvi      a,6	sta      VoiceFault	jmp      LogIt	; See  SpInData  vs  SpOutData,  position in buffers is specified in SpByteCountDataOK:	mov	a,m		; Fifo data not compare	sta     Observed	lda	SpByteCount	dcr	a		sta	SpByteCount	rz	inx	d		; inc SpOutData pointer	inx	h		; inc SpInData pointer	jmp	CheckAgain; ;  Subroutine:  PrepareSpOutData;   Set Speech-Out-Data area to data pattern PrepareSpOutData:	lhld    SpOutData	; Set up pointer to SpOutData area	lda     Count	mov      e,aPrepareNextWord:	lda     Expected	mov	m,a		; Set up Speech-In data	dcr	e	rz		inx	h	call    IncExpected	jmp	PrepareNextWord;  Subroutine:  ClearSpInData; Clear the Speech-In-Data area to 0's;   No. of bytes is specified in reg BClearSpInData:	lhld    SpInData	; Set up pointer to SpInData area	mvi	c,0		; Set C = 0	lda     CountClearNextWord:	mov	m,c		; Set up Speech-In data	dcr	a	rz		inx	h	jmp	ClearNextWord	END	MoonVoice@


1.1.1.1
log
@first add
@
text
@@
